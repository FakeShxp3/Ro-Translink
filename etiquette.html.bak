<!DOCTYPE html>
<html class="no-js noFocus" data-page-has-site-header="" data-page-has-site-footer=""

  data-show-unsupported-browser-warning="" data-page-has-live-chat-button="" data-page-has-alerts-banner=""

  lang="en-CA">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <!-- IE Edge Mode META + Security META -->
    <meta http-equiv="X-UA-Compatible" content="IE=EDGE">
    <script class="show-xss-warning">
	; (() => {
		console.log("%c%s", "color: red; font-size: 24px;", "WARNING!");
		console.log("%c%s", "font-size: 18px;", "Please do not enter in any code into this console that you do not understand.\n\nDoing so could compromise your account and personal information.\n\nTransLink will never require you to open this console to use our website.");
	})();
</script> <!-- END OF IE Edge Mode META + Security META -->
    <!-- Debugging JS -->
    <script class="tlConsole">
        ; (() => {
            window.DBG_NAMESPACE = "dbg";

            window.DBG_COOKIE_NAME = "dbg=true";

            window.DBG_COOKIE_STRING = [
                window.DBG_COOKIE_NAME
                , "domain=translink.ca"
                , "samesite=strict"
                , "secure"
            ].join(";");

            window.IS_DBG = () => {
                return document.cookie.includes(window.DBG_COOKIE_NAME);
            };
        })();
    </script>
    <script>
        ; (() => {
            const STRING_TYPE = "[object String]";

            var mostRecentlyUsedTimerName;

            window.startTimer = timerName => {
                //GUARD: do nothing if the timer name isn't a valid string
                if (!timerName || timerName && Object.prototype.toString.call(timerName) !== STRING_TYPE) {
                    return false;
                }

                mostRecentlyUsedTimerName = timerName;

                var output = window.performance && window.performance.mark && window.performance.mark(timerName);

                return output;  //NOTE: return PerformanceMark object; "undefined"/falsy return value would imply that the timer did not start
            };

            window.getElapsedTimeInMilliseconds = (timerName, benchmarkName) => {
                var output;

                //NOTE: if the caller sends 'null' as the timer name, then it means they want to use the most recently used timer name passed to startTimer()
                if (timerName === null) {
                    timerName = mostRecentlyUsedTimerName;
                }

                //GUARD: do nothing if the timer name isn't a valid string
                if (!timerName || timerName && Object.prototype.toString.call(timerName) !== STRING_TYPE) {
                    return false;
                }

                //GUARD: do nothing if benchmark name exists, but is not a string
                if (benchmarkName && Object.prototype.toString.call(benchmarkName) !== STRING_TYPE) {
                    return false;
                }

                try {
                    var benchmarkData = window.performance && window.performance.measure && window.performance.measure(benchmarkName || timerName, timerName);

                    output = benchmarkData && benchmarkData.duration;

                    if (window.IS_DBG && window.IS_DBG() === true) {
                        //save to local storage so /dbg page can display the data
                        output && window.sessionStorage && window.sessionStorage.setItem(`${window.DBG_NAMESPACE}-timings-${benchmarkName}_${timerName}`, output);
                    }
                } catch (error) {
                    console.error(error);
                } finally {
                    return output;  //NOTE: returns the measured time; "undefined"/falsy return value would imply that the timer was not setup correctly;
                }
            };
        })();
    </script>
    <script class="start-user-timing-for-head-parsing">
        ; (() => {
            window.startTimer && window.startTimer("head-parsing-timer");
        })();
    </script>
    <!-- END OF Debugging JS -->
    <!-- Preload -->
    <link rel="preload" href="https://getaway.translink.ca/api/webbanneralerts"

      as="fetch" type="application/json" crossorigin="anonymous">
    <link rel="preload" href="api/sitenav-v3?menuId=7CB6E8FC-7592-4701-A2EB-448805B8E75A&amp;apiToken=59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8"

      as="fetch" type="application/json" crossorigin="anonymous">
    <script type="speculationrules">
	{
		"prerender": [{
			"source": "document"
			, "where": {
				"and": [
					{
						"href_matches": "/schedules-and-maps/route/*"
					}
					, {
						"not": {
							"href_matches": "?no-speculative-loading=true"
						}
					}
				]
			}
			, "eagerness": "eager"
		}]
	}
</script><script type="speculationrules">
	{
		"prerender": [{
			"source": "document"
			, "where": {
				"and": [
					{
						"href_matches": "/schedules-and-maps/line/*"
					}
					, {
						"not": {
							"href_matches": "?no-speculative-loading=true"
						}
					}
				]
			}
			, "eagerness": "eager"
		}]
	}
</script> <!-- END OF Preload -->
    <!-- Analytics Scripts -->
    <!-- END OF Analytics Scripts -->
    <!-- API Metadata -->
    <script>
        ; (function () {
            "use strict";

            window.codeo = window.codeo || {};
            window.codeo.searchIndex = ("sitecore_public_index");
            window.codeo.siteSuggesterPaths = "";
        })();
    </script>
    <!-- END OF API Metadata -->
    <!-- Content META -->
    <link rel="canonical" href="etiquette.html">
    <title>Etiquette on Transit | TransLink</title>
    <meta name="description" content="Learn about guidelines for a more safe and efficient trip.">
    <meta name="theme-color" content="#00355F" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#00355F" media="(prefers-color-scheme: dark)">
    <meta name="msapplication-TileColor" content="#FFFFFF">
    <!-- END OF Content META -->
    <!-- Favicons -->
    <link rel="icon" sizes="any" href="-/media/translink/icons/favicons/tl_leaper_favicon.png">
    <link rel="icon" type="image/svg+xml" sizes="32x32" href="-/media/translink/favicon/favicon.svg">
    <link rel="icon" type="image/svg+xml" sizes="180x180" href="-/media/translink/favicon/favicon.svg">
    <link rel="manifest" href="site.webmanifest">
    <link rel="mask-icon" href="-/media/translink/favicon/safari-pinned-tab.svg"

      color="#005DAA">
    <!-- END OF Favicons -->
    <!-- Global Head JS -->
    <script class="remove-skipto-if-in-iframe">
    ; (function () {
        "use strict";

        var curURL = window.location.href;

        //GUARD: do not run in:
        //sitecore admin panel
        if (curURL.indexOf("/sitecore/") > -1) {
            return;
        }

        var isInCrossOriginIFrame = false;

        try {
            var candidateParentURL = window.top && window.top.location && window.top.location.href;
        } catch (err) {
            isInCrossOriginIFrame = true;
        }

        //GUARD: do nothing if this page isn't in an iframe  //??? does this handle the case where the page is iframing itself?  do we even care about that case?  I think it would cause an infinite loop and out-of-memory erro
        if (isInCrossOriginIFrame === false && window.self.location.href === candidateParentURL) {
            return;
        }

        window.addEventListener("DOMContentLoaded", function () {
            "use strict";

            var skipToElement = document.querySelector('a[href="#content"]');

            skipToElement && skipToElement.remove();
        });
    })();
</script> <script class="hide-pwa-install-banner">
	; (() => {
		window.addEventListener("beforeinstallprompt", e => {
			e.preventDefault();
			return false;
		});
	})();
</script><script class="load-getdetails-as-early-as-possible">
	; (async () => {
		try {
			const AUTHED_MODULE_URL_STRING = "/js/authed.mjs";
			
			var authedModuleURL = AUTHED_MODULE_URL_STRING && new URL(AUTHED_MODULE_URL_STRING, document.location.origin);
			
			var { fetchIsAuthenticated, fetchAuthID, fetchAuthName } = authedModuleURL && await import(authedModuleURL);
			
			//NOTE: do nothing because we are just preloading  //??? but maybe this should be a timer?
		} catch (error) {
			console.error(error);
		}
	})();
</script><script>
	; (() => {
		//GUARD: do nothing if the browser does not support service workers
		if (!("serviceWorker" in navigator)) {
			return;
		}
		
		try {
			const SERVICE_WORKER_URL_STRING = "/sw.js";
			
			var serviceWorkerURL = SERVICE_WORKER_URL_STRING && new URL(SERVICE_WORKER_URL_STRING, document.location.origin);
			
			//GUARD: do nothing if there is no service worker URL
			if (!serviceWorkerURL) {
				return;
			}
			
			window.addEventListener("load", () => {
				navigator.serviceWorker.register(serviceWorkerURL);  //??? should we log whether or not the service worker completed?
			});
		} catch (error) {
			console.error(error);
		}
	})();
</script><script class="tlConsole">
	; (() => {
		window.DBG_NAMESPACE = "dbg";
		
		window.DBG_COOKIE_NAME = "dbg=true";
		
		window.DBG_COOKIE_STRING = [
			window.DBG_COOKIE_NAME
			, "domain=translink.ca"
			, "samesite=strict"
			, "secure"
		].join(";");
		
		window.IS_DBG = () => {
			return document.cookie.includes(DBG_COOKIE_NAME);
		};
	})();
</script><script class="tlHelpers">
	window.KEYCODE = {
		ENTER: 13
		, TAB: 9
		, SPACE: 32
		, UP_ARROW: 38
		, TOP_ARROW: 38  //NOTE: this is deprecated because of poor naming; please use UP_ARROW
		, RIGHT_ARROW: 39
		, DOWN_ARROW: 40
		, BOTTOM_ARROW: 40  //NOTE: this is deprecated because of poor naming; please use DOWN_ARROW
		, LEFT_ARROW: 37
		, ESC: 27
		, PAGE_UP: 33
		, PAGE_DOWN: 34
		, HOME: 36
		, END: 35
	};
	
	window.EMAIL_REGEX = /^[a-zA-Z0-9._%+-]{1,64}@([a-zA-Z0-9-]{1,63}\.)+[a-zA-Z]{2,63}$/;
	
	window.noop = () => { };
	
	window.getType = function (rawTarget) {
		"use strict";
		
		var undefinedOutput = window.getType.undefined;
		var nullOutput = window.getType.null;
		
		var target;
		
		if (arguments.length > 0) {
			target = rawTarget;
		} else if (this || this === "" || this === 0 || this === null) {
			target = this;
		}
		
		if (target === undefined) {
			return undefinedOutput;
		} else if (target === null) {
			return nullOutput;
		} else {
			return Object.prototype.toString.call(target);
		}
	};
	
	window.getType.object = "[object Object]";
	window.getType.array = "[object Array]";
	window.getType.nodelist = "[object NodeList]";
	window.getType.function = "[object Function]";
	window.getType.asyncFunction = "[object AsyncFunction]";
	window.getType.string = "[object String]";
	window.getType.number = "[object Number]";
	window.getType.bool = "[object Boolean]";
	window.getType.undefined = "undefined";
	window.getType.null = "null";
	window.getType.window = "[object Window]";
	window.getType.date = "[object Date]";
	
	window.isValidDate = target => {
		if (window.getType(target) === window.getType.date && window.isNaN(target) === false) {
			return true;
		}
		
		return false;
	};
	
	window.getAllChildNodes = (targetNode, output) => {
		//GUARD: do nothing if there is no current node or the current node does not support children (such as a text node)
		if (!targetNode || !targetNode.children) {
			return output;
		}
		
		//GUARD: do nothing if the output data store does not support 'add()'
		if (!output.add) {
			return output;
		}
		
		output.add(targetNode);
		
		var allChildrenNodes = targetNode.querySelectorAll("*");
		
		allChildrenNodes.forEach(curNode => {
			output.add(curNode);
		});
		
		return output;
	};
	
	window.deleteAllChildNodes = curNode => {
		var curChild = curNode.lastElementChild;
		
		while (curChild) {
			curNode.removeChild(curChild);
			
			curChild = curNode.lastElementChild;
		}
	};
	
	window.sanitizeID = target => {
		/*
			
			replace(/^\s+/g, "") - remove all whitespace that may have been missed by .trim()
			replace(/\s*\-/g, "-") - replace whitespace followed by a dash with a single dash
			replace(/-\s+/g, "-") - replace a dash followed by whitespace with a single dash
			replace(/\s+/g, "-") - replace a single whitespace with a single dash
			replace(/&/g, "and") - replace "&" with "and" because "&" is a reserved URL character
			replace(/\//g, "-") - replace "/" with a dash
			replace(/[^a-zA-Z0-9\-]+/g, "") - delete all characters except alphanumeric and dashes
			replace(/(-)\1{2,}/g, "-") - replace any repeated dashes with a single dash
			
		*/
		
		var output = target
		.trim()
		.toLowerCase()
		.replace(/^\s+/g, "")
		.replace(/\s*\-/g, "-")
		.replace(/-\s+/g, "-")
		.replace(/\s+/g, "-")
		.replace(/&/g, "and")
		.replace(/\//g, "-")
		.replace(/[^a-zA-Z0-9\-]+/g, "")
		.replace(/(-){2,}/g, "-")
		.trim();
		
		return output;
	};
	
	window.getDashDelimitedDateString = targetDate => {
		var output = [];
		
		if (targetDate) {
			var year = targetDate.getFullYear && targetDate.getFullYear();
			var month = targetDate.getMonth && (targetDate.getMonth() + 1).toString().padStart(2, "0");
			var date = targetDate.getDate && targetDate.getDate().toString().padStart(2, "0");
			
			if (year && month && date) {
				output.push(year);
				output.push(month);
				output.push(date);
			}
		}
		
		output = output.join("-");
		
		return output;
	};
	
	window.getDateObjectFromDateInput = dateInput => {
		var output;
		
		var dateInputValue = dateInput && dateInput.value;
		
		//GUARD: do nothing if there is no date input value
		if (!dateInputValue) {
			return output;
		}
		
		var dateInputValueParts = dateInputValue && dateInputValue.split("-");
		
		var dateYear = parseInt(dateInputValueParts[0], 10);
		var dateMonth = parseInt(dateInputValueParts[1], 10) - 1;
		var dateDate = parseInt(dateInputValueParts[2], 10);
		
		output = new Date(dateYear, dateMonth, dateDate);
		output = window.isValidDate(output) === true ? output : undefined;
		
		return output;
	};
	
	window.logger = output => {
		console.log(output);
	};
	
	window.logger.info = output => {
		console.info(output);
	};
	
	; (() => {
		var mostRecentlyUsedTimerName;
		
		window.startTimer = timerName => {
			//GUARD: do nothing if the timer name isn't a valid string
			if (!timerName || timerName && window.getType(timerName) !== window.getType.string) {
				return false;
			}
			
			mostRecentlyUsedTimerName = timerName;
			
			var output = window.performance && window.performance.mark && window.performance.mark(timerName);
			
			return output;  //NOTE: return PerformanceMark object; "undefined"/falsy return value would imply that the timer did not start
		};
		
		window.getElapsedTimeInMilliseconds = (timerName, benchmarkName) => {
			var output;
			
			//NOTE: if the caller sends 'null' as the timer name, then it means they want to use the most recently used timer name passed to startTimer()
			if (timerName === null) {
				timerName = mostRecentlyUsedTimerName;
			}
			
			//GUARD: do nothing if the timer name isn't a valid string
			if (!timerName || timerName && window.getType(timerName) !== window.getType.string) {
				return false;
			}
			
			//GUARD: do nothing if benchmark name exists, but is not a string
			if (benchmarkName && window.getType(benchmarkName) !== window.getType.string) {
				return false;
			}
			
			var benchmarkData = window.performance && window.performance.measure && window.performance.measure(benchmarkName || timerName, timerName);  //??? need to handle exceptions from this function
			
			output = benchmarkData && benchmarkData.duration;
			
			if (window.IS_DBG && window.IS_DBG() === true) {
				//save to local storage so /dbg page can display the data
				output && window.TemporaryStorage.setItem(DBG_NAMESPACE + "-timings-" + benchmarkName + "_" + timerName, output);
			}
			
			return output;  //NOTE: returns the measured time; "undefined"/falsy return value would imply that the timer was not setup correctly;
		};
	})();
	
	window.defineNameSpace = targetNameSpace => {
		if (window[targetNameSpace]) {
			//always merge when there is a namespace collision and always notify the developer/QA
			console.info(`Namespace '${targetNameSpace}' is already in use and a merge has been performed`);
		} else {
			//an empty object is the correct object for a new namespace
			window[targetNameSpace] = {};
		}
		
		//return a valid object/value instead of undefined; true/false codes do not make sense because there are no known exception/error cases
		return window[targetNameSpace];
	};
	
	window.runAfterDOMContentLoaded = (targetDocument, callbackFunction) => {
		//GUARD: do nothing if there is no target document or callback function
		if (!targetDocument || !callbackFunction) {
			return;
		}
		
		switch (targetDocument.readyState.toLowerCase()) {
			case "loading":
				targetDocument.addEventListener("DOMContentLoaded", callbackFunction);
				
				break;
			case "interactive":
			case "complete":
				callbackFunction();
				
				break;
		}  //??? missing a default-case to handle unexpected readyState AKA a weird error
	};
	
	window.runAfterLoad = (targetDocument, callbackFunction) => {
		//GUARD: do nothing if there is no target document or callback function
		if (!targetDocument || !callbackFunction) {
			return;
		}
		
		switch (targetDocument.readyState) {
			case "loading":
				window.addEventListener("load", callbackFunction);
				
				break;
			case "interactive":
			case "complete":
				callbackFunction();
				
				break;
		}  //??? missing a default-case to handle unexpected readyState AKA a weird error
	};
	
	window.runAfterPamMapLoad = (targetPamMapElement, callbackFunction) => {
		//GUARD: do nothing if there is no target iframe or callback function
		if (!targetPamMapElement || !callbackFunction) {
			return;
		}
		
		var isIFrameInited = targetPamMapElement.hasAttribute("data-is-loaded") && targetPamMapElement.getAttribute("data-is-loaded");
		
		if (isIFrameInited === "true") {
			callbackFunction && callbackFunction();
		} else {
			//??? replace with 'findDynamicComponent'?
			var waitForPamMapLoaded = new MutationObserver(() => {
				var isPamMapLoaded = targetPamMapElement.hasAttribute("data-is-loaded") && targetPamMapElement.getAttribute("data-is-loaded");
				
				if (isPamMapLoaded === "true") {
					callbackFunction && callbackFunction();
					
					waitForPamMapLoaded.disconnect();
				}
			});
			
			waitForPamMapLoaded.observe(targetPamMapElement, { attributes: true }); //??? should add attributes filter here
		}
	};
	
	window.createLazyLoader = options => {
		var wasLazyLoaderCreatedSuccessfully = false;
		
		var hitboxSizing = options.hitboxSizing || "0px 0px 0px 0px";
		var lazyLoadTargetSelectors = options.lazyLoadTargetList;
		var lazyLoadTargets = options.lazyLoadTargets;
		var onLoadFunction = options.onLoadFunction;
		
		//GUARD: do nothing if there is no callback or the callback value is not a sync-function or an async-function
		if (!onLoadFunction || (window.getType(onLoadFunction) !== window.getType.function && window.getType(onLoadFunction) !== window.getType.asyncFunction)) {
			return wasLazyLoaderCreatedSuccessfully;
		}
		
		//GUARD: do nothing if there is no list of elements or element-selector-strings for observing
		if (!lazyLoadTargets && !lazyLoadTargetSelectors) {
			return wasLazyLoaderCreatedSuccessfully;
		}
		
		if (window.getType(lazyLoadTargets) === window.getType.nodeList) {
			lazyLoadTargets = Array.from(lazyLoadTargets);
		}
		
		if (window.getType(lazyLoadTargets) !== window.getType.array) {
			lazyLoadTargets = [lazyLoadTargets];
		}
		
		if (window.getType(lazyLoadTargetSelectors) !== window.getType.array) {
			lazyLoadTargetSelectors = [lazyLoadTargetSelectors];
		}
		
		lazyLoadTargets = lazyLoadTargets.filter(x => x); //NOTE: "filter(x => x)" to remove empty strings and other falsey values
		lazyLoadTargetSelectors = lazyLoadTargetSelectors.filter(x => x); //NOTE: "filter(x => x)" to remove empty strings and other falsey values
		
		var allContainers = [].concat(lazyLoadTargets);
		
		lazyLoadTargetSelectors.forEach(selectorString => {
			var newContainers = selectorString && window.getType(selectorString) === window.getType.string && document.querySelectorAll(selectorString);
			
			newContainers = Array.from(newContainers);
			
			if (newContainers.length > 0) {
				allContainers = allContainers.concat(newContainers);
			}
		});
		
		allContainers = allContainers.filter(x => x); //NOTE: "filter(x => x)" to remove empty strings and other falsey values
		
		if ("IntersectionObserver" in window) {
			allContainers.forEach(curTarget => {
				var preLazyLoadAbortController = new AbortController();
				
				//if the target is inside an accordion, load the element when the accordion header is focused/hovered so the lazyloaded content begins loading before the accordion is opened (otherwise, the accordion will open without the lazyloaded content, then refresh/increase in height after the lazyloaded content is rendered)
				var parentAccordion = curTarget.closest("details");
				var parentAccordionHeader = parentAccordion && parentAccordion.querySelector("summary");
				
				parentAccordionHeader && parentAccordionHeader.addEventListener("focus", () => {
					if (window.getType(onLoadFunction) === window.getType.asyncFunction) {
						; (async () => {
							await onLoadFunction(curTarget); 
						})();
					} else {
						onLoadFunction && onLoadFunction(curTarget);
					}
					
					preLazyLoadAbortController && preLazyLoadAbortController.abort && preLazyLoadAbortController.abort();
					lazyLoader && lazyLoader.unobserve && lazyLoader.unobserve(curTarget);
				}, {
					signal: preLazyLoadAbortController.signal
				});
				
				parentAccordionHeader && parentAccordionHeader.addEventListener("mouseover", () => {
					if (window.getType(onLoadFunction) === window.getType.asyncFunction) {
						; (async () => {
							await onLoadFunction(curTarget); 
						})();
					} else {
						onLoadFunction && onLoadFunction(curTarget);
					}
					
					preLazyLoadAbortController && preLazyLoadAbortController.abort && preLazyLoadAbortController.abort();
					lazyLoader && lazyLoader.unobserve && lazyLoader.unobserve(curTarget);
				}, {
					signal: preLazyLoadAbortController.signal
				});
				
				//if the target is inside an tab, load the element when the tab is focused/hovered so the lazyloaded content begins loading before the tab is opened (otherwise, the tab will open without the lazyloaded content, then refresh/increase in height after the lazyloaded content is rendered)
				var parentTabPanel = curTarget.closest('[role="tabpanel"]');
				var parentTabHeaderID = parentTabPanel && parentTabPanel.hasAttribute("aria-labelledby") && parentTabPanel.getAttribute("aria-labelledby");
				var parentTabHeader = parentTabHeaderID && document.querySelector(`button#${parentTabHeaderID}[role="tab"]`);
				
				parentTabHeader && parentTabHeader.addEventListener("focus", () => {
					if (window.getType(onLoadFunction) === window.getType.asyncFunction) {
						; (async () => {
							await onLoadFunction(curTarget); 
						})();
					} else {
						onLoadFunction && onLoadFunction(curTarget);
					}
					
					preLazyLoadAbortController && preLazyLoadAbortController.abort && preLazyLoadAbortController.abort();
					lazyLoader && lazyLoader.unobserve && lazyLoader.unobserve(curTarget);
				}, {
					signal: preLazyLoadAbortController.signal
				});
				
				parentTabHeader && parentTabHeader.addEventListener("mouseover", () => {
					if (window.getType(onLoadFunction) === window.getType.asyncFunction) {
						; (async () => {
							await onLoadFunction(curTarget); 
						})();
					} else {
						onLoadFunction && onLoadFunction(curTarget);
					}
					
					preLazyLoadAbortController && preLazyLoadAbortController.abort && preLazyLoadAbortController.abort();
					lazyLoader && lazyLoader.unobserve && lazyLoader.unobserve(curTarget);
				}, {
					signal: preLazyLoadAbortController.signal
				});
				
				//init the lazy loader
				var intersectionConfig = {
					rootMargin: hitboxSizing  //??? is this really needed if the user doesn't pass a custom value?  the default for rootMargin is "0px" anyways
				};
				
				var lazyLoader = new IntersectionObserver(entries => {
					entries.forEach(entry => {
						var target = entry.target;
						
						if (entry.intersectionRatio > 0) {
							if (preLazyLoadAbortController.signal.aborted === false) {
								if (window.getType(onLoadFunction) === window.getType.asyncFunction) {
									; (async () => {
										await onLoadFunction(target); 
									})();
								} else {
									onLoadFunction && onLoadFunction(target);
								}
							}
							
							preLazyLoadAbortController && preLazyLoadAbortController.abort && preLazyLoadAbortController.abort();
							lazyLoader && lazyLoader.unobserve && lazyLoader.unobserve(target);
						}
					});
				}, intersectionConfig);
				
				lazyLoader.observe(curTarget);
				
				wasLazyLoaderCreatedSuccessfully = true;
			});
		} else {
			allContainers.forEach(target => {
				if (window.getType(onLoadFunction) === window.getType.asyncFunction) {
					; (async () => {
						await onLoadFunction(target); 
					})();
				} else {
					onLoadFunction && onLoadFunction(target);
				}
			});
		}
		
		return wasLazyLoaderCreatedSuccessfully;
	};
	
	window.findDynamicComponent = options => {
		var parentContainerNode = options.parentContainerNode;
		var parentContainerSelectorString = options.parentContainer;
		var targetSelectorString = options.targetSelector;
		var targetMutationObserverChangeTypes = options.targetChanges;
		var callbackFunction = options.callbackFunction;
		var watchedAttributes = options.watchedAttributes;
		var runOnce = options.runOnce || false;
		
		var callbackHasRunOnce = false;
		
		//GUARD: do not run if there is no explicitly stated container; this is an important performance consideration
		if (!parentContainerNode && !parentContainerSelectorString || parentContainerSelectorString && window.getType(parentContainerSelectorString) !== window.getType.string) {
			return false;
		}
		
		var parentContainerElement = parentContainerNode || parentContainerSelectorString && document.querySelector(parentContainerSelectorString);
		
		//GUARD: do nothing if no parent container was found
		if (!parentContainerElement) {
			return;
		}
		
		//GUARD: do not run if there is no target element selector
		if (!targetSelectorString || window.getType(targetSelectorString) !== window.getType.string) {
			return false;
		}
		
		//GUARD: do not run if there is no callback function
		//??? should FDC be updated to accept async functions?
		if (!callbackFunction || window.getType(callbackFunction) !== window.getType.function) {
			return false;
		}
		
		var config = targetMutationObserverChangeTypes && targetMutationObserverChangeTypes.reduce && targetMutationObserverChangeTypes.reduce((output, curTargetChange) => {
			var newValue = true;
			
			switch (curTargetChange) {
				case "attributeFilter":
					; (() => {
						//??? maybe remove all non-strings from watchedAttributes earlier?
						var validWatchedAttributes = watchedAttributes && watchedAttributes.filter && watchedAttributes.filter(curWatchedAttribute => {
							return window.getType(curWatchedAttribute) === window.getType.string;
						});
						
						newValue = validWatchedAttributes || newValue;
					})();
					
					//break;  //NOTE: intentional passthrough
				case "subtree":
				case "childList":
				case "attributes":
				case "attributeOldValue":
				case "characterData":
				case "characterDataOldValue":
					; (() => {
						output[curTargetChange] = newValue;
					})();
					
					break;
			}
			
			return output;
		}, {}) || {
			childList: true
			, subtree: true
			, attributes: true
		};
		
		var handleMutations = allMutations => {
			allMutations.forEach(curMutation => {
				var curIndex = 0;
				
				var runCallback = (curResult, index) => {
					//GUARD: do nothing if the current target is not a target node or is a text node
					if (!curResult.matches || curResult.matches(targetSelectorString) === false) {
						return;
					}
					
					callbackFunction && callbackFunction(curResult, curIndex);
					
					callbackHasRunOnce = true;
					
					curIndex = curIndex + 1;
				};
				
				//we have to disconnect and then reconnect to prevent potential issues with the callback triggering a change and then causing an excessively-long loop
				observer.disconnect();
				
				var allAddedNodes = curMutation.addedNodes;
				allAddedNodes = allAddedNodes && window.getType(allAddedNodes) !== window.getType.array && Array.from(allAddedNodes);
				
				if (allAddedNodes && allAddedNodes.forEach) {
					//??? is it necessary to loop over allAddedNodes twice?
					var foundChildNodes = new Set();
					
					allAddedNodes.forEach(curAddedNode => {
						window.getAllChildNodes && window.getAllChildNodes(curAddedNode, foundChildNodes);
					});
					
					var allChildrenNodes = Array.from(foundChildNodes);
					
					allAddedNodes.forEach(runCallback);
					allChildrenNodes && allChildrenNodes.forEach && allChildrenNodes.forEach(runCallback);
					runCallback(curMutation.target, curIndex);
				}
				
				if (!(runOnce && callbackHasRunOnce) && parentContainerElement) {
					//reattach the observer once the callback has finished running
					observer.observe(parentContainerElement, config);
				}
			});
		};
		
		var observer = new MutationObserver(handleMutations);
		
		observer.observe(parentContainerElement, config);
		
		var allFoundTargetElements = targetSelectorString && parentContainerElement.querySelectorAll(targetSelectorString);
		
		allFoundTargetElements && Array.from(allFoundTargetElements).forEach((curTarget, index) => {
			callbackFunction && callbackFunction(curTarget, index);
		});
		
		return true;
	};
	
	; (function () {
		window.setPassiveEventListener = false;
		
		try {
			var opts = Object.defineProperty({}, "passive", {
				get: function () {
					setPassiveEventListener = {
						passive: true
					};
				}
			});
			
			window.addEventListener("testPassive", null, opts);
			window.removeEventListener("testPassive", null, opts);
		} catch (error) {
			console.error(error);
		}
	})();
</script><script class="tlhelpers-shame">
	; (() => {
		window.ZERO_WIDTH_WHITESPACE_CHAR = "/&#8203;";  //NOTE: this is a bug: it shouldn't have the / in front of it; use window.ZERO_WIDTH_SPACE_CHAR instead
		window.ZERO_WIDTH_SPACE_CHAR = "&#8203;";
		
		window.getNearestParentByTag = (targetChild, parentTag) => {
			//??? can this be replaced with .closest()?
			var candidateParentNode = targetChild.parentElement;
			
			while (candidateParentNode && candidateParentNode.tagName !== parentTag) {
				candidateParentNode = candidateParentNode.parentElement;
			}
			
			return candidateParentNode;
		};
		
		window.getAllParentsByTag = (targetChild, parentTag) => {
			var output = [];
			
			var candidateParentNode = targetChild.parentElement;
			
			while (candidateParentNode) {
				if (candidateParentNode.tagName === parentTag) {
					output.push(candidateParentNode);
				}
				candidateParentNode = candidateParentNode.parentElement;
			}
			
			return output;
		};
		
		window.getDirectChildrenByTag = (parent, targetChildTagName) => {
			var output = Array.from(parent.children).filter(curChild => {
				return curChild.tagName === targetChildTagName;
			});
			
			return output;
		};
		
		window.binaryCountoffToArray = (value, numFlags) => {
			var output = [];
			
			for (var p = numFlags - 1; p > 0; p--) {
				var currentModuloValue = Math.pow(2, p);
				var adjustedCurValue = value - currentModuloValue;
				
				if (adjustedCurValue >= 0) {
					output[p] = true;
					
					value = adjustedCurValue;
				} else {
					output[p] = false;
				}
			}
			
			if (value === 1) {
				output[0] = true;
			} else {
				output[0] = false;
			}
			
			return output;
		};
		
		window.MONTHS = [
			"January"
			, "February"
			, "March"
			, "April"
			, "May"
			, "June"
			, "July"
			, "August"
			, "September"
			, "October"
			, "November"
			, "December"
		];
		
		window.SHORT_MONTHS = [
			"Jan"
			, "Feb"
			, "Mar"
			, "Apr"
			, "May"
			, "Jun"
			, "Jul"
			, "Aug"
			, "Sep"
			, "Oct"
			, "Nov"
			, "Dec"
		];
		
		window.DAYS_OF_WEEK = [
			"Sunday"
			, "Monday"
			, "Tuesday"
			, "Wednesday"
			, "Thursday"
			, "Friday"
			, "Saturday"
		];
		
		window.SHORT_DAYS_OF_WEEK = [
			"Sun"
			, "Mon"
			, "Tue"
			, "Wed"
			, "Thu"
			, "Fri"
			, "Sat"
		];
		
		window.buildDateString = dateString => {
			var SHORT_MONTHS = window.SHORT_MONTHS;
			
			//??? need to add much more validation here
			
			var dateTime = new Date(dateString);
			var dateTimeDate = (dateTime.getDate().toString().length == 1 ? "0" : "") + dateTime.getDate().toString();
			dateTimeDate = parseInt(dateTimeDate, 10).toString();
			var dateTimeMonth = SHORT_MONTHS[dateTime.getMonth()];
			var dateTimeYear = dateTime.getFullYear();
			
			return `${dateTimeDate}-${dateTimeMonth}-${dateTimeYear}`;
		};
		
		window.buildTimeString = timeString => {
			var timeStringParts = timeString.split(":");
			
			var timeHour = parseInt(timeStringParts[0], 10) % 12;
			var timeMinutes = parseInt(timeStringParts[1], 10) % 60;
			
			var timeAmPm = parseInt(timeStringParts[0], 10) % 24 < 12 ? "am" : "pm" ;
			
			var formattedTimeHourString = timeHour === 0 ? "12" : timeHour.toString();
			
			return `${formattedTimeHourString}:${timeMinutes.toString().padStart(2, "0")} ${timeAmPm}`;
		};
		
		window.buildDateTimeString = dateTimeString => {
			var SHORT_MONTHS = window.SHORT_MONTHS;
			
			var dateTime = new Date(dateTimeString);
			var dateTimeDate = (dateTime.getDate().toString().length == 1 ? "0" : "") + dateTime.getDate().toString();
			dateTimeDate = parseInt(dateTimeDate, 10).toString();
			var dateTimeMonth = SHORT_MONTHS[dateTime.getMonth()];
			var dateTimeYear = dateTime.getFullYear();
			var hour = dateTime.getHours();
			var ampm = "pm";
			
			if (hour < 12) {
				ampm = "am";
			}
			
			if (hour === 0) {
				hour = 12;
			} else if (hour > 12) {
				hour = hour - 12;
			}
			
			var dateTimeHour = hour.toString();
			var dateTimeMinutes = (dateTime.getMinutes().toString().length == 1 ? "0" : "") + dateTime.getMinutes().toString();
			var dateTimeAmPm = ampm;
			
			return `${dateTimeDate}-${dateTimeMonth}-${dateTimeYear} ${dateTimeHour}:${dateTimeMinutes} ${dateTimeAmPm}`;
		};
		
		; (() => {  //??? module-candidate
			const justNowCutoffInMinutes = 2;
			const justNowString = "Just now";
			const minutesAgoCutoffInMinutes = 60;
			const minutesAgoString = "minutes ago";
			const hoursAgoCutoffInHours = 3;
			const hoursAgoString = "hour ago";
			const hoursAgoPluralString = "hours ago";
			
			const MINUTE_IN_MILLISECONDS = 60000;
			const HOUR_IN_MILLISECONDS = 3600000;
			var SHORT_MONTHS = window.SHORT_MONTHS;
			
			window.buildLastModifiedDateTimeString = lastModifiedString => {
				var lastModified = new Date(lastModifiedString);
				var diffMin = Math.floor((Date.now() - lastModified) / MINUTE_IN_MILLISECONDS);
				var diffHour = Math.floor((Date.now() - lastModified) / HOUR_IN_MILLISECONDS);
				
				if (diffMin < justNowCutoffInMinutes) {
					return justNowString;
				} else if (diffMin < minutesAgoCutoffInMinutes) {
					return `${diffMin} ${minutesAgoString}`;
				} else if (diffHour < hoursAgoCutoffInHours) {
					return diffHour + " " + (diffHour === 1 ? hoursAgoString : hoursAgoPluralString);
				}
				
				var hour = lastModified.getHours();
				var ampm = "pm";
				
				if (hour < 12) {
					ampm = "am";
				}
				
				if (hour === 0) {
					hour = 12;
				} else if (hour > 12) {
					hour = hour - 12;
				}
				
				var lastModifiedDate = lastModified.getDate().toString();
				var lastModifiedMonth = SHORT_MONTHS[lastModified.getMonth()];
				var lastModifiedYear = lastModified.getFullYear();
				var lastModifiedHour = hour.toString();
				var lastModifiedMinutes = lastModified.getMinutes().toString().padStart(2, "0");
				var lastModifiedAmPm = ampm;
				
				return `${lastModifiedDate}-${lastModifiedMonth}-${lastModifiedYear} ${lastModifiedHour}:${lastModifiedMinutes} ${lastModifiedAmPm}`;
			};
		})();
		
		window.buildParagraphElementFromText = text => {
			var output = document.createElement("p");
			
			//GUARD: return empty <p> if the provided text is not valid
			if (!text || window.getType(text) !== window.getType.string) {
				return output;
			}
			
			var allTextSegments = text.replace(/\r/g, "").split("\n").filter(x => x); //NOTE: "filter(x => x)" to remove empty strings and other falsey values
			
			allTextSegments && allTextSegments.forEach((curTextSegment, idx) => {
				var newTextNode = document.createTextNode(curTextSegment);
				
				output.append(newTextNode);
				
				if (idx < allTextSegments.length - 1) {  //only add <br> in-between text nodes, so don't run this if the current text node is the last one
					//NOTE:  we need two <br> to make an empty line
					output.append(document.createElement("br"));
					output.append(document.createElement("br"));
				}
			});
			
			return output;
		};
		
		window.bestEffort_GetFormSubmitter = submitEvent => {
			var output;
			
			var target = submitEvent.target;
			
			var formName = target && target.getAttribute("id");
			
			output = submitEvent.submitter || document.querySelector(`[type="submit"][form="${formName}"], form[id="${formName}"] [type="submit"]`);
			
			return output;
		};
	})();
</script><script class="tl-helpers-webform-helpers-shame">
	; (() => {
		window.SELECT_ELEMENT_VALUE_CHANGE_EVENT = "ApplePaySession" in window ? "blur" : "change";
		
		window.getFetchURLFromFormElement = targetFormElement => {
			var targetAPIURL;
			
			try {
				var targetAPIURLString = targetFormElement.hasAttribute("data-fetch-action") && targetFormElement.getAttribute("data-fetch-action") || targetFormElement.hasAttribute("action") && targetFormElement.getAttribute("action");
				
				targetAPIURL = targetAPIURLString && new URL(targetAPIURLString);
			} catch (error) {
				console.error(error);
			} finally {
				return targetAPIURL;  //??? shouldn't this return undefined rather than false?
			}
		};
		
		window.getFetchOptionsFromFormElement = (targetFormElement, additionalOptions) => {
			var output = {};
			
			var targetHTTPVerb = targetFormElement.hasAttribute("data-fetch-method") && targetFormElement.getAttribute("data-fetch-method") || targetFormElement.hasAttribute("method") && targetFormElement.getAttribute("method");
			
			if (targetHTTPVerb) {
				output.method = targetHTTPVerb;
			}
			
			if (additionalOptions && additionalOptions.setContentTypeToJSON === true) {
				output.headers = output.headers || {};
				
				output.headers["Content-Type"] = "application/json";
			}
			
			return output;
		};
	})();
</script><script class="tlbuilder">
	; (() => {
		window.injectHTMLTemplateContentInPlace = targetTemplateID => {
			var templateElement = document.getElementById(targetTemplateID);
			var templateElementContent = templateElement && templateElement.tagName === "TEMPLATE" && templateElement.content;
			
			if (templateElementContent) {
				var allContentElements = Array.from(templateElementContent.children);
				
				allContentElements.forEach(curContentElement => {
					templateElement.insertAdjacentElement("afterend", curContentElement);
				});
			}
		};
		
		window.buildDayPicker = (dayLabel, dayValue, formID, isReadOnly, isSelected) => {
			var daySelector = document.createElement("label");
			daySelector.setAttribute("class", "flexContainer flexColumn horizontallyCenteredContent");
			daySelector.setAttribute("style", "flex-direction: column-reverse;");
			
			var daySelectorLabel = document.createElement("span");
			daySelectorLabel.setAttribute("data-role", "p");
			daySelectorLabel.textContent = dayLabel;
			
			var daySelectorCheckbox = document.createElement("input");
			daySelectorCheckbox.setAttribute("type", "checkbox");
			formID && daySelectorCheckbox.setAttribute("form", formID);
			daySelectorCheckbox.setAttribute("name", "dayOfWeek");
			daySelectorCheckbox.setAttribute("value", dayValue);
			isSelected && daySelectorCheckbox.setAttribute("checked", "");
			isReadOnly && daySelectorCheckbox.setAttribute("disabled", "");
			
			daySelector.append(daySelectorCheckbox);
			daySelector.append(daySelectorLabel);
			
			return daySelector;
		};
		
		window.buildDayOfWeekPicker = (formID, isReadOnly, selectedDaysOfWeek) => {
			var output = document.createElement("div");
			output.classList = `${output.classList} DaysOfWeek contentItem flexContainer fullyJustifiedContent`;
			
			window.DAYS_OF_WEEK.forEach((curDay, idx) => {
				var isSelected = selectedDaysOfWeek && selectedDaysOfWeek[idx];
				
				var curDayPicker = buildDayPicker(curDay.substring(0, 3), curDay, formID, isReadOnly, isSelected);
				
				output.append(curDayPicker);
			});
			
			return output;
		};
		
		window.buildAlertAccordion = (targetAlert, renderOnlyTodayAlerts) => {
			var gtfsItemName = targetAlert.routeLongName || targetAlert.stationName;
			var gtfsRouteLineNumber = targetAlert.routeId;
			var targetTimeframe = renderOnlyTodayAlerts === true ? "today" : "all";  //??? unhardcode somehow
			
			//GUARD: do nothing if the item does not have a name
			if (!gtfsItemName) {
				return;
			}
			
			var output = document.createElement("details");
			
			if (gtfsRouteLineNumber) {
				//if the route ID starts with a number, make sure it is padded with leading zeros to make the route number 3-digits long.  Otherwise, just return the route ID.
				var routeNumberString = gtfsRouteLineNumber.match(/^\d/) ? gtfsRouteLineNumber.padStart(3, "0") : gtfsRouteLineNumber;
				
				output.setAttribute("data-route-number", routeNumberString);
			}
			
			var newAlertHeader = document.createElement("summary");
			
			var newAlertHeaderLayoutContainer = document.createElement("div");  //NOTE: needed because <summary> cannot be flex container in iOS
			newAlertHeaderLayoutContainer.setAttribute("class", "flexContainer maxWidth verticallyCenteredContent useContentSpacing");
			
			var newAlertHeadingIcon = document.createElement("span");
			
			var iconURL = window.GTFS_ROUTELINE_NUMBER_TO_ICON[gtfsRouteLineNumber];
			
			if (iconURL && window.GTFS_LINE_NUMBERS.includes(gtfsRouteLineNumber) === true) {
				newAlertHeadingIcon = document.createElement("img");
				newAlertHeadingIcon.setAttribute("role", "presentation");
				newAlertHeadingIcon.setAttribute("src", iconURL);
				newAlertHeadingIcon.setAttribute("class", "AlertGTFSIcon");
				newAlertHeadingIcon.setAttribute("aria-hidden", true);
			} else {
				newAlertHeadingIcon = document.createElement("span");
				newAlertHeadingIcon.setAttribute("class", "AlertGTFSNumber flexContainer horizontallyCenteredContent verticallyCenteredContent");
				
				if (gtfsRouteLineNumber) {
					newAlertHeadingIcon.textContent = gtfsRouteLineNumber;
				}
			}
			
			var newAlertHeading = document.createElement("p");
			newAlertHeading.textContent = gtfsItemName.replaceAll("/", " / ");
			
			var newAlertTransitAlertsCounterElement = document.createElement("transit-alerts");  //??? rename this variable
			newAlertTransitAlertsCounterElement.setAttribute("data-show-alert-count-only", true);
			newAlertTransitAlertsCounterElement.setAttribute("data-alert-count-singular-suffix-text", "Alert");
			newAlertTransitAlertsCounterElement.setAttribute("data-alert-count-multiples-suffix-text", "Alerts");
			newAlertTransitAlertsCounterElement.setAttribute("data-timeframe", targetTimeframe);  //??? ugly hardcoding
			newAlertTransitAlertsCounterElement.setAttribute("data-gtfs-mode-number", targetAlert.group);
			(gtfsRouteLineNumber || gtfsItemName) && newAlertTransitAlertsCounterElement.setAttribute("data-gtfs-routeline-number", gtfsRouteLineNumber || gtfsItemName);
			newAlertTransitAlertsCounterElement.setAttribute("data-no-alerts-text", "No Alerts");
			
			newAlertHeadingIcon && newAlertHeaderLayoutContainer.append(newAlertHeadingIcon);
			newAlertHeaderLayoutContainer.append(newAlertHeading);
			newAlertHeaderLayoutContainer.append(newAlertTransitAlertsCounterElement);
			
			newAlertHeader.append(newAlertHeaderLayoutContainer);
			
			output.append(newAlertHeader);
			
			return output;
		};
		
		window.buildAlert = getAlertContext => {
			var DEFAULT_ALERT_ENDTIME_LABEL = window.TRANSIT_ALERT_END_TIME_LABELS[0];  //??? should this be hardcoded?
			const DEFAULT_CLOSED_ALERT_LABEL = "Resolved";  //??? should this be hardcoded?
			const DEFAULT_OPENED_ALERT_LABEL = "In Effect";  //??? should this be hardcoded?
			
			var context = getAlertContext && getAlertContext();
			
			//GUARD: do nothing if there is no context
			if (!context) {
				return;
			}
			
			var alertID = context.alertID;
			var isClosedAlert = context.isClosedAlert;
			var isCriticalAlert = context.isCriticalAlert;
			var isAdvisoryAlert = context.isAdvisoryAlert;
			var alertEffect = window.TRANSIT_ALERT_EFFECTS[context.alertEffect] || context.alertEffect || "";
			var affectedModes = context.affectedModes || "";
			var headerText = context.headerText || "";
			var descriptionText = context.descriptionText || "";
			var moreInfoURL = context.url && (context.url.startsWith("https://www.translink.ca") || context.url.startsWith("https://infomaps.translink.ca") ? context.url : "");  //??? include
			var lastModifiedDateTime = context.lastModifiedDateTime || "";
			var startTime = context.startTime || ""; //??? this is actually "startDateTime"
			var endTime = context.endTime || DEFAULT_ALERT_ENDTIME_LABEL;
			var endDateTime = context.endDateTime;
			var isRecurring = context.isRecurring;
			
			var output = document.createElement("article");
			alertID && output.setAttribute("data-alert-id", alertID);
			output.setAttribute("class", "AlertDetails useContentSpacing useFontColor");
			
			var alertMetaDataElement = document.createElement("p");
			alertMetaDataElement.setAttribute("class", "flexContainer flexWrapper verticallyCenteredContent");
			alertMetaDataElement.setAttribute("style", "gap: 1rem;");  //??? need to put this into inline-style
			
			var alertEffectElement = document.createElement("strong");
			alertEffectElement.setAttribute("class", "AlertEffect");
			isCriticalAlert && alertEffectElement.setAttribute("style", "--alertEffectBackgroundColor: #D9212C; --alertEffectTextColor: white;");  //??? should this be hardcoded?
			isAdvisoryAlert && alertEffectElement.setAttribute("style", "--alertEffectBackgroundColor: #FF870F;");  //??? should this be hardcoded?
			alertEffectElement.textContent = alertEffect;
			
			var affectedModesElement = document.createElement("strong");
			affectedModesElement.setAttribute("class", "AlertAffectedModes");
			affectedModesElement.textContent = affectedModes;
			
			alertMetaDataElement.append(alertEffectElement);
			alertMetaDataElement.append(affectedModesElement);
			
			var alertDurationContainerElement = document.createElement("div");
			alertDurationContainerElement.setAttribute("class", "AlertDuration contentItem verticallyCenteredItem");
			
			var alertDurationStatusElement = document.createElement("strong");
			alertDurationStatusElement.textContent = !isClosedAlert || isClosedAlert === false ? DEFAULT_OPENED_ALERT_LABEL : DEFAULT_CLOSED_ALERT_LABEL;  //??? should not be hardcoded?
			
			if (!isClosedAlert || isClosedAlert === false) {
				var alertDurationTimeElement = document.createElement("small");
				
				if (isRecurring === true) {
					var startDateTime = new Date(startTime);
					
					var startTimeString = `${startDateTime.getHours()}:${startDateTime.getMinutes()}`;
					
					alertDurationTimeElement.textContent = `Recurring from ${window.buildTimeString(startTimeString)} to ${endTime.replaceAll("Until ", "")} on ${window.buildDateString(endDateTime)}`;
				} else {
					alertDurationTimeElement.textContent = `${window.buildDateTimeString(startTime)} — ${endTime}`;
				}
			}
			
			alertDurationContainerElement.append(alertDurationStatusElement);
			alertDurationTimeElement && alertDurationContainerElement.append(alertDurationTimeElement);
			
			var alertDescriptionElement = window.buildParagraphElementFromText(headerText + "\n" + descriptionText);
			
			var moreInfoLinkElement = document.createElement("a");
			moreInfoLinkElement.setAttribute("href", moreInfoURL);
			moreInfoLinkElement.setAttribute("style", "display: inline-block; border-top: none; word-break: break-word;");
			moreInfoLinkElement.textContent = moreInfoURL;
			
			var alertLastModifiedElement = document.createElement("div");
			alertLastModifiedElement.setAttribute("class", "AlertLastModified contentItem");
			
			var alertLastModifiedLabelElement = document.createElement("strong");
			alertLastModifiedLabelElement.textContent = "Updated";
			
			var alertLastModifiedTimeElement = document.createElement("small");
			alertLastModifiedTimeElement.textContent = window.buildLastModifiedDateTimeString(lastModifiedDateTime) || "";
			
			alertLastModifiedElement.append(alertLastModifiedLabelElement);
			alertLastModifiedElement.append(alertLastModifiedTimeElement);
			
			output.append(alertMetaDataElement);
			output.append(alertDurationContainerElement);
			output.append(alertDescriptionElement);
			output.append(moreInfoLinkElement);
			output.append(alertLastModifiedElement);
			
			return output;
		};
	})();
</script><script class="geographyHelpers">
	; (() => {
		window.GVTA_LATLNG_BOUNDS = window.GVTA_LATLNG_BOUNDS || {
			north: 49.476707
			, west: -123.438324
			, south: 49.000000
			, east: -122.300060
		};
	})();
</script><script class="GTFSHelpers">
	; (() => {
		window.ALL_TRANSIT_MODES = [
			"Bus"
			, "SkyTrain"
			, "West Coast Express"
			, "SeaBus"
			, "HandyDART"
		];
		
		window.PREFERRED_LINES_SORT_ORDER = [
			"Canada Line"
			, "Millennium Line"
			, "Expo Line"
			, "West Coast Express"
			, "SeaBus"
		];
		
		window.PREFERRED_DIRECTION_SORT_ORDER = [
			"Northbound"
			, "Southbound"
			, "Westbound"
			, "Eastbound"
			, "Waterfront"  //NOTE: used by both WCE and SeaBus when heading towards Waterfront, so this needs to be higher than both the 'away' directions for those two lines
			, "Mission City"  //NOTE: used by WCE when heading away from Waterfront
			, "Lonsdale Quay"  //NOTE: used by SeaBus when heading away from Waterfront
		];
		
		window.GTFS_MODE_NUMBER_TO_MODE_NAME = [
			undefined  //NOTE: there is no '0' mode ID
			, "SkyTrain"
			, "West Coast Express"
			, "Bus"
			, "SeaBus"
			, undefined //NOTE: HandyDART was originally mode-number-5, but is now 715
			, "Station Access"
			, "Technical"
			, "Critical"
			, "Advisory"
		];
		window.GTFS_MODE_NUMBER_TO_MODE_NAME[715] = "HandyDART";  //NOTE: HandyDART was originally mode-number-5, but is now 715
		
		window.GTFS_CANADA_LINE_NUMBER = "980";
		window.GTFS_MILLENNIUM_LINE_NUMBER = "991";
		window.GTFS_EXPO_LINE_NUMBER = "992";
		window.GTFS_WEST_COAST_EXPRESS_LINE_NUMBER = "997";
		window.GTFS_SEABUS_LINE_NUMBER = "998";
		window.GTFS_HANDYDART_LINE_NUMBER = "HD";
		
		//??? deprecated
		window.GTFS_CANADA_LINE_ID = window.GTFS_CANADA_LINE_NUMBER;
		window.GTFS_MILLENNIUM_LINE_ID = window.GTFS_MILLENNIUM_LINE_NUMBER;
		window.GTFS_EXPO_LINE_ID = window.GTFS_EXPO_LINE_NUMBER;
		window.GTFS_WEST_COAST_EXPRESS_LINE_ID = window.GTFS_WEST_COAST_EXPRESS_LINE_NUMBER;
		window.GTFS_SEABUS_LINE_ID = window.GTFS_SEABUS_LINE_NUMBER;
		window.GTFS_HANDYDART_LINE_ID = window.GTFS_HANDYDART_LINE_NUMBER;
		
		window.GTFS_SKYTRAIN_LINE_NUMBERS = [
			window.GTFS_CANADA_LINE_NUMBER
			, window.GTFS_MILLENNIUM_LINE_NUMBER
			, window.GTFS_EXPO_LINE_NUMBER
		];
		
		window.GTFS_SKYTRAIN_LINE_IDS = window.GTFS_SKYTRAIN_LINE_NUMBERS;
		
		window.GTFS_LINE_NUMBERS = [
			...window.GTFS_SKYTRAIN_LINE_NUMBERS
			, window.GTFS_WEST_COAST_EXPRESS_LINE_NUMBER
			, window.GTFS_SEABUS_LINE_NUMBER
			, window.GTFS_HANDYDART_LINE_NUMBER
		];
		
		window.GTFS_LINE_IDS = window.GTFS_LINE_NUMBERS;
		
		//??? this name is very misleading because it is only used for lines and never routes
		window.GTFS_ROUTELINE_NUMBER_TO_NAME = {};
		window.GTFS_ROUTELINE_NUMBER_TO_NAME["000"] = "Critical Alerts";
		window.GTFS_ROUTELINE_NUMBER_TO_NAME[window.GTFS_CANADA_LINE_NUMBER] = "Canada Line";
		window.GTFS_ROUTELINE_NUMBER_TO_NAME[window.GTFS_MILLENNIUM_LINE_NUMBER] = "Millennium Line";
		window.GTFS_ROUTELINE_NUMBER_TO_NAME[window.GTFS_EXPO_LINE_NUMBER] = "Expo Line";
		window.GTFS_ROUTELINE_NUMBER_TO_NAME[window.GTFS_WEST_COAST_EXPRESS_LINE_NUMBER] = "West Coast Express";
		window.GTFS_ROUTELINE_NUMBER_TO_NAME[window.GTFS_SEABUS_LINE_NUMBER] = "SeaBus";
		window.GTFS_ROUTELINE_NUMBER_TO_NAME[window.GTFS_HANDYDART_LINE_NUMBER] = "HandyDART";
		
		//NOTE: 'window.GTFS_ROUTELINE_ID_TO_NAME' && 'GTFS_ROUTE_ID_TO_NAME' both are legacy aliases; in deprecation
		window.GTFS_ROUTELINE_ID_TO_NAME = window.GTFS_ROUTELINE_NUMBER_TO_NAME;
		window.GTFS_ROUTE_ID_TO_NAME = window.GTFS_ROUTELINE_ID_TO_NAME;
		
		window.GTFS_LINE_NAMES = [
			"Critical Alerts"
			, "Canada Line"
			, "Millennium Line"
			, "Expo Line"
			, "West Coast Express"
			, "SeaBus"
			, "HandyDART"
		];
		
		window.GTFS_LINE_NUMBERS = [
			"000"
			, "980"
			, "991"
			, "992"
			, "997"
			, "998"
			, "HD"
		];
		
		window.GTFS_LINE_NAME_TO_NUMBER = {
			"Critical Alerts": "000"
			, "Canada Line": "980"
			, "Millennium Line": "991"
			, "Expo Line": "992"
			, "West Coast Express": "997"
			, "SeaBus": "998"
			, "HandyDART": "HD"
		};
		
		window.GTFS_LINE_NAMES_URL_SAFE_TO_LINE_NUMBERS = window.GTFS_LINE_NAMES.reduce((output, curLineName, idx) => {
			curLineName = window.sanitizeID && window.sanitizeID(curLineName) || curLineName;
			var curLineNumber = window.GTFS_LINE_NUMBERS[idx];
			
			output[curLineName] = curLineNumber;
			
			return output;
		}, {});
		
		window.GTFS_LINE_NUMBERS_TO_LINE_NAMES = window.GTFS_LINE_NAMES.reduce((output, curLineName, idx) => {
			var curLineNumber = window.GTFS_LINE_NUMBERS[idx];
			
			output[curLineNumber] = curLineName;
			
			return output;
		}, {});
		
		window.GTFS_LINE_NUMBERS_TO_LINE_NAMES_URL_SAFE = window.GTFS_LINE_NAMES.reduce((output, curLineName, idx) => {
			curLineName = window.sanitizeID && window.sanitizeID(curLineName) || curLineName;
			
			var curLineNumber = window.GTFS_LINE_NUMBERS[idx];
			
			output[curLineNumber] = curLineName;
			
			return output;
		}, {});
		
		window.DEFAULT_GTFS_ROUTELINE_ICON = "/-/media/translink/icons/alerts/bus.svg";
		
		window.GTFS_ROUTELINE_NUMBER_TO_ICON = {
			"000": "/-/media/translink/icons/alerts/critical.svg"
			, "980": "/-/media/translink/icons/alerts/canada-line.svg"
			, "991": "/-/media/translink/icons/alerts/millennium-line.svg"
			, "992": "/-/media/translink/icons/alerts/expo-line.svg"
			, "997": "/-/media/translink/icons/alerts/west-coast-express.svg"
			, "998": "/-/media/translink/icons/alerts/seabus.svg"
			, "301": "/-/media/translink/icons/alerts/double-decker-bus.svg"
			, "555": "/-/media/translink/icons/alerts/double-decker-bus.svg"
			, "620": "/-/media/translink/icons/alerts/double-decker-bus.svg"
			, "HD": "/-/media/translink/icons/alerts/handydart.svg"
			, "N8": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N9": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N10": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N15": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N17": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N19": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N20": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N22": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N24": "/-/media/translink/icons/alerts/nightbus.svg"
			, "N35": "/-/media/translink/icons/alerts/nightbus.svg"
			, "R1": "/-/media/translink/icons/alerts/rapid-bus.svg"
			, "R2": "/-/media/translink/icons/alerts/rapid-bus.svg"
			, "R3": "/-/media/translink/icons/alerts/rapid-bus.svg"
			, "R4": "/-/media/translink/icons/alerts/rapid-bus.svg"
			, "R5": "/-/media/translink/icons/alerts/rapid-bus.svg"
		};
		//??? deprecated
		window.GTFS_ROUTE_ID_TO_ICON = window.GTFS_ROUTELINE_NUMBER_TO_ICON;
		
		window.GTFS_ROUTE_ID_TO_SEARCH_TERM = window.GTFS_ROUTELINE_NUMBER_TO_NAME;  //??? remove reference to ID and add reference to line
		
		//??? do I need to add color for B-Line and rapidbus?
		window.GTFS_ROUTELINE_NUMBER_TO_LINE_COLOR = {};
		window.GTFS_ROUTELINE_NUMBER_TO_LINE_COLOR[window.GTFS_CANADA_LINE_NUMBER] = "#007C9F";
		window.GTFS_ROUTELINE_NUMBER_TO_LINE_COLOR[window.GTFS_MILLENNIUM_LINE_NUMBER] = "#FFD733";
		window.GTFS_ROUTELINE_NUMBER_TO_LINE_COLOR[window.GTFS_EXPO_LINE_NUMBER] = "#005DAA";
		window.GTFS_ROUTELINE_NUMBER_TO_LINE_COLOR[window.GTFS_WEST_COAST_EXPRESS_LINE_NUMBER] = "#68166E";
		window.GTFS_ROUTELINE_NUMBER_TO_LINE_COLOR[window.GTFS_SEABUS_LINE_NUMBER] = "#756660";
		
		window.GTFS_ROUTE_ID_TO_LINE_COLOR = window.GTFS_ROUTELINE_NUMBER_TO_LINE_COLOR;
		
		window.GTFS_STATION_NAMES = [
			"22nd Street Station"
			, "29th Avenue Station"
			, "Aberdeen Station"
			, "Braid Station"
			, "Brentwood Town Centre Station"
			, "Bridgeport Station"
			, "Broadway-City Hall Station"
			, "Burquitlam Station"
			, "Burrard Station"
			, "Capstan Station"
			, "Columbia Station"
			, "Commercial-Broadway Station"
			, "Coquitlam Central Station"
			, "Edmonds Station"
			, "Gateway Station"
			, "Gilmore Station"
			, "Granville Station"
			, "Holdom Station"
			, "Inlet Centre Station"
			, "Joyce-Collingwood Station"
			, "King Edward Station"
			, "King George Station"
			, "Lafarge Lake–Douglas Station"
			, "Lake City Way Station"
			, "Langara-49th Avenue Station"
			, "Lansdowne Station"
			, "Lincoln Station"
			, "Lonsdale Quay Station"
			, "Lougheed Town Centre Station"
			, "Main Street-Science World Station"
			, "Maple Meadows Station"
			, "Marine Drive Station"
			, "Metrotown Station"
			, "Mission City Station"
			, "Moody Centre Station"
			, "Nanaimo Station"
			, "New Westminster Station"
			, "Oakridge-41st Avenue Station"
			, "Olympic Village Station"
			, "Patterson Station"
			, "Pitt Meadows Station"
			, "Port Coquitlam Station"
			, "Port Haney Station"
			, "Production Way-University Station"
			, "Renfrew Station"
			, "Richmond-Brighouse Station"
			, "Royal Oak Station"
			, "Rupert Station"
			, "Sapperton Station"
			, "Scott Road Station"
			, "Sea Island Centre Station"
			, "Sperling-Burnaby Lake Station"
			, "Stadium-Chinatown Station"
			, "Surrey Central Station"
			, "Templeton Station"
			, "Vancouver City Centre Station"
			, "VCC-Clark Station"
			, "Waterfront Station"
			, "Yaletown-Roundhouse Station"
			, "YVR-Airport Station"
		];
		
		window.GTFS_SCHEDULING_LOCATION_NUMBERS = [
			"57893"
			, "60105"
			, "60106"
			, "60107"
			, "60108"
		];
		//??? deprecated
		window.GTFS_SCHEDULING_LOCATION_IDS = window.GTFS_SCHEDULING_LOCATION_NUMBERS;
		
		//??? remove reference to ID
		window.GTFS_CANADA_LINE_STATION_IDS = [
			"99906" //Aberdeen
			, "99907" //Bridgeport
			, "99912" //Broadway City Hall
			, "99959" //Capstan Station
			, "99911" //King Edward
			, "99909" //Langara-49th Avenue
			, "99905" //Lansdowne
			, "99908" //Marine Drive
			, "99910" //Oakridge-41st Avenue
			, "99913" //Olympic Village
			, "99904" //Richmond-Brighouse
			, "99902" //Sea Island Centre
			, "99903" //Templeton
			, "99915" //Vancouver City Centre
			, "12034" //Waterfront
			, "99914" //Yaletown-Roundhouse
			, "99901" //YVR-Airport
		];
		
		//??? remove reference to ID
		window.GTFS_MILLENNIUM_LINE_STATION_IDS = [
			"99921" //Brentwood Town Centre
			, "99927" //Burquitlam
			, "99917" //Commercial-Broadway
			, "99930" //Coquitlam Central
			, "99920" //Gilmore
			, "99922" //Holdom
			, "99929" //Inlet Centre
			, "99932" //Lafarge Lake–Douglas
			, "99924" //Lake City Way
			, "99931" //Lincoln
			, "99926" //Lougheed Town Centre
			, "99928" //Moody Centre
			, "99925" //Production Way-University
			, "99918" //Renfrew
			, "99919" //Rupert
			, "99923" //Sperling-Burnaby Lake
			, "99916" //VCC-Clark
		];
		
		//??? remove reference to ID
		window.GTFS_EXPO_LINE_STATION_IDS = [
			"99944" //22nd Street
			, "99938" //29th Avenue
			, "99948" //Braid
			, "99933" //Burrard
			, "99946" //Columbia
			, "99917" //Commercial-Broadway
			, "99943" //Edmonds
			, "99950" //Gateway
			, "99934" //Granville
			, "99939" //Joyce-Collingwood
			, "99952" //King George
			, "99926" //Lougheed Town Centre
			, "99936" //Main Street-Science World
			, "99941" //Metrotown
			, "99937" //Nanaimo
			, "99945" //New Westminster
			, "99940" //Patterson
			, "99925" //Production Way-University
			, "99942" //Royal Oak
			, "99947" //Sapperton
			, "99949" //Scott Road
			, "99935" //Stadium-Chinatown
			, "99951" //Surrey Central
			, "12034" //Waterfront
		];
		
		//??? remove reference to ID
		window.GTFS_WEST_COAST_EXPRESS_EXCLUSIVE_STATION_IDS = [
			"99953"
			, "99954"
			, "99955"
			, "99956"
			, "99957"
		];
		
		//??? remove reference to ID
		window.GTFS_SEABUS_EXPRESS_EXCLUSIVE_STATION_IDS = [
			"99958"
		];
		
		//??? remove reference to ID
		window.GTFS_STATION_IDS = Array.from(new Set([
			...window.GTFS_CANADA_LINE_STATION_IDS
			, ...window.GTFS_MILLENNIUM_LINE_STATION_IDS
			, ...window.GTFS_EXPO_LINE_STATION_IDS
			, ...window.GTFS_WEST_COAST_EXPRESS_EXCLUSIVE_STATION_IDS
			, ...window.GTFS_SEABUS_EXPRESS_EXCLUSIVE_STATION_IDS
		]));
		
		//??? this is a manual version of window.GTFS_STATION_IDS?  refactor to keep this name and use _IDS code, but keep the _ID name in legacy mode
		window.GTFS_STATION_NUMBERS = [
			"99944"
			, "99938"
			, "99906"
			, "99948"
			, "99921"
			, "99907"
			, "99912"
			, "99927"
			, "99933"
			, "99959"
			, "99946"
			, "99917"
			, "99930"
			, "99943"
			, "99950"
			, "99920"
			, "99934"
			, "99922"
			, "99929"
			, "99939"
			, "99911"
			, "99952"
			, "99932"
			, "99924"
			, "99909"
			, "99905"
			, "99931"
			, "99958"
			, "99926"
			, "99936"
			, "99955"
			, "99908"
			, "99941"
			, "99957"
			, "99928"
			, "99937"
			, "99945"
			, "99910"
			, "99913"
			, "99940"
			, "99954"
			, "99953"
			, "99956"
			, "99925"
			, "99918"
			, "99904"
			, "99942"
			, "99919"
			, "99947"
			, "99949"
			, "99902"
			, "99923"
			, "99935"
			, "99951"
			, "99903"
			, "99915"
			, "99916"
			, "12034"
			, "99914"
			, "99901"
		];
		
		window.GTFS_STATION_NAMES_URL_SAFE_TO_STATION_NUMBERS = window.GTFS_STATION_NAMES.reduce((output, curStationName, idx) => {
			curStationName = window.sanitizeID && window.sanitizeID(curStationName) || curStationName;
			var curStationNumber = window.GTFS_STATION_NUMBERS[idx];
			
			output[curStationName] = curStationNumber;
			
			return output;
		}, {});
		
		window.GTFS_STATION_NUMBERS_TO_STATION_NAMES_URL_SAFE = window.GTFS_STATION_NAMES.reduce((output, curStationName, idx) => {
			curStationName = window.sanitizeID && window.sanitizeID(curStationName) || curStationName;
			var curStationNumber = window.GTFS_STATION_NUMBERS[idx];
			
			output[curStationNumber] = curStationName;
			
			return output;
		}, {});
		
		//??? remove reference to ID and add reference to line
		window.GTFS_STATION_NAMES_TO_STATION_NUMBERS = window.GTFS_STATION_NAMES.reduce((output, curStationName, idx) => {
			var curStationNumber = window.GTFS_STATION_NUMBERS[idx];
			
			output[curStationName] = curStationNumber;
			
			return output;
		}, {});
		//??? deprecated
		window.GTFS_STATION_NAMES_TO_STATION_IDS = window.GTFS_STATION_NAMES_TO_STATION_NUMBERS;
		
		//??? remove reference to ID and add reference to line
		window.GTFS_STATION_NUMBERS_TO_STATION_NAMES = window.GTFS_STATION_NAMES.reduce((output, curStationName, idx) => {
			var curStationNumber = window.GTFS_STATION_NUMBERS[idx];
			
			output[curStationNumber] = curStationName;
			
			return output;
		}, {});
		//??? deprecated
		window.GTFS_STATION_IDS_TO_STATION_NAMES = window.GTFS_STATION_NUMBERS_TO_STATION_NAMES;
		
		window.GTFS_PLATFORM_NUMBERS = [
			"57982"
			, "57985"
			, "60095"
			, "60096"
			, "61377"
			, "61378"
			, "57983"
			, "57984"
			, "57947"
			, "57956"
			, "57949"
			, "57954"
			, "61391"
			, "61392"
			, "61381"
			, "61382"
			, "57948"
			, "57955"
			, "61389"
			, "61390"
			, "57961"
			, "57962"
			, "61365"
			, "61366"
			, "61383"
			, "61384"
			, "61387"
			, "61388"
			, "57950"
			, "57953"
			, "61385"
			, "61386"
			, "60089"
			, "60090"
			, "60093"
			, "60094"
			, "60810"
			, "60811"
			, "60802"
			, "60803"
			, "57980"
			, "57987"
			, "60800"
			, "60801"
			, "57975"
			, "57992"
			, "57979"
			, "57988"
			, "57944"
			, "57959"
			, "57960"
			, "57963"
			, "57964"
			, "58003"
			, "61393"
			, "61394"
			, "57951"
			, "57952"
			, "60820"
			, "60821"
			, "61379"
			, "61380"
			, "61371"
			, "61372"
			, "60812"
			, "60813"
			, "60825"
			, "60824"
			, "57971"
			, "57996"
			, "60085"
			, "60086"
			, "60087"
			, "60088"
			, "57945"
			, "57958"
			, "57981"
			, "57986"
			, "60816"
			, "60817"
			, "60091"
			, "60092"
			, "57946"
			, "57957"
			, "57970"
			, "57997"
			, "57966"
			, "58001"
			, "57973"
			, "57994"
			, "61369"
			, "61370"
			, "61363"
			, "61364"
			, "61367"
			, "61368"
			, "60808"
			, "60809"
			, "60806"
			, "60807"
			, "60826"
			, "58002"
			, "57974"
			, "57993"
			, "57969"
			, "57998"
			, "60822"
			, "60823"
			, "57972"
			, "57995"
			, "57978"
			, "57989"
			, "60084"
			, "60804"
			, "60805"
			, "61375"
			, "61376"
			, "60814"
			, "60815"
			, "61373"
			, "61374"
			, "60818"
			, "60819"
			, "57977"
			, "57990"
			, "57967"
			, "58000"
			, "57976"
			, "57991"
			, "57968"
			, "57999"
			, "60674"
			, "60675"
		];
		//??? deprecated
		window.GTFS_PLATFORM_IDS = window.GTFS_PLATFORM_NUMBERS;
		
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS = new Map();
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("12034", ["61394", "61393"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("61925", ["61394", "61393"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99901", ["61392", "61391"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99902", ["61390", "61389"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99903", ["61388", "61387"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99904", ["61386", "61385"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99905", ["61384", "61383"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99906", ["61382", "61381"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99907", ["61380", "61379"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99908", ["61378", "61377"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99909", ["61376", "61375"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99910", ["61374", "61373"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99911", ["61372", "61371"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99912", ["61370", "61369"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99913", ["61368", "61367"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99914", ["61366", "61365"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99915", ["61364", "61363"]);
		window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99959", ["60674", "60675"]);
		
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS = new Map();
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99916", ["60825", "60824"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99917", ["60823", "60822"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99918", ["60821", "60820"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99919", ["60819", "60818"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99920", ["60817", "60816"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99921", ["60815", "60814"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99922", ["60813", "60812"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99923", ["60811", "60810"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99924", ["60809", "60808"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99925", ["60807", "60806"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99926", ["60805", "60084"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99927", ["60086", "60085"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99928", ["60088", "60087"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99929", ["60090", "60089"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99930", ["60092", "60091"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99931", ["60094", "60093"]);
		window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99932", ["60096", "60095"]);
		
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS = new Map();
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("12034", ["57964", "58003"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("61925", ["57964", "58003"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99917", ["57969", "57998"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99925", ["60806", "60807"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99926", ["60804", "60805"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99933", ["60826", "58002"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99934", ["57966", "58001"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99935", ["57967", "58000"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99936", ["57968", "57999"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99937", ["57970", "57997"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99938", ["57971", "57996"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99939", ["57972", "57995"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99940", ["57973", "57994"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99941", ["57974", "57993"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99942", ["57975", "57992"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99943", ["57976", "57991"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99944", ["57977", "57990"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99945", ["57978", "57989"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99946", ["57979", "57988"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99947", ["60801", "60800"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99948", ["60803", "60802"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99949", ["57980", "57987"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99950", ["57981", "57986"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99951", ["57982", "57985"]);
		window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99952", ["57983", "57984"]);
		
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS = new Map();
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("12034", ["57944", "57959"]);
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("61925", ["57944", "57959"]);
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99928", ["57945", "57958"]);
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99930", ["57946", "57957"]);
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99953", ["57947", "57956"]);
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99954", ["57948", "57955"]);
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99955", ["57949", "57954"]);
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99956", ["57950", "57953"]);
		window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99957", ["57951", "57952"]);
		
		window.GTFS_SEABUS_STATION_NUMBER_TO_PLATFORM_NUMBERS = new Map();
		window.GTFS_SEABUS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("12034", ["57960", "57963"]);
		window.GTFS_SEABUS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("61925", ["57960", "57963"]);
		window.GTFS_SEABUS_STATION_NUMBER_TO_PLATFORM_NUMBERS.set("99958", ["57961", "57962"]);
		
		window.GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER = new Map();
		window.GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER.set(window.GTFS_CANADA_LINE_NUMBER, window.GTFS_CANADA_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS);
		window.GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER.set(window.GTFS_MILLENNIUM_LINE_NUMBER, window.GTFS_MILLENNIUM_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS);
		window.GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER.set(window.GTFS_EXPO_LINE_NUMBER, window.GTFS_EXPO_LINE_STATION_NUMBER_TO_PLATFORM_NUMBERS);
		window.GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER.set(window.GTFS_WEST_COAST_EXPRESS_LINE_NUMBER, window.GTFS_WEST_COAST_EXPRESS_STATION_NUMBER_TO_PLATFORM_NUMBERS);
		window.GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER.set(window.GTFS_SEABUS_LINE_NUMBER, window.GTFS_SEABUS_STATION_NUMBER_TO_PLATFORM_NUMBERS);
		
		window.GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER = new Map();  //NOTE: needed for inconsistent platform and station number mappings
		
		window.GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER.forEach(curGTFSRouteLines => {
			curGTFSRouteLines.forEach((curGTFSPlatformNumbers, curGTFSStationNumber) => {
				//GUARD: do nothing if the current station number is 61925 because it is an unwanted alias for 12034
				if (curGTFSStationNumber === "61925") {
					return;
				}
				
				curGTFSPlatformNumbers.forEach(curGTFSPlatformNumber => {
					window.GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER.set(curGTFSPlatformNumber, curGTFSStationNumber);
				});
			});
		});
		window.GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER.set("61925", "12034");  //NOTE: this is used on headway sheets for line schedules
		
		/* RSP and Transit Alerts values below */
		
		window.GTFS_STATION_EFFECT_NAMES = new Map();
		window.GTFS_STATION_EFFECT_NAMES.set("ELEVATORS", "Elevators");
		window.GTFS_STATION_EFFECT_NAMES.set("ESCALATORS", "Escalators");
		window.GTFS_STATION_EFFECT_NAMES.set("WALKWAYS", "Walkways");
		
		window.CRITICAL_ALERT_KEY = "Critical";
		window.ADVISORY_ALERT_KEY = "Advisory";
		
		window.CRITICAL_ALERT_LABEL = "Critical";
		window.ADVISORY_ALERT_LABEL = "Advisory";
		
		window.ALERTS_PAGE_URL = "/alerts";
		window.CRITICAL_ALERTS_PAGE_URL = window.ALERTS_PAGE_URL + "#critical-alerts";
		window.ADVISORY_ALERTS_PAGE_URL = window.ALERTS_PAGE_URL + "#advisory-alerts";
		
		window.TRANSIT_ALERT_EFFECTS = {
			"DELAY": "Delay"
			, "CANCELLATION": "Cancellation"
			, "DETOUR": "Detour"
			, "SUSPENSION": "Suspension"
			, "STOP_CLOSURE": "Stop Closure"
			, "STOP_MOVE": "Stop Moved"
			, "SCHEDULE_CHANGE": "Schedule Change"
			, "EXTRA_SERVICE": "Extra Service"
			, "SERVICE_CHANGE": "Service Change"
			, "INFORMATIONAL": "Informational"
			, "BUS_BRIDGE": "Bus Bridge"
			, "SHUTTLE_TRAIN": "Shuttle Train"
			, "STATION_CLOSURE": "Station Closure"
			, "STATION_ISSUE": "Station Issue"
			, "PLATFORM_CHANGE": "Platform Change"
			, "ELEVATORS": "Elevators"
			, "ESCALATORS": "Escalators"
			, "WALKWAYS": "Walkways"
			, "FAREGATES": "Faregates"
			, "AMBER_ALERT": "Amber Alert"
			, "LABOUR_DISPUTE": "Labour Dispute"
			, "CRISIS": "Crisis"
			, "PSA": "PSA"
			, "TECHNICAL": "Technical"
			, "CVM": "CVM"
			, "ADVISORY": "Advisory"
			, "NO_EFFECT": "No Effect"
			, "ACCESSIBILITY_ISSUE": "Accessibility Issue"
		};
		
		window.TRANSIT_ALERT_END_TIME_LABELS = [
			"Until further notice"
			, "Until end of service"
			, "Ongoing"
			, "Until end time"
			, "Closed"
		];
		
		//??? we need to add platform numbers to here too.....
		//NOTE: every term should end or start with a space so we don't match numbers/letters inside a whole word
		window.GTFS_NON_SEARCHABLE_TERMS = [
			 "000 "
			, " 000"
			, " 000 "
			, "980 "
			, " 980"
			, " 980 "
			, "991 "
			, " 991"
			, " 991 "
			, "992 "
			, " 992"
			, " 992 "
			, "997 "
			, " 997"
			, " 997 "
			, "998 "
			, " 998"
			, " 998 "
			, "HD "
			, " HD"
			, " HD "
		];
		window.GTFS_NON_SEARCHABLE_TERMS && window.GTFS_NON_SEARCHABLE_TERMS.push && window.GTFS_STATION_NUMBERS && window.GTFS_STATION_NUMBERS.forEach(curGTFSStationNumber => {
			curGTFSStationNumber = curGTFSStationNumber.trim();
			
			window.GTFS_NON_SEARCHABLE_TERMS.push(`${curGTFSStationNumber} `);
			window.GTFS_NON_SEARCHABLE_TERMS.push(` ${curGTFSStationNumber}`);
			window.GTFS_NON_SEARCHABLE_TERMS.push(` ${curGTFSStationNumber} `);
		});
		
		window.CURRENT_SERVICE_DAY_START_TIME = (() => {
			var output = new Date();
			
			output.setHours(4);
			output.setMinutes(0);
			output.setSeconds(0);
			
			return output;
		})();
		
		window.NEXT_SERVICE_DAY_START_TIME = (() => {
			var output = new Date();
			
			output.setDate(output.getDate() + 1);
			output.setHours(4);
			output.setMinutes(0);
			output.setSeconds(0);
			
			return output;
		})();
		
		window.getPaddedGTFSRouteLineNumber = unpaddedGTFSRouteLineNumber => {
			//??? should validate if unpaddedGTFSRouteLineNumber is a string
			var output = unpaddedGTFSRouteLineNumber;
			
			//GUARD: do nothing if this is a 3 digit number already
			if (output.length >= 3) {
				return output;
			}
			
			var doesGTFSRouteLineNumberContainLetters = (() => {
				var foundLetters = output.match("[a-zA-Z]");
				
				var numFoundLetters = foundLetters && foundLetters.length || 0;
				
				return numFoundLetters > 0;
			})();
			
			if (doesGTFSRouteLineNumberContainLetters === false) {
				output = output.padStart && output.padStart(3, "0") || output;
			}
			
			return output;
		};
		
		window.getUnpaddedGTFSRouteLineNumber = gtfsRouteLineNumber => {
			//??? should validate if gtfsRouteLineNumber is a string
			var output = gtfsRouteLineNumber;
			
			//GUARD: do nothing if the value does not match the format because it is greater than 3 digits
			if (!output || output.length > 3) {
				return output;
			}
			
			var foundLetters = output.match("[a-zA-Z]");
			
			var numFoundLetters = foundLetters && foundLetters.length || 0;
			
			if (numFoundLetters > 0) {
				output = output.toUpperCase();
			} else {
				output = gtfsRouteLineNumber === "000" ? "000" : parseInt(output, 10).toString();
			}
			
			return output;
		};
		
		window.formatGTFSItemName = gtfsItemNameString => {
			var output = gtfsItemNameString && gtfsItemNameString
			.replaceAll("/", " / ")
			.replaceAll(" To ", " to ")
			.replaceAll("/ to ", "/ To ")
			.replaceAll(" Via ", " via ")
			|| gtfsItemNameString;
			
			output = output.trim();
			
			return output;
		};
		
		window.createGTFSDataModel = getGTFSDataContext => {
			var context = getGTFSDataContext && getGTFSDataContext();
			
			//GUARD: do nothing if there is no context
			if (!context) {
				return;
			}
			
			var gtfsData = context.gtfsData;
			var results = context.results;
			var routeLineNumber = context.routeLineNumber;
			var directionValue = context.directionValue;
			
			results.forEach(result => {
				var allRouteDirections = result.d;
				var allGTFSLocations = result.s;
				
				/* INIT DIRECTION PICKER */  //???? why is this here??? made sense in the POC, but not in the full library, this work is not related to the function name at all - maybe we need another callback userland function
				var routeDirectionPicker = document.querySelector('[form="SchedulesTimeFilter"][name="routeDirection"]');
				
				if (routeDirectionPicker && routeDirectionPicker.children.length < 2) {
					window.deleteAllChildNodes && window.deleteAllChildNodes(routeDirectionPicker);
					
					var newTargetValue;
					
					allRouteDirections.forEach((curDirection, idx) => {
						var curDirectionElement = document.createElement("option");
						curDirectionElement.setAttribute("value", curDirection.di);
						curDirectionElement.textContent = curDirection.dn.replaceAll("/", " / ").trim();
						
						if (curDirection.di === parseInt(directionValue, 10)) {
							newTargetValue = curDirection.di;
						}
						
						routeDirectionPicker.append(curDirectionElement);
						routeDirectionPicker && routeDirectionPicker.hasAttribute("readonly") && routeDirectionPicker.removeAttribute("readonly");
					});
					
					var newSelectedOption = newTargetValue && routeDirectionPicker.querySelector(`option[value="${newTargetValue}"]`);
					var newSelectedOptionIndex = newSelectedOption && newSelectedOption.index;
					
					routeDirectionPicker.selectedIndex = newSelectedOptionIndex;  //??? check this value before using it?
				}
				/* end of INIT DIRECTIONS PICKER */
				
				/* INIT DATE PICKER */
				var startDatePicker = document.querySelector('[form="SchedulesTimeFilter"][name="startDate"]');
				
				startDatePicker && startDatePicker.hasAttribute("readonly") && startDatePicker.removeAttribute("readonly");
				/* end of INIT DATE PICKER */
				
				/* START AND END TIME */
				var startTimePicker = document.querySelector('[form="SchedulesTimeFilter"][name="startTime"]');
				var endTimePicker = document.querySelector('[form="SchedulesTimeFilter"][name="endTime"]');
				
				startTimePicker && startTimePicker.hasAttribute("readonly") && startTimePicker.removeAttribute("readonly");
				endTimePicker && endTimePicker.hasAttribute("readonly") && endTimePicker.removeAttribute("readonly");
				/* end of START AND END TIME */
				
				var headwaySheet = [];
				
				var sheetDate = result.sd;
				var allGTFSLocations = result.s;
				
				if (!allGTFSLocations || !allGTFSLocations.forEach) {
					//??? we should have some sort of messaging?
					
					return;
				}
				
				var highestSequenceNumber = 0;
				
				allGTFSLocations.forEach(curGTFSLocation => {
					//GUARD: do nothing if this is a scheduling location
					if (window.GTFS_SCHEDULING_LOCATION_NUMBERS.includes(curGTFSLocation.sc) === true) {
						return;
					}
					
					var newGTFSLocationData = {};  //??? need a better name?
					
					//NOTE: gtfslocation.st must always be an array; otherwise, different days will have a different number of rows/stops and that will cause merging issues
					//??? refactor this into an IIFE that immediately populates newGTFSLocationData.st
					if (!curGTFSLocation.st || window.getType(curGTFSLocation.st) !== window.getType.array) {
						curGTFSLocation.st = [];
					}
					
					//??? stop using "sc", "sn", "st" as newGTFSLocationData keys; just use the full term eg. "stopTimes"
					newGTFSLocationData.sc = parseInt(curGTFSLocation.sc, 10).toString();  //??? what kind of error handling do we need here?
					newGTFSLocationData.sn = window.formatGTFSItemName(curGTFSLocation.sn);
					newGTFSLocationData.no = curGTFSLocation.st.length === 0 ? false : true;
					newGTFSLocationData.st = [];
					newGTFSLocationData.la = curGTFSLocation.la;
					newGTFSLocationData.lo = curGTFSLocation.lo;
					newGTFSLocationData.wc = curGTFSLocation.wc;
					
					curGTFSLocation.st && curGTFSLocation.st.forEach(curStopTimeData => {
						var tripSequenceNumber = curStopTimeData.ts;
						var isCurStopTimeNodeOnly = curStopTimeData.no === true ? true : false;  //??? maybe we need to think of terms to describe node-only stops and node-only stoptimes/trip
						
						//NOTE: this stop is only a node-only stop if all trips are 
						if (isCurStopTimeNodeOnly === false && newGTFSLocationData.no === true) {
							newGTFSLocationData.no = false;
						}
						
						var curStopTime;
						
						if (window.GTFS.lineNumber) {
							curStopTime = [
								parseInt(curStopTimeData.dt && curStopTimeData.dt.replace && curStopTimeData.dt.replace(":", ""), 10)
								, undefined
							];
						} else {
							curStopTime = [
								parseInt(curStopTimeData.dt && curStopTimeData.dt.replace && curStopTimeData.dt.replace(":", ""), 10)
								, curStopTimeData.tp
							];
						}
						
						if (curStopTime[0] && tripSequenceNumber) {
							newGTFSLocationData.st[tripSequenceNumber] = curStopTime;
						}
						
						highestSequenceNumber = Math.max(highestSequenceNumber, tripSequenceNumber);
					});
					
					if (newGTFSLocationData.st.length > 0) {
						headwaySheet.push(newGTFSLocationData);
					}
				});
				
				headwaySheet.forEach(curRow => {
					if (curRow.st && highestSequenceNumber) {
						while (curRow.st.length <= highestSequenceNumber) {
							curRow.st.push(undefined);
						}
					}
				});
				
				//??? do we need a sequence number here????
				gtfsData[directionValue][routeLineNumber][sheetDate] = headwaySheet;
			});
			/* end of CONVERT API DATA INTO DATA MODEL */
		};
		
		window.createRenderableDatamodelFromGTFSDataModel = (curDayLocations, allFormattedStopMetadata, allFormattedStopTimes, twentyFourHourOffset, parseLocationsWithoutStopTimes) => {
			var excludeNodeOnlyStops = window.NextBusSettings && window.NextBusSettings.getSetting("nodeStopsPreference") === "hideNodeStops" || window.NextBusSettings && window.NextBusSettings.getSetting("nodeStopsPreference") === undefined;
			
			var formattedStoptimes = allFormattedStopTimes
			.find(curFormattedStoptimes => {
				return curFormattedStoptimes && curFormattedStoptimes.length > 0;
			});  //??? terrible naming
			
			var numPrevDaysStopTimes = formattedStoptimes && formattedStoptimes.length || 0;
			
			var numCurDayStopTimes = 0;
			
			var isCurStopANodeStop = false;
			
			//??? this is a sketchy API design, using the 'out'/byref to accomplish its work.  extremely fishy
			curDayLocations && curDayLocations.forEach((curStop, idx) => {
				isCurStopANodeStop = curStop.no;
				
				//GUARD: do nothing if we are not showing node stops and this is a node stop
				if (excludeNodeOnlyStops === true && isCurStopANodeStop === true) {
					//??? I need to check which row this node-only curStop was occupying and remove it?
					
					return;
				}
				
				var curStopTimes = curStop.st.concat();
				var curStopNumber = curStop.sc;
				var curStopName = window.formatGTFSItemName(curStop.sn);
				var curStopLatitude = curStop.la;
				var curStopLongitude = curStop.lo;
				var curStopWheelchairAccessible = curStop.wc;
				var allStopTimes = (curStopTimes[0] !== undefined ? curStopTimes : (curStopTimes.shift() || curStopTimes)); //HACK: remove the first element only if it is empty/missing  //NOTE: the first element is always empty because each stoptime is placed in the array index based on the GTFSTripSequence-integer-value  (the first stoptime is "tripSequence 1" so it is placed in array-index-1; there is no "tripSequence 0", so array-index-0 is always empty)
				
				//GUARD: do nothing if any stop data is missing or corrupt
				if (!curStopNumber || !curStopName || !curStopLatitude || !curStopLongitude) {
					return;
				}
				
				if (!parseLocationsWithoutStopTimes && !(allStopTimes && allStopTimes.length)) {
					return;
				}
				
				var formattedCurStop = [
					curStopNumber
					, curStopName
					, curStopLatitude
					, curStopLongitude
					, curStopWheelchairAccessible
				];
				
				var allFormattedStopMetadataAsJSON = allFormattedStopMetadata.map(curFormattedStopMetadata => {
					return JSON.stringify(curFormattedStopMetadata);
				});
				
				var indexOfAdditionItemInAccumulator = allFormattedStopMetadataAsJSON.indexOf(JSON.stringify(formattedCurStop));
				
				//??? what happens when the "idx" of curDayLocations is greater than the size of the "allFormattedStopMetadata" that was already made yesterday?
				if (allFormattedStopMetadata[idx] === undefined) {
					if (indexOfAdditionItemInAccumulator === -1) {
						allFormattedStopMetadata[idx] = formattedCurStop;
					}
					//??? how do we handle versioning of the metadata format???
				} else {
					//check to see if ALL days agree on the same ordering of stops; if not, that is a critical error
					var doesStopNumberMatch = allFormattedStopMetadata[idx][0] === curStopNumber;
					var doesStopNameMatch = allFormattedStopMetadata[idx][1] === curStopName;
					
					if (!doesStopNumberMatch || !doesStopNameMatch) {
						if (indexOfAdditionItemInAccumulator === -1) {
							if (idx === 1) {
								allFormattedStopMetadata.splice(idx, 0, formattedCurStop);
								allFormattedStopTimes.splice(idx, 0, undefined);
							} else {
								var prevAddition = JSON.stringify(curDayLocations[idx - 1]);
								
								var indexOfPrevAdditionInAccumulator = allFormattedStopMetadataAsJSON.indexOf(prevAddition);
								
								allFormattedStopMetadata.splice(indexOfPrevAdditionInAccumulator + 1, 0, formattedCurStop);
								allFormattedStopTimes.splice(indexOfPrevAdditionInAccumulator + 1, 0, undefined);
							}
						}
					}
				}
				
				if (twentyFourHourOffset) {
					allStopTimes = allStopTimes.map(curStopTime => {
						var output = curStopTime && curStopTime[0];
						
						if (output) {
							output = [
								curStopTime[0] + twentyFourHourOffset
								, curStopTime[1]
							];
						}
						
						return output;
					});
				}
				
				var formattedIdx = indexOfAdditionItemInAccumulator === -1 ? idx : indexOfAdditionItemInAccumulator;
				
				if (allFormattedStopTimes[formattedIdx] === undefined) {
					allFormattedStopTimes[formattedIdx] = [];
				}
				
				if (allStopTimes.length > 0) {
					if (allFormattedStopTimes[formattedIdx].length === 0) {
						allFormattedStopTimes[formattedIdx] = Array(numPrevDaysStopTimes).fill(undefined).concat(allStopTimes);
					} else {
						allFormattedStopTimes[formattedIdx] = allFormattedStopTimes[formattedIdx].concat(allStopTimes);
					}
					
					numCurDayStopTimes = allStopTimes.length;
				} else {
					allFormattedStopTimes[formattedIdx] = allFormattedStopTimes[formattedIdx].concat(Array(numCurDayStopTimes).fill(undefined));
				}
			});
			
			//??? this is a hack to add the "add undefined stoptimes so all stops have the same number of stoptimes" to the first stop because we don't know the correct number of days to append until at least the 2nd row is run...
			//??? couldn't the 2nd row also have this issue as well?  why are we only appending to the first row?
			//??? I don't really think this works that well
            if (allFormattedStopTimes.length > 2) {
				if (Array.isArray(allFormattedStopTimes[0]) === true && Array.isArray(allFormattedStopTimes[1]) === true) {
					if (allFormattedStopTimes[0].length < allFormattedStopTimes[1].length) {
						allFormattedStopTimes[0] = allFormattedStopTimes[0].concat(Array(numCurDayStopTimes).fill(undefined));
					}
				}
			}
            
			if (allFormattedStopTimes.length > 3) {
				if (Array.isArray(allFormattedStopTimes[1]) === true && Array.isArray(allFormattedStopTimes[2]) === true) {
					if (allFormattedStopTimes[1].length < allFormattedStopTimes[2].length) {
						allFormattedStopTimes[1] = allFormattedStopTimes[1].concat(Array(numCurDayStopTimes).fill(undefined));
					}
				}
			}
			
			/* REMOVE TRIPS/COLUMNS FOR PREVIOUS DAY */
			var tripHasCurDayStopTimes = false;
			
			//NOTE: we are using a while loop so we don't have to loop through trips/columns that are for the current day; we only need to find the first trip/column with stoptimes for the current day (meaning that all trips/columns after it are also for the current day/tomorrow)
			var firstFormattedStop = allFormattedStopTimes.find(curFormattedStop => {
				return curFormattedStop !== undefined && curFormattedStop.length;
			});  //NOTE: we cannot just get the first element/stop in allFormattedStopTimes because it may have been excluded because it is a node-stop
			
			var numTripColumns = firstFormattedStop && firstFormattedStop.length || 0;
			while (tripHasCurDayStopTimes === false && numTripColumns.length > 0) {
				var tripHasCurDayStopTimes = (() => {
					var output = false;
					
					//NOTE: we are searching the stoptimes for the current trip/column in reverse chronological order because if the latest stoptime is not in the current day, then it is impossible for the earlier stoptimes to be in the current day
					var numStops = allFormattedStopTimes.length;
					for (var i = numStops - 1; i > 0; i--) {
						var targetStop = allFormattedStopTimes[i];
						var targetStopTime = targetStop[0];
						
						//NOTE: do nothing if targetStopTime is 'empty', so continue looking for the next stoptime
						if (targetStopTime) {
							if (targetStopTime[0] > 2400) { //if this stoptime is for the current day, then the entire column/trip needs to be shown; also all future trips are also for the current day/tomorrow, so we can stop validating
								output = true;
								
								break;
							} else { //if the last stoptime for this trip is not in the current day, then none of the earlier stoptimes are in the current day either, so we must NOT show this column/trip
								output = false;
								
								break;
							}
						}
					}
					
					return output;
				})();
				
				//if the current column/trip is invalid (none of the stoptimes are for the current day), then we need to remove the 1st stoptime for every single stop
				tripHasCurDayStopTimes === false && allFormattedStopTimes.forEach(targetStop => {
					targetStop.shift();
				});
			}
			/* end of REMOVE TRIPS/COLUMNS FOR PREVIOUS DAY */
		};
	})();
</script><script class="inform-CSS-that-this-device-has-a-pointer">
	window.addEventListener("DOMContentLoaded", () => {
		if (window.matchMedia("(pointer: fine)").matches === true || window.matchMedia("(min-width: 48em)").matches === true) {
			document.documentElement.classList.add("hasMouseCursor");
		}
	});
</script><script class="inform CSS that JS is enabled">
	document.documentElement.classList.remove("no-js");
	document.documentElement.classList.add("js");
</script><script class="detect-details-element-support">
	(document.createElement("details").open === false) ? document.documentElement.classList.add("details") : document.documentElement.classList.add("no-details")
</script><script class="environment-aware-URL-generator-prototype">
	; (() => {
		var getEnvironmentName = (curURL, canonicalURL) => {
			var output;
			
			var knownEnvironmentURLSegments = [
				"dev"
				, "qa"
				, "willow"
				, "oak"
				, "ash"
				, "elm"
			];
			
			var knownEnvironmentURLSegmentsMappingTable = {
				"dev": "dev"
				, "qa": "qa"
				, "willow": "willow"
				, "oak": "oak"
			};
			
			var toArray = target => {
				return getType(target) === window.getType.array ? target : [target];
			};
			
			var excludeArrays = (lhs, rhs) => {
				var flattenedLHS = new Set();
				
				Array.from(lhs.keys()).forEach(target => {
					(Object.prototype.toString.call(lhs[target]) === "[object Array]") ? flattenedLHS.add(Array.from(lhs[target])) : flattenedLHS.add(lhs[target]);
				});
				
				return Array.from(flattenedLHS).filter(target => {
					return !rhs.includes(target);
				});
			};
			
			var isProdURL = (curURL, prdURL) => {
				return curURL.host === prdURL.host;
			};
			
			//??? what to return if we wrap new URL() in a try-catch?
			curURL = curURL && new URL(curURL) || new URL(document.location);
			canonicalURL = canonicalURL && new URL(canonicalURL) || new URL(document.querySelector('link[rel="canonical"]').getAttribute("href"));
			
			//GUARD: do nothing if we are currently in PRD
			if (isProdURL(curURL, canonicalURL) === true) {
				return;
			}
			
			var rootURL = curURL.host;
			
			var isAzureRootWebsite = rootURL.endsWith("azurewebsites.net");
			var isTransLinkRootWebsite = rootURL.endsWith("translink.ca");
			var rootURLSegments = rootURL.split(".");
			var canonicalURLSegments = canonicalURL.host.split(".");
			var numRootURLSegments = rootURLSegments.length;
			
			//GUARD: do nothing if this is an azure website; we have no way of detecting which environment an azure website belongs to
			if (isAzureRootWebsite) {
				//NOTE:  this case should never happen; you cannot add your own subdomains to the Azure websites
				return;
			}
			
			//GUARD:  do nothing if there is no subdomain
			if (isTransLinkRootWebsite && numRootURLSegments <= 2) {
				return;
			}
			
			output = excludeArrays(rootURLSegments, canonicalURLSegments);
			
			output = output.filter(curURLSegment => {
				return knownEnvironmentURLSegments.indexOf(curURLSegment) !== -1;
			});
			
			return knownEnvironmentURLSegmentsMappingTable[output[0]];
		};
		
		window.buildEnvironmentSpecificURL = originalURL => {
			//GUARD: do nothing if there is no original URL
			if (!originalURL) {
				return;
			}
			
			var environmentName = getEnvironmentName();
			
			var originalURLSegments = originalURL.split(".");
			
			if (environmentName) {
				originalURLSegments.splice(originalURLSegments.length - 2, 0, environmentName);
			}
			
			return originalURLSegments.join(".");
		};
		
		window.isRunningInProduction = () => {
			//??? is this correct?  what should be the default return value if there is an internal issue inside this function?
			try {
				var curURLString = document.location.href;
				var curURL = curURLString && new URL(curURLString);
				
				var formattedCurURLString = curURL && (curURL.origin + curURL.pathname);
				
				var canonicalURLElement = document.querySelector('link[rel="canonical"]');
				
				var canonicalURLString = canonicalURLElement && canonicalURLElement.getAttribute("href");
				var canonicalURL = canonicalURLString && new URL(canonicalURLString);
				
				var formattedCanonicalURLString = canonicalURL && (canonicalURL.origin + canonicalURL.pathname);
				
				var isRunningInProduction = formattedCurURLString === formattedCanonicalURLString;
				
				return isRunningInProduction;
			} catch (error) {
				console.error(error);
			}
		};
	})();
</script><script class="inform CSS when there is no hash in the URL">
	; (() => {
		var setHasURLHashClass = () => {
			document.documentElement.classList.add("hasURLHash");
			
			return true;
		};
		
		var removeHasURLHashClass = () => {
			document.documentElement.classList.remove("hasURLHash");
			
			return true;
		};
		
		if (window.location.hash !== "") {
			setHasURLHashClass();
		}
		
		window.onhashchange = () => {
			if (window.location.hash !== "") {
				setHasURLHashClass();
			} else {
				removeHasURLHashClass();
			}
		};
	})();
</script><script class="PersistentStorage">
	; (() => {
		window.PersistentStorage = window.PersistentStorage || {};
		
		window.PersistentStorage.length = () => {
			try {
				var output = window.localStorage.length;
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.PersistentStorage.setItem = (key, value) => {
			try {
				var output = window.localStorage.setItem(key, value);
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.PersistentStorage.getItem = key => {
			try {
				var output = window.localStorage.getItem(key);
				
				//NOTE:  when localStorage is not able to find an item, it returns null.  However, a reasonable person expects undefined to be returned; so we are forcibly converting nulls into undefineds
				if (output === null) {
					output = undefined;
				}
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.PersistentStorage.removeItem = key => {
			try {
				var output = window.PersistentStorage.getItem(key);
				
				window.localStorage.removeItem(key);
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.PersistentStorage.clear = () => {
			try {
				window.localStorage.clear();
				
				return;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.PersistentStorage.getAllKeys = () => {
			try {
				var output = Object.keys(window.localStorage);
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.PersistentStorage.getAllItems = () => {
			try {
				var output = Object.keys(window.localStorage).map(curKey => {
					return window.localStorage.getItem(curKey);
				});
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
	})();
</script><script class="temporaryStorage-100">
	; (() => {
		window.TemporaryStorage = window.TemporaryStorage || {};
		
		window.TemporaryStorage.length = () => {
			try {
				var output = window.sessionStorage.length;
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.TemporaryStorage.setItem = (key, value) => {
			try {
				var output = window.sessionStorage.setItem(key, value);
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.TemporaryStorage.getItem = key => {
			try {
				var output = window.sessionStorage.getItem(key);
				
				//NOTE:  when sessionStorage is not able to find an item, it returns null.  However, a reasonable person expects undefined to be returned; so we are forcibly converting nulls into undefineds
				if (output === null) {
					output = undefined;
				}
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.TemporaryStorage.removeItem = key => {
			try {
				var output = window.TemporaryStorage.getItem(key);
				
				window.sessionStorage.removeItem(key);
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.TemporaryStorage.clear = () => {
			try {
				window.sessionStorage.clear();
				
				return;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.TemporaryStorage.getAllKeys = () => {
			try {
				var output = Object.keys(window.sessionStorage);
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
		
		window.TemporaryStorage.getAllItems = () => {
			try {
				var output = Object.keys(window.sessionStorage).map(curKey => {
					return window.sessionStorage.getItem(curKey);
				});
				
				return output;
			} catch (error) {
				console.error(error);
				
				return;
			}
		};
	})();
</script><script class="sitenav">
	; (() => {
		const NAMESPACE = "SiteNav";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			self.apiURL;
			self.additionalQueryStringArguments = "";
			self.getExpanderButton;
			self.declarativeContainerSelector;
			self.getDeclarativeMenuID;
			self.getDeclarativeMenuToken;
			self.getDeclarativeIsPrependingLinks;
			
			self.load = options => {
				//GUARD: do not proceed if no options were passed
				if (!options) {
					return;
				}
				
				var targets = options.targets || [];  //??? this is a horrible variable name; must change
				var targetSelector = options.targetSelector;
				
				var apiMenuID = options.apiMenuID;
				var apiMenuToken = options.apiMenuToken;
				
				var isPrependingLinks = options.isPrependingLinks;
				var isKeepingPlaceHolderContentAfterLoad = options.keepPlaceHolderContentAfterLoad;
				
				var onAfterLoadSuccess = options.onAfterLoadSuccess;
				var onAfterCachedLoadSuccess = options.onAfterCachedLoadSuccess;
				var onAfterLoadFail = options.onAfterLoadFail;
				
				var CACHE_KEY = "SiteNav-" + apiMenuID;
				
				self.apiURL.search = new URLSearchParams({
					menuId: apiMenuID
					, apiToken: apiMenuToken
				});
				
				var cachedCopy = window.PersistentStorage && window.PersistentStorage.getItem && window.PersistentStorage.getItem(CACHE_KEY);
				
				if (targets && window.getType(targets) !== window.getType.array) {
					targets = [targets];
				}
				
				var foundTargets = Array.from(document.querySelectorAll(targetSelector));
				
				targets = targets.concat(foundTargets);
				
				//GUARD: do nothing if no containers were found
				if (targets.length === 0) {
					return;
				}
				
				//immediately render cached sitenav if it exists
				var isCachedCopyValid = cachedCopy && cachedCopy.includes("MenuItemLinkUrl");  //??? should probably make a better validation function....
				
				if (isCachedCopyValid) {
					isKeepingPlaceHolderContentAfterLoad !== true && targets && targets.forEach(curTarget => {
						window.deleteAllChildNodes && window.deleteAllChildNodes(curTarget);
					});
					
					createSiteNav(JSON.parse(cachedCopy), targets, isPrependingLinks);
				} else {
					window.PersistentStorage && window.PersistentStorage.getItem && window.PersistentStorage.getItem(CACHE_KEY);
				}
				
				fetch(self.apiURL.toString() + self.additionalQueryStringArguments, { priority: "high" })
				.then(response => {
					response.json()
					.then(result => {
						switch (result) {
							case "500":
							case 500:
							case "503":
							case 503:
								//GETAWAY return successfully but origin failed
								onAfterLoadFail && onAfterLoadFail();
								
								break;
							default:
								//GETAWAY return successfully
								
								//only render sitenav if there was no cached copy
								if (isCachedCopyValid !== true) {
									isKeepingPlaceHolderContentAfterLoad !== true && targets && targets.forEach(curTarget => {
										window.deleteAllChildNodes && window.deleteAllChildNodes(curTarget);
									});
									
									createSiteNav(result, targets, isPrependingLinks);
								}
								
								//always add to cache whether or not there is a cached copy
								window.PersistentStorage && window.PersistentStorage.setItem && window.PersistentStorage.setItem(CACHE_KEY, JSON.stringify(result));
								
								onAfterLoadSuccess && onAfterLoadSuccess(targetSelector, targets);  //??? consider refactoring into context object
								
								break;
						}
					})
					.catch(error => {
						//GETAWAY failed to return
						console.error(error);
					});
				})
				.catch(error => {
					//CLIENT is offline
					console.error(error);
				});
			};
			
			var createSiteNav = (siteNavJsonData, containers, isPrependingLinks) => {
				//GUARD: do nothing if there is no data
				if (!siteNavJsonData) {
					return;
				}
				
				containers.forEach(curSiteNav => {
					var siteNavContainer = curSiteNav.querySelector("ul");
					
					var newSiteNavContainer = self.generateSiteNavigation(siteNavJsonData);
					
					if (!siteNavContainer) {
						if (isPrependingLinks === true) {
							curSiteNav.prepend(newSiteNavContainer);
						} else {
							curSiteNav.appendChild(newSiteNavContainer);
						}
					} else {
						newSiteNavContainer.children && Array.from(newSiteNavContainer.children).forEach(curNavItem => {
							if (isPrependingLinks === true) {
								siteNavContainer.prepend(curNavItem);
							} else {
								siteNavContainer.appendChild(curNavItem);
							}
						});
					}
				});
			};
			
			self.generateSiteNavigation = links => {
				var output = document.createElement("ul");
				
				try {
					var curURL = new URL(document.URL);  //??? should this be "document.location.href"?
					var curURLPath = curURL.pathname;
					
					links && links.forEach(curLink => {
						var linkItem = self.generateSiteNavigationLink(curLink, curURLPath);
						
						if (linkItem) {
							output.appendChild(linkItem);
						}
					});
				} catch (error) {
					console.error(error);
				} finally {
					return output;
				}
			};
			
			self.generateSiteNavigationLink = (curLink, curPath) => {
				var linkURL = curLink.MenuItemLinkUrl;
				var linkName = curLink.MenuItemName;
				var iconURL = curLink.MenuItemTabImageUrl;
				var iconAltText = curLink.MenuItemTabImageAlt
				var iconWidth = curLink.MenuItemTabImageWidth;
				var iconHeight = curLink.MenuItemTabImageHeight;
				var textOnly = !iconURL;
				var ariaLabel = curLink.MenuItemTabAriaLabel;
				
				//GUARD: do not proceed if there is no link
				if (!linkURL) {
					return;
				}
				
				//GUARD: do not proceed if there is no link name or icon
				if (!linkName && !iconURL) {
					return;
				}
				
				var output = document.createElement("li");
				var link = document.createElement("a");
				
				if (textOnly === true) {
					link.appendChild(document.createTextNode(linkName));
				} else {
					var img = document.createElement("img");  //??? horrible variable name; need to rename
					img.setAttribute("role", "presentation");
					iconURL && img.setAttribute("src", iconURL);
					iconWidth && img.setAttribute("width", iconWidth);
					iconHeight && img.setAttribute("height", iconHeight);
					img.setAttribute("loading", "lazy");
					img.setAttribute("decoding", "async");
					img.setAttribute("aria-hidden", true);
					
					link.appendChild(img);
					link.appendChild(document.createTextNode(linkName));
					link.setAttribute("aria-label", linkName);  //NOTE: we need to create aria-label incase the text is hidden; otherwise, there is nothing for a screen reader to detect inside this link if the text is hidden because the icon is also hidden to screen readers
				}
				
				//HACK: assume that every site's homepage is "home" and rewrite it to "/" //??? consider making this an init()/load() config setting
				if (linkURL.toLowerCase().endsWith(window.location.origin + "/home/") === true || linkURL.toLowerCase().endsWith(window.location.origin + "/home") === true) {
					linkURL = linkURL.replace("/home/", "/");
					linkURL = linkURL.replace("/home", "/");
				}
				
				link.setAttribute("href", linkURL);
				ariaLabel && link.setAttribute("aria-label", ariaLabel);
				
				if (curLink.MenuItemTabTarget === true) {
					link.setAttribute("target", "_blank");
				}
				
				output.appendChild(link);
				
				if (curLink.Children.length > 0) {
					var expanderButton = self.getExpanderButton(linkName);
					
					output.classList.add("hasSubLinks");
					output.appendChild(expanderButton);
					
					output.addEventListener("mouseenter", e => {
						if (window.matchMedia("(min-width: 76.875em)").matches === true) {  //??? need to replace hardcoded media query with enum
							expanderButton.setAttribute("aria-expanded", true);
						}
					});
					
					output.addEventListener("mouseleave", e => {
						if (window.matchMedia("(min-width: 76.875em)").matches === true) {  //??? need to replace hardcoded media query with enum
							expanderButton.setAttribute("aria-expanded", false);
						}
					});
					
					var childLinksContainer = document.createElement("ul");
					
					curLink.Children.forEach(curChildLink => {
						var newChildLink = self.generateSiteNavigationLink(curChildLink);
						
						if (newChildLink) {
							childLinksContainer.appendChild(newChildLink);
						}
					});
					
					output.appendChild(childLinksContainer);
				}
				
				return output;
			};
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				var apiURL = options.apiURL;
				self.additionalQueryStringArguments = options.additionalQueryStringArguments || self.additionalQueryStringArguments;
				self.getExpanderButton = options.getExpanderButton;
				self.declarativeContainerSelector = options.declarativeContainerSelector;
				self.getDeclarativeMenuID = options.getDeclarativeMenuID;
				self.getDeclarativeMenuToken = options.getDeclarativeMenuToken;
				self.getDeclarativeIsPrependingLinks = options.getDeclarativeIsPrependingLinks;
				self.getDeclarativeKeepPlaceHolderContentAfterLoad = options.getDeclarativeKeepPlaceHolderContentAfterLoad;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				//??? wrap new URL() in a try-catch
				if (apiURL.startsWith("/") === true) {
					self.apiURL = new URL(apiURL, document.location.origin);
				} else {
					self.apiURL = new URL(apiURL);
				}
				
				var foundDeclarativeContainers = new WeakSet();
				
				var declarativeContainerSelector = self.declarativeContainerSelector;
				
				declarativeContainerSelector && window.findDynamicComponent({
					parentContainer: "html"
					, targetSelector: declarativeContainerSelector
					, callbackFunction: targetDeclarativeContainer => {
						//GUARD: do nothing if the current container already has a lazyloader
						if (foundDeclarativeContainers.has(targetDeclarativeContainer) === true) {
							return;
						}
						
						var declarativeMenuID = self.getDeclarativeMenuID && self.getDeclarativeMenuID(targetDeclarativeContainer);
						var declarativeMenuToken = self.getDeclarativeMenuToken && self.getDeclarativeMenuToken(targetDeclarativeContainer);
						var isPrependingLinks = self.getDeclarativeIsPrependingLinks && self.getDeclarativeIsPrependingLinks(targetDeclarativeContainer);
						var keepPlaceHolderContentAfterLoad = self.getDeclarativeKeepPlaceHolderContentAfterLoad && self.getDeclarativeKeepPlaceHolderContentAfterLoad(targetDeclarativeContainer);
						
						var wasLazyLoaderCreatedSuccessfully = declarativeMenuID && declarativeMenuToken && window.createLazyLoader && window.createLazyLoader({
							lazyLoadTargets: targetDeclarativeContainer
							, onLoadFunction: curTarget => {
								window.SiteNav && window.SiteNav.isInited && window.SiteNav.load({
									targets: curTarget
									, apiMenuID: declarativeMenuID
									, apiMenuToken: declarativeMenuToken
									, isPrependingLinks: isPrependingLinks === "true" ? true : false
									, keepPlaceHolderContentAfterLoad: keepPlaceHolderContentAfterLoad === "true" ? true : false
								});
							}
						});
						
						wasLazyLoaderCreatedSuccessfully === true && foundDeclarativeContainers.add(targetDeclarativeContainer);
					}
				});
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="alertsbanner-114">
	; (() => {
		const NAMESPACE = "AlertsBanner";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			var bannerContainerSelector;
			var criticalAlertsContainerSelector;
			var advisoryAlertsContainerSelector;
			var criticalAlertsCounterSelector;
			var advisoryAlertsCounterSelector;
			var alertsAPIUrl;
			var criticalAlertKey;
			var advisoryAlertKey;
			var allModes;
			var allModesDisplayString;
			var getAlertsCounterString;
			var createBannerAlert;
			var createAlertBundle;
			var createAlert;
			var onAfterBannerAlertsLoad;
			var onAfterLoad;
			
			//??? rewrite to use better variable names after understanding the copied logic
			var combineInformedEntities = entities => {  //candidate for moving into userland
				var totalModes = entities.length;
				
				if (totalModes === allModes.length) {
					return allModesDisplayString;
				} else {
					var informedEntities = "";
					
					for (var i = 0; i < totalModes; i++) {
						informedEntities = informedEntities + entities[i].mode;
						
						if (entities[i].lines !== null && entities[i].mode.toLowerCase() === "skytrain") {  //??? ugly hardcoding
							var lines = entities[i].lines.join(", ");
							
							if (lines.trim() !== "") {
								informedEntities = informedEntities + ": " + lines;
							}
						}
						
						if (i !== totalModes - 1) {
							informedEntities = informedEntities + ", ";
						}
					}
					
					return informedEntities;
				}
			};
			
			var renderAlerts = (allTargetAlerts, targetContainerSelector, allAlerts) => {
				var targetContainer = targetContainerSelector && document.querySelectorAll(targetContainerSelector);
				
				allTargetAlerts && allTargetAlerts.length > 0 && targetContainer.forEach(curContainer => {
					window.deleteAllChildNodes(curContainer);
				});
				
				targetContainer && targetContainer.length > 0 && allTargetAlerts.forEach((curAlert, curAlertIdx) => {
					var renderedAlert = createAlert(() => {
						var context = {};
						
						context.isClosedAlert = curAlert.closed;
						context.isCriticalAlert = curAlert.group === criticalAlertKey;
						context.isAdvisoryAlert = curAlert.group === advisoryAlertKey;
						context.alertEffect = curAlert.effect;
						context.affectedModes = combineInformedEntities(curAlert.informedEntities);
						context.headerText = curAlert.header;
						context.descriptionText = curAlert.description;
						context.url = curAlert.url;
						context.lastModifiedDateTime = curAlert.lastModified;
						context.startTime = curAlert.startTime;
						context.endTime = curAlert.endStamp === 3 ? window.buildDateTimeString(curAlert.endTime) : window.TRANSIT_ALERT_END_TIME_LABELS[curAlert.endStamp];
						
						return context;
					});
					
					allAlerts && allAlerts.push(renderedAlert);
					
					targetContainer.forEach(curContainer => {
						curContainer.append(renderedAlert.cloneNode(true));
						
						if (curAlertIdx === 0) {  //??? this section is completely based on the implementation and should be userland
							var modeContainer = curContainer.closest(".ModeContainer");
							
							modeContainer && modeContainer.removeAttribute("hidden"); //??? this is way too hard coded
						}
					});
				});
			};
			
			self.isInited = false;
			
			self.init = async options => {
				//GUARD:  do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD:  do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				bannerContainerSelector = options.bannerContainerSelector;
				criticalAlertsContainerSelector = options.criticalAlertsContainerSelector;
				advisoryAlertsContainerSelector = options.advisoryAlertsContainerSelector;
				criticalAlertsCounterSelector = options.criticalAlertsCounterSelector;
				advisoryAlertsCounterSelector = options.advisoryAlertsCounterSelector;
				criticalAlertKey = options.criticalAlertKey;
				advisoryAlertKey = options.advisoryAlertKey;
				allModes = options.allModes;
				allModesDisplayString = options.allModesDisplayString;
				getAlertsCounterString = options.getAlertsCounterString;
				createBannerAlert = options.createBannerAlert;
				createAlertBundle = options.createAlertBundle;
				createAlert = options.createAlert;
				onAfterBannerAlertsLoad = options.onAfterBannerAlertsLoad;
				onAfterLoad = options.onAfterLoad;
				
				//GUARD: do nothing if bannerContainerSelector does not exist or is not a string
				if (!bannerContainerSelector || window.getType(bannerContainerSelector) !== window.getType.string) {
					return;
				}
				
				var bannerContainer;
				
				try {
					const WEB_BANNER_ALERTS_MODULE_URL_STRING = "/js/webbanneralerts.mjs";
					
					var webBannerAlertsModuleURL = WEB_BANNER_ALERTS_MODULE_URL_STRING && new URL(WEB_BANNER_ALERTS_MODULE_URL_STRING, document.location.origin);
					
					var { fetchAllWebBannerAlerts } = webBannerAlertsModuleURL && await import(webBannerAlertsModuleURL);
					
					try {
						var allAlerts = fetchAllWebBannerAlerts && await fetchAllWebBannerAlerts;
						
						bannerContainer = bannerContainerSelector && document.querySelector(bannerContainerSelector);
						
						//to remove the custom height for banner alerts on page load
						if (bannerContainer) {
							bannerContainer.style.removeProperty("--customHeightInPXForPageLoad");
						} else {
							window.findDynamicComponent({
								parentContainer: "html"
								, targetSelector: bannerContainerSelector
								, callbackFunction: target => {
									target.style.removeProperty("--customHeightInPXForPageLoad");
								}
								, runOnce: true
							});
						}
						
						//GUARD: do nothing if there are no alerts
						if (!allAlerts || allAlerts.length === 0) {
							return;
						}
						
						var allRenderedBannerAlerts = [];
						
						//??? should we also sort these?
						var criticalAlerts = allAlerts.filter(curAlert => curAlert.group === criticalAlertKey);
						var advisoryAlerts = allAlerts.filter(curAlert => curAlert.group === advisoryAlertKey);
						
						//render banner alerts
						switch (criticalAlerts.length) {
							case 0:
								; (() => {
									if (advisoryAlerts.length > 2) {
										allRenderedBannerAlerts.push(createAlertBundle(() => {
											var context = {};
											
											context.alertType = advisoryAlertKey;
											context.numAlerts = advisoryAlerts.length;
											context.lastModifiedDateTime = advisoryAlerts[0].lastModified;
											
											return context;
										}));
									} else {
										advisoryAlerts.forEach(curAlert => {
											var output = createBannerAlert(() => {
												var context = {};
												
												context.isCriticalAlert = curAlert.group === criticalAlertKey;
												context.isAdvisoryAlert = curAlert.group === advisoryAlertKey;
												context.alertEffect = curAlert.effect;
												context.affectedModes = combineInformedEntities(curAlert.informedEntities);
												context.headerText = curAlert.bannerText;
												context.descriptionText = curAlert.description;
												context.alertURL = curAlert.alertURL;
												context.lastModifiedDateTime = curAlert.lastModified;
												
												return context;
											});
											
											allRenderedBannerAlerts.push(output);
										});
									}
								})();
								
								break;
							case 1:
							case 2:
								; (() => {
									criticalAlerts.forEach(curAlert => {
										var output = createBannerAlert(() => {
											var context = {};
											
											context.isCriticalAlert = curAlert.group === criticalAlertKey;
											context.isAdvisoryAlert = curAlert.group === advisoryAlertKey;
											context.alertEffect = curAlert.effect;
											context.affectedModes = combineInformedEntities(curAlert.informedEntities);
											context.headerText = curAlert.bannerText;
											context.descriptionText = curAlert.description;
											context.alertURL = curAlert.alertURL;
											context.lastModifiedDateTime = curAlert.lastModified;
											
											return context;
										});
										
										allRenderedBannerAlerts.push(output);
									});
								})();
								
								break;
							default:
								; (() => {
									//there are 3 or more critical alerts, so show a direct link to alerts page
									allRenderedBannerAlerts.push(createAlertBundle(() => {
										var context = {};
										
										context.alertType = criticalAlertKey;
										context.numAlerts = criticalAlerts.length;
										context.lastModifiedDateTime = criticalAlerts[0].lastModified;
										
										return context;
									}));
								})();
								
								break;
						}
						
						//try to render banner alerts as soon as possible, even before DOMContentLoaded
						var bannerContainer = document.querySelector(bannerContainerSelector);
						
						//??? this should be a helper like runAfterDOMContentLoaded()?
						if (bannerContainer) {
							allRenderedBannerAlerts.forEach(curRenderedAlert => {
								bannerContainer && bannerContainer.append && bannerContainer.append(curRenderedAlert);
							});
							
							onAfterBannerAlertsLoad && onAfterBannerAlertsLoad(allRenderedBannerAlerts);
						} else {
							window.findDynamicComponent({
								parentContainer: "html"
								, targetSelector: bannerContainerSelector
								, callbackFunction: target => {
									allRenderedBannerAlerts.forEach(curRenderedAlert => {
										bannerContainer && bannerContainer.append && bannerContainer.append(curRenderedAlert);
									});
									
									onAfterBannerAlertsLoad && onAfterBannerAlertsLoad(allRenderedBannerAlerts);
								}
								, runOnce: true
							});
						}
						
						window.runAfterDOMContentLoaded && window.runAfterDOMContentLoaded(document, () => {
							//set critical alerts counters
							var criticalAlertsCounterText = getAlertsCounterString(criticalAlerts.length);
							
							var allCriticalAlertsCounterElements = document.querySelectorAll(criticalAlertsCounterSelector);
							
							allCriticalAlertsCounterElements.forEach(curCriticalAlertsCounterElement => {
								curCriticalAlertsCounterElement.textContent = criticalAlertsCounterText;
							});
							
							//set advisory alerts counters
							var advisoryAlertsCounterText = getAlertsCounterString(advisoryAlerts.length);
							
							var allAdvisoryAlertsCounterElements = document.querySelectorAll(advisoryAlertsCounterSelector);
							
							allAdvisoryAlertsCounterElements.forEach(curAdvisoryAlertsCounterElement => {
								curAdvisoryAlertsCounterElement.textContent = advisoryAlertsCounterText;
							});
							
							//render all critical and advisory alerts
							var allRenderedAlerts = [];
							
							renderAlerts(criticalAlerts, criticalAlertsContainerSelector, allRenderedAlerts);
							renderAlerts(advisoryAlerts, advisoryAlertsContainerSelector, allRenderedAlerts);
							
							onAfterLoad && onAfterLoad(allRenderedBannerAlerts, allRenderedAlerts);
						});
					} catch (error) {
						console.error(error);
					}
				} catch (error) {
					console.error(error);
				} finally {
					//to remove the custom height for the banner alerts on page load in case there is an error
					bannerContainer = bannerContainerSelector && document.querySelector(bannerContainerSelector);
					
					if (bannerContainer) {
						bannerContainer.style.removeProperty("--customHeightInPXForPageLoad");
					} else {
						window.findDynamicComponent({
							parentContainer: "html"
							, targetSelector: bannerContainerSelector
							, callbackFunction: target => {
								target.style.removeProperty("--customHeightInPXForPageLoad");
							}
							, runOnce: true
						});
					}
				}
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="init above the fold widgets">
	; (() => {
		document.documentElement.hasAttribute("data-page-has-alerts-banner") === true && window.AlertsBanner && window.AlertsBanner.init({
			bannerContainerSelector: ".bannerAlerts"
			, criticalAlertsContainerSelector: '[data-critical-alerts="all" i]'
			, advisoryAlertsContainerSelector: '[data-advisory-alerts="all" i]'
			, criticalAlertsCounterSelector: '[data-critical-alerts-counter-for="all"]'
			, advisoryAlertsCounterSelector: '[data-advisory-alerts-counter-for="all"]'
			, criticalAlertKey: window.CRITICAL_ALERT_KEY
			, advisoryAlertKey: window.ADVISORY_ALERT_KEY
			, allModes: window.ALL_TRANSIT_MODES
			, allModesDisplayString: "All Modes"
			, getAlertsCounterString: numAlerts => {
				var output = "No Alerts";
				
				//GUARD: do nothing if no alerts count was provided
				if (!numAlerts && numAlerts !== 0) {
					return output;
				}
				
				if (window.getType(numAlerts) === window.getType.string) {
					numAlerts = parseInt(numAlerts, 10);
				}
				
				//GUARD: do nothing if no number of alerts was provided
				if (window.getType(numAlerts) !== window.getType.number) {
					return output;
				}
				
				switch (numAlerts) {
					case 0:
						; (() => {
							//
						})();
						
						break;
					case 1:
						; (() => {
							output = "1 Alert";
						})();
						
						
						break;
					default:
						; (() => {
							output = `${numAlerts} Alerts`;
						})();
						
						break;
				}
				
				return output;
			}
			, createBannerAlert: getBannerAlertContext => {
				var context = getBannerAlertContext && getBannerAlertContext();
				
				//GUARD: do nothing if there is no context
				if (!context) {
					return;
				}
				
				var isCriticalAlert = context.isCriticalAlert;
				var isAdvisoryAlert = context.isAdvisoryAlert;
				var alertEffect = window.TRANSIT_ALERT_EFFECTS[context.alertEffect] || context.alertEffect || "";
				var affectedModes = context.affectedModes || "";
				var headerText = context.headerText || "";
				var descriptionText = context.descriptionText || "";
				var alertURL = context.alertURL || "";
				var lastModifiedDateTime = context.lastModifiedDateTime || "";
				
				var output = document.createElement("div");
				output.setAttribute("class", "layoutItem");
				
				var alertElement = document.createElement("details");
				alertElement.setAttribute("class", "InfoCard AlertBannerInfoCardTheme layoutItemContent");
				isCriticalAlert && alertElement.setAttribute("data-alert-severity", window.CRITICAL_ALERT_LABEL);
				isAdvisoryAlert && alertElement.setAttribute("data-alert-severity", window.ADVISORY_ALERT_LABEL);
				
				var headerElement = document.createElement("summary");
				headerElement.setAttribute("class", "Header");
				
				var headerLayoutElement = document.createElement("div");
				headerLayoutElement.setAttribute("class", "flexContainer");
				
				var headerTextWrapperElement = document.createElement("div");
				
				var headerTextElement = document.createElement("p");
				
				var headerTextFormattingElement = document.createElement("strong");
				headerTextFormattingElement.textContent = affectedModes;
				
				headerTextElement.append(headerTextFormattingElement);
				
				var lastModifiedElement = document.createElement("time");
				lastModifiedElement.setAttribute("datetime", lastModifiedDateTime);
				lastModifiedElement.textContent = `Updated ${window.buildLastModifiedDateTimeString(lastModifiedDateTime)}`;
				
				headerTextWrapperElement.append(headerTextElement);
				headerTextWrapperElement.append(lastModifiedElement);
				
				var alertEffectElement = document.createElement("span");
				alertEffectElement.setAttribute("style", "margin-top: 0px;");
				alertEffectElement.textContent = alertEffect;
				
				headerLayoutElement.append(headerTextWrapperElement);
				headerLayoutElement.append(alertEffectElement);
				
				headerElement.append(headerLayoutElement);
				
				var contentBodyLayoutElement = document.createElement("div");
				
				var backgroundElement = document.createElement("div");
				backgroundElement.setAttribute("class", "Background");
				
				var imageMainElement = document.createElement("div");
				imageMainElement.setAttribute("class", "ImageMain");
				
				var copyMainElement = document.createElement("div");
				copyMainElement.setAttribute("class", "CopyMain");
				
				var alertBannerElement = document.createElement("p");
				alertBannerElement.textContent = headerText;
				
				var alertDescriptionElement = document.createElement("p");
				alertDescriptionElement.textContent = descriptionText;
				
				copyMainElement.append(alertBannerElement);
				copyMainElement.append(alertDescriptionElement);
				
				if (alertURL && alertURL !== "") {
					var alertURLElement = document.createElement("a");
					
					alertURLElement.setAttribute("href", alertURL);
					alertURLElement.setAttribute("title", "Link to more alert information");
					alertURLElement.textContent = alertURL;
					
					copyMainElement.append(alertURLElement);
				}
				
				var ctaLinkContainerElement = document.createElement("div");
				ctaLinkContainerElement.setAttribute("class", "CTALinkContainer");
				
				var ctaLinkElement = document.createElement("a");
				ctaLinkElement.setAttribute("href", window.ALERTS_PAGE_URL);
				ctaLinkElement.setAttribute("title", "Link to All Alerts on Alerts Page");
				ctaLinkElement.textContent = "View All Alerts";
				
				ctaLinkContainerElement.append(ctaLinkElement);
				
				contentBodyLayoutElement.append(backgroundElement);
				contentBodyLayoutElement.append(imageMainElement);
				contentBodyLayoutElement.append(copyMainElement);
				contentBodyLayoutElement.append(ctaLinkContainerElement);
				
				alertElement.append(headerElement);
				alertElement.append(contentBodyLayoutElement);
				
				output.append(alertElement);
				
				return output;
			}
			, createAlertBundle: getAlertBundleContext => {
				var context = getAlertBundleContext && getAlertBundleContext();
				
				//GUARD: do nothing if there is no context
				if (!context) {
					return;
				}
				
				var alertType = context.alertType;
				var numAlerts = context.numAlerts;
				var lastModifiedDateTime = context.lastModifiedDateTime || "";
				
				//GUARD: do nothing if there is no alert type provided
				if (!alertType) {
					return;
				}
				
				var output = document.createElement("div");
				output.setAttribute("class", "layoutItem");
				
				var alertBundleElement = document.createElement("article");
				alertBundleElement.setAttribute("class", "InfoCard AlertBannerInfoCardTheme layoutItemContent");
				alertBundleElement.setAttribute("data-alert-severity", alertType ? "CriticalBundle" : "AdvisoryBundle");
				
				var backgroundElement = document.createElement("div");
				backgroundElement.setAttribute("class", "Background");
				
				var headerElement = document.createElement("header");
				headerElement.setAttribute("class", "Header");
				
				var headerTextElement = document.createElement("p");
				
				var headerTextFormattingElement = document.createElement("strong");
				headerTextFormattingElement.textContent = "Transit Alerts Issued";
				
				headerTextElement.append(headerTextFormattingElement);
				headerElement.append(headerTextElement);
				
				var imageMainElement = document.createElement("section");
				imageMainElement.setAttribute("class", "ImageMain");
				
				var alertIcon = document.createElement("img");
				
				switch (alertType) {
					case window.CRITICAL_ALERT_KEY:
						; (() => {
							alertIcon = document.createElement("img");
							alertIcon.setAttribute("role", "presentation");
							alertIcon.setAttribute("src", "/-/media/translink/icons/alerts/critical.svg");
							alertIcon.setAttribute("width", 40);
							alertIcon.setAttribute("height", 40);
							alertIcon.setAttribute("loading", "lazy");
							alertIcon.setAttribute("decoding", "async");
							alertIcon.setAttribute("aria-hidden", true);
						})();
						
						imageMainElement.append(alertIcon);
						
						break;
					case window.ADVISORY_ALERT_KEY:
						; (() => {
							alertIcon = document.createElement("img");
							alertIcon.setAttribute("role", "presentation");
							alertIcon.setAttribute("src", "/-/media/translink/icons/alerts/advisory.svg");
							alertIcon.setAttribute("width", 40);
							alertIcon.setAttribute("height", 40);
							alertIcon.setAttribute("loading", "lazy");
							alertIcon.setAttribute("decoding", "async");
							alertIcon.setAttribute("aria-hidden", true);
						})();
						
						imageMainElement.append(alertIcon);
						
						break;
				}
				
				var copyMainElement = document.createElement("section");
				copyMainElement.setAttribute("class", "CopyMain");
				
				var lastModifiedElement = document.createElement("time");
				lastModifiedElement.setAttribute("datetime", lastModifiedDateTime);
				lastModifiedElement.textContent = `Updated ${window.buildLastModifiedDateTimeString(lastModifiedDateTime)}`;
				
				copyMainElement.append(lastModifiedElement);
				
				var ctaLinkContainerElement = document.createElement("div");
				ctaLinkContainerElement.setAttribute("class", "CTALinkContainer");
				
				var ctaLinkElement = document.createElement("a");
				
				switch (alertType) {
					case window.CRITICAL_ALERT_KEY:
						; (() => {
							ctaLinkElement.setAttribute("href", window.CRITICAL_ALERTS_PAGE_URL);
							ctaLinkElement.setAttribute("title", "Link to Critical Alerts on Alerts Page");
							ctaLinkElement.textContent = `${numAlerts} Critical Alerts`;
						})();
						
						break;
					case window.ADVISORY_ALERT_KEY:
						; (() => {
							ctaLinkElement.setAttribute("href", window.ADVISORY_ALERTS_PAGE_URL);
							ctaLinkElement.setAttribute("title", "Link to Advisory Alerts on Alerts Page");
							ctaLinkElement.textContent = `${numAlerts} Advisory Alerts`;
						})();
						
						break;
					default:
						; (() => {
							//??? add error logging
						})();
						
						break;
				}
				
				ctaLinkContainerElement.append(ctaLinkElement);
				
				alertBundleElement.append(backgroundElement);
				alertBundleElement.append(headerElement);
				alertBundleElement.append(imageMainElement);
				alertBundleElement.append(copyMainElement);
				alertBundleElement.append(ctaLinkContainerElement);
				
				output.append(alertBundleElement);
				
				return output;
			}
			, createAlert: window.buildAlert
			, onAfterBannerAlertsLoad: allBannerAlerts => {
				//GUARD: do nothing if there is more than one banner alert; when there are 2 or more banner alerts, they are always closed on pageload
				allBannerAlerts = allBannerAlerts && allBannerAlerts.filter && allBannerAlerts.filter(x => x); //NOTE: "filter(x => x)" to remove empty strings and other falsey values
				
				if (allBannerAlerts.length > 1) {
					return;
				}
				
				const BANNER_ALERT_SNOOZE_TIME_KEY = "CriticalAlertBannerSnoozeTime";
				
				var savedSnoozeTimeString = window.TemporaryStorage && window.TemporaryStorage.getItem(BANNER_ALERT_SNOOZE_TIME_KEY);
				var previousSnoozeDateTime = savedSnoozeTimeString && new Date(savedSnoozeTimeString);
				
				//GUARD: do nothing if the previous snooze time is not a valid date
				//??? use MJS version of isValidDate
				if (savedSnoozeTimeString && previousSnoozeDateTime && window.isValidDate(previousSnoozeDateTime) === false) {
					return;
				}
				
				const TWENTY_MINUTES_IN_MILLISECONDS = 1200000;  //1,200,000ms is 20minutes
				
				var curDateTime = new Date();
				
				var hasSnoozeExpired = previousSnoozeDateTime && (curDateTime - previousSnoozeDateTime >= TWENTY_MINUTES_IN_MILLISECONDS);
				
				if (!previousSnoozeDateTime || hasSnoozeExpired === true) {
					allBannerAlerts.forEach(curBannerAlert => {
						var curAccordionHeader = curBannerAlert && curBannerAlert.querySelector && curBannerAlert.querySelector("summary");
						
						curAccordionHeader && curAccordionHeader.click && curAccordionHeader.click();  //click the alert to open it
					});
				}
				
				allBannerAlerts.forEach(curBannerAlert => {
					var curAccordionHeader = curBannerAlert && curBannerAlert.querySelector && curBannerAlert.querySelector("summary");
					
					curAccordionHeader && curAccordionHeader.addEventListener("click", () => {
						window.TemporaryStorage && window.TemporaryStorage.setItem(BANNER_ALERT_SNOOZE_TIME_KEY, new Date());
						
						//??? in the future once TemporaryStorage returns a true/false for setItem(), I can put error logging here
					});
				});
			}
			, onAfterLoad: window.noop
		});
		
		window.SiteNav && window.SiteNav.init({
			apiURL: window.buildEnvironmentSpecificURL("https://getaway.translink.ca/api/sitenav-v3")  //??? replace with URL Object Pattern
			, additionalQueryStringArguments: window.location.host.startsWith("cm.") ? "&env=cm":  ""
			, getExpanderButton: linkName => {
				var expanderButton = document.createElement("button");
				expanderButton.setAttribute("type", "button");
				expanderButton.setAttribute("data-type", "unstyledButton");
				expanderButton.setAttribute("aria-expanded", false);
				expanderButton.setAttribute("aria-label", `Subpages for ${linkName} page`);
				
				var expanderButtonIcon = document.createElement("img");
				expanderButtonIcon.setAttribute("role", "presentation");
				expanderButtonIcon.setAttribute("src", "https://tlweblibs.translink.ca/Chevron_DefaultHoverFocusSelected.svg");
				expanderButtonIcon.setAttribute("width", 9);
				expanderButtonIcon.setAttribute("height", 6);
				expanderButtonIcon.setAttribute("aria-hidden", true);
				
				expanderButton.appendChild(expanderButtonIcon);
				
				return expanderButton;
			}
			, declarativeContainerSelector: 'nav[aria-label]:not([aria-label=""])[aria-label]:not([aria-label=""])[data-sitenav-menu-id]:not([data-sitenav-menu-id=""])[data-sitenav-menu-token]:not([data-sitenav-menu-token=""])'
			, getDeclarativeMenuID: container => {
				const MENU_ID_ATTRIBUTE_SELECTOR = "data-sitenav-menu-id";
				
				var output = container && container.hasAttribute && container.hasAttribute(MENU_ID_ATTRIBUTE_SELECTOR) && container.getAttribute && container.getAttribute(MENU_ID_ATTRIBUTE_SELECTOR);
				
				return output;
			}
			, getDeclarativeMenuToken: container => {
				const MENU_TOKEN_ATTRIBUTE_SELECTOR = "data-sitenav-menu-token";
				
				var output = container && container.hasAttribute && container.hasAttribute(MENU_TOKEN_ATTRIBUTE_SELECTOR) && container.getAttribute && container.getAttribute(MENU_TOKEN_ATTRIBUTE_SELECTOR);
				
				return output;
			}
			, getDeclarativeIsPrependingLinks: container => {
				const MENU_APPEND_LOCATION_ATTRIBUTE_SELECTOR = "data-sitenav-prepend-links";
				
				var output = container && container.hasAttribute && container.hasAttribute(MENU_APPEND_LOCATION_ATTRIBUTE_SELECTOR) && container.getAttribute && container.getAttribute(MENU_APPEND_LOCATION_ATTRIBUTE_SELECTOR);
				
				return output;
			}
			, getDeclarativeKeepPlaceHolderContentAfterLoad: container => {
				const MENU_APPEND_LOCATION_ATTRIBUTE_SELECTOR = "data-keep-placeholder-content";
				
				var output = container && container.hasAttribute && container.hasAttribute(MENU_APPEND_LOCATION_ATTRIBUTE_SELECTOR) && container.getAttribute && container.getAttribute(MENU_APPEND_LOCATION_ATTRIBUTE_SELECTOR);
				
				return output;
			}
		});
	})();
</script> <!-- END OF Global Head JS -->
    <!-- Site Head JS -->
    <script class="escape-iframe-and-load-same-page">
	; (() => {
		try {
			var curPageURLString = window.location.href;
			
			//GUARD: do nothing if there is no current URL
			if (!curPageURLString) {
				return;
			}
			
			//GUARD: do not run in:
			//sitecore admin panel
			if (curPageURLString.indexOf("/sitecore/") > -1) {
				return;
			}
			
			var curPageURL = curPageURLString && new URL(curPageURLString);
			
			//GUARD: do nothing if this page isn't in an iframe
			if (window.self === window.top) {
				return;
			}
			
			window.parent.location.href = curPageURL;
		} catch (error) {
			console.error(error);
		}
	})();
</script> <!-- END OF Site Head JS -->
    <!-- Page Head JS -->
    <!-- END OF Page Head JS -->
    <!-- Fonts CSS -->
    <style class="fallback-font-styles-when-font-files-are-missing">
        @font-face
        {
            font-family: "ArialPlaceholderBeforeFiraIsLoaded";
            src: local(Arial);
            size-adjust: 119%;
        }

        html, button, input, textarea, select, option
        {
            font-family: "ArialPlaceholderBeforeFiraIsLoaded", Helvetica, sans-serif;
            font-size: 18px;
        }
    </style>
    <style class="firafont-131">
	@font-face {
		font-family: "Fira Sans Regular";
		src: url("https://tlweblibs.translink.ca/FiraSans-Regular.woff2") format("woff2");
		
		font-display: swap;
	}
	
	@font-face {
		font-family: "Fira Sans Bold";
		src: url("FiraSans-Bold.woff2") format("woff2");
		
		font-display: swap;
		font-weight: 700;
	}
	
	@font-face {
		font-family: "Fira Sans Italic";
		src: url("FiraSans-Italic.woff2") format("woff2");
		
		font-display: swap;
		font-style: italic;
	}
	
	@font-face {
		font-family: "Fira Sans Medium";
		src: url("FiraSans-Medium.woff2") format("woff2");
		
		font-display: swap;
	}
	
	@font-face {
		font-family: "Fira Sans SemiBold";
		src: url("FiraSans-SemiBold.woff2") format("woff2");
		
		font-display: swap;
	}
	
	@media not all and (min-width: 48em) {
		h1
		{
			font-family: "Fira Sans SemiBold", Arial, Helvetica, sans-serif;
			
			font-size: 1.7778rem !important; /* override normalize.css */
			line-height: 2.2222rem;
		}
		
		h2
		{
			font-family: "Fira Sans SemiBold", Arial, Helvetica, sans-serif;
			
			font-size: 1.3333rem;
			line-height: 1.5rem;
		}
		
		h3
		{
			font-family: "Fira Sans Medium", Arial, Helvetica, sans-serif;
			
			font-size: 1.1111rem;
			line-height: 1.3333rem;
		}
		
		h4
		{
			font-family: "Fira Sans Medium", Arial, Helvetica, sans-serif;
			
			font-size: 0.8888rem;
			line-height: 1.3333rem;
		}
		
		h5
		{
			font-family: "Fira Sans Medium", Arial, Helvetica, sans-serif;
			
			font-size: 0.8888rem;
			line-height: 1.3333rem;
		}
		
		h6
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif;
			
			font-size: 0.7777rem;
			line-height: 1rem;
		}
		
		p
		, img
		, li::marker
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif;
			
			font-size: 0.8888rem;
			line-height: 1.5rem;
			
			font-weight: normal;
			
			text-wrap: pretty;
		}
		
		blockquote
		{
			font-family: "Fira Sans Italic", Arial, Helvetica, sans-serif;
			
			font-size: 0.8888rem;
			line-height: 1.5rem;
			
			font-weight: normal;
		}
		
		address
		{
			font-style: normal;
		}
		
		a
		, span
		, th
		, td
		, address
		, time
		, [data-role="p"]
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif;
			
			font-size: 0.8888rem;
			line-height: 1.3333rem;
			
			font-weight: normal;
		}
		
		input
		, textarea
		, select
		, optgroup
		, option
		, button
		, [role="button"]
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif !important; /* override normalize.css for button, input, optgroup, select, textarea */
			
			font-size: 0.8888rem !important; /* override normalize.css for button, input, optgroup, select, textarea */
			line-height: 1.3333rem;
			
			font-weight: normal;
		}
		
		label
		, legend
		{
			font-family: "Fira Sans Bold", Arial, Helvetica, sans-serif;
			
			font-size: 0.8888rem;
			line-height: 1.5rem;
			
			font-weight: 700;
		}
		
		b
		, strong
		{
			font-family: "Fira Sans Bold", Arial, Helvetica, sans-serif;
			
			font-size: 0.8888rem;
			line-height: 1.1111rem;
			
			font-weight: 700;
		}
		
		i
		, em
		, q
		{
			font-family: "Fira Sans Italic", Arial, Helvetica, sans-serif;
			
			font-style: italic;
		}
		
		*:not(h1, h2, h3, h4, h5, h6) > i
		, *:not(h1, h2, h3, h4, h5, h6) > em
		, *:not(h1, h2, h3, h4, h5, h6) > q
		{
			font-size: 0.8888rem;
			line-height: 1.1111rem;
		}
		
		small
		, small *
		, [data-role="small"]
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif;
			
			font-size: 0.7778rem;
			line-height: 1.25rem;
			
			text-wrap: pretty;
		}
		
		@supports (-webkit-touch-callout: none) { /* target only iOS because it doesn't render letter-spacing properly when the font doesn't support that font-weight */
			h1
			, h2
			, h3
			, h4
			, h5
			, label small
			, label [data-role="small"] 
			, label small *
			, label [data-role="small"] *
			, strong
			{
				letter-spacing: -0.9px;
			}
		}
	}
	
	@media (min-width: 48em) {
		h1
		{
			font-family: "Fira Sans SemiBold", Arial, Helvetica, sans-serif;
			
			font-size: 3.1111rem !important; /* override normalize.css */
			line-height: 3.5556rem;
		}
		
		h2
		{
			font-family: "Fira Sans Medium", Arial, Helvetica, sans-serif;
			
			font-size: 2rem;
			line-height: 2.2222rem;
		}
		
		h3
		{
			font-family: "Fira Sans Medium", Arial, Helvetica, sans-serif;
			
			font-size: 1.3333rem;
			line-height: 1.7778rem;
		}
		
		h4
		{
			font-family: "Fira Sans Medium", Arial, Helvetica, sans-serif;
			
			font-size: 1.3333rem;
			line-height: 1.7777rem;
		}
		
		h5
		{	
			font-family: "Fira Sans SemiBold", Arial, Helvetica, sans-serif;
			
			font-size: 1.3333rem;
			line-height: 1.3333rem;
		}
		
		h6
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif;
			
			font-size: 1rem;
			line-height: 1.1111rem;
		}
		
		p
		, img
		, li::marker
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif;
			
			font-size: 1rem;
			line-height: 1.5rem;
			
			font-weight: normal;
			
			text-wrap: pretty;
		}
		
		blockquote
		{
			font-family: "Fira Sans Italic", Arial, Helvetica, sans-serif;
			
			font-size: 1rem;
			line-height: 1.5rem;
			
			font-weight: normal;
		}
		
		address
		{
			font-style: normal;
		}
		
		a
		, span
		, th
		, td
		, address
		, time
		, [data-role="p"]
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif;
			
			font-size: 1rem;
			line-height: 1.3333rem;
			
			font-weight: normal;
		}
		
		input
		, textarea
		, select
		, optgroup
		, option
		, button
		, [role="button"]
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif !important; /* override normalize.css for button, input, optgroup, select, textarea */
			
			font-size: 1rem !important; /* override normalize.css for button, input, optgroup, select, textarea */
			line-height: 1.15rem;
			
			font-weight: normal;
		}
		
		label
		, legend
		{
			font-family: "Fira Sans Bold", Arial, Helvetica, sans-serif;
			
			font-size: 1rem;
			line-height: 1.5rem;
			
			font-weight: 700;
		}
		
		b
		, strong
		{
			font-family: "Fira Sans Bold", Arial, Helvetica, sans-serif;
			
			font-size: 1rem;
			line-height: 1.1111rem;
			
			font-weight: 700;
		}
		
		i
		, em
		, q
		{
			font-family: "Fira Sans Italic", Arial, Helvetica, sans-serif;
			
			font-style: italic;
		}
		
		*:not(h1, h2, h3, h4, h5, h6) > i
		, *:not(h1, h2, h3, h4, h5, h6) > em
		, *:not(h1, h2, h3, h4, h5, h6) > q
		{
			font-size: 1rem;
			line-height: 1.1111rem;
		}
		
		small
		, small *
		, [data-role="small"]
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif;
			
			font-size: 0.7778rem;
			line-height: 1.25rem;
			
			text-wrap: pretty;
		}
		
		@supports (-webkit-touch-callout: none) { /* target only iOS because it doesn't render letter-spacing properly when the font doesn't support that font-weight */
			h1
			, h2
			, h3
			, h4
			, h5
			, label small
			, label [data-role="small"] 
			, label small *
			, label [data-role="small"] *
			, strong
			{
				letter-spacing: -0.9px;
			}
		}
	}
	
	a[href*=".pdf"]:after
	,a[href*=".xsl"]:after
	, a[href*=".xslx"]:after
	, a[href*=".csv"]:after
	, a[href*=".doc"]:after
	, a[href*=".docx"]:after
	{
		content: "";
		
		display: inline-block;
		
		margin-left: 0.25rem;
		margin-right: 0.05rem;
		width: 0.7778rem;
		height: 1rem;
		
		background-repeat: no-repeat;
		background-position: 0 0;
		
		vertical-align: text-top;
	}
	
	a[href*=".pdf"]:after
	{
		background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNCAxOCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwNTVlYWE7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5wZGZERmVmYXVsdDwvdGl0bGU+PGcgaWQ9IkxheWVyXzIiIGRhdGEtbmFtZT0iTGF5ZXIgMiI+PGcgaWQ9IkxheWVyXzEtMiIgZGF0YS1uYW1lPSJMYXllciAxIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik03Ljg4LDYuM2g0LjgxTDcuODgsMS4zNVY2LjNNMS43NSwwaDdMMTQsNS40VjE2LjJBMS43OCwxLjc4LDAsMCwxLDEyLjI1LDE4SDEuNzVBMS43OCwxLjc4LDAsMCwxLDAsMTYuMlYxLjhBMS43OCwxLjc4LDAsMCwxLDEuNzUsME01LjM0LDguNDZBMTMuODYsMTMuODYsMCwwLDEsMy41LDEyLjY4Uy40NCwxNC4zMiwxLjE2LDE1LjU0Yy41OSwxLDIsMCwzLjI4LTIuNDFhMTUuMzQsMTUuMzQsMCwwLDEsMy43MS0uNzRTMTEuNTIsMTQsMTIsMTIuMjksOS4zMSwxMSw4Ljc1LDExLjE3QTYuMDksNi4wOSwwLDAsMSw2LjU2LDguMjhzMS0zLjU1LS41My0zLjUxLTEsMi44Mi0uNjksMy42OW0uNzEuOTRBNi44Myw2LjgzLDAsMCwwLDcuNywxMS42MWEyMS4wNywyMS4wNywwLDAsMC0zLC44MSwxNy42MiwxNy42MiwwLDAsMCwxLjMyLTNtMy40NCwyLjQ0Yy41LS4xNCwyLC4xNCwyLC40NHMtMi0uNDQtMi0uNDRNMy4zLDEzLjVhMy4zMiwzLjMyLDAsMCwxLTEuNDYsMS44Yy0uMiwwLC42MS0xLjQ0LDEuNDYtMS44TTYuMDUsNy4yNmMwLS4wNi0uMzItMiwwLTEuOTNDNi41Miw1LjQsNi4wNSw3LjIsNi4wNSw3LjI2WiIvPjwvZz48L2c+PC9zdmc+");
	}
	
	a[href*=".xsl"]:after
	, a[href*=".xslx"]:after
	 ,a[href*=".csv"]:after
	{
		background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNCAxOCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwZjYwYWE7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5leGNlbERlZmF1bHQ8L3RpdGxlPjxnIGlkPSJMYXllcl8yIiBkYXRhLW5hbWU9IkxheWVyIDIiPjxnIGlkPSJMYXllcl8xLTIiIGRhdGEtbmFtZT0iTGF5ZXIgMSI+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNOC43NSwwaC03QTEuNzgsMS43OCwwLDAsMCwwLDEuOFYxNi4yQTEuNzgsMS43OCwwLDAsMCwxLjc1LDE4aDEwLjVBMS43OCwxLjc4LDAsMCwwLDE0LDE2LjJWNS40TDguNzUsMG0xLjU4LDE2LjJIOC43NUw3LDEzLjE0LDUuMjUsMTYuMkgzLjY3bDIuNTQtNEwzLjY3LDguMUg1LjI1TDcsMTEuMTYsOC43NSw4LjFoMS41OEw3Ljc5LDEyLjE1bDIuNTQsNE03Ljg4LDYuM1YxLjM1TDEyLjY5LDYuM1oiLz48L2c+PC9nPjwvc3ZnPg==");
	}
	
	a[href*=".doc"]:after
	, a[href*=".docx"]:after
	{
		background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNCAxOCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwYjVmYWE7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT53b3JkRGVmYXVsdDwvdGl0bGU+PGcgaWQ9IkxheWVyXzIiIGRhdGEtbmFtZT0iTGF5ZXIgMiI+PGcgaWQ9IkxheWVyXzEtMiIgZGF0YS1uYW1lPSJMYXllciAxIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik04Ljc1LDBoLTdBMS43OCwxLjc4LDAsMCwwLDAsMS44VjE2LjJBMS43OCwxLjc4LDAsMCwwLDEuNzUsMThoMTAuNUExLjc4LDEuNzgsMCwwLDAsMTQsMTYuMlY1LjRMOC43NSwwTTkuOCwxNi4ySDguNThMNywxMC4wOCw1LjQyLDE2LjJINC4yTDIuMjcsOC4xSDMuNTlsMS4yMiw2LjEyTDYuMzksOC4xSDcuNTNMOS4xLDE0LjIyLDEwLjMzLDguMWgxLjMxTDkuOCwxNi4yTTcuODgsNi4zVjEuMzVMMTIuNjksNi4zWiIvPjwvZz48L2c+PC9zdmc+");
	}
</style> <style class="styling-lightpdficon">
	a[href*=".pdf"].lightPDFIcon:after
	{
		background-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTkuMiIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDE5LjIgMjQiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiNmZmY7fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJhIiBkPSJNMTYsMmw3LjIsNy4yVjIzLjZBMi40LDIuNCwwLDAsMSwyMC44LDI2SDYuNEEyLjQsMi40LDAsMCwxLDQsMjMuNlY0LjRBMi40LDIuNCwwLDAsMSw2LjQsMkgxNm00LjgsMjEuNlYxMC40aC02di02SDYuNFYyMy42SDIwLjhtLTguNS05LjIyOGMtLjI4OC0uOTI0LS45MjQtMy44NzYuNzU2LTMuOTI0cy41NzYsMy43NDQuNTc2LDMuNzQ0YTYuMzQsNi4zNCwwLDAsMCwyLjQyNCwzLjA3MmMuNi0uMTgsNC4wMi0uNTc2LDMuNTQsMS4yLS41MTYsMS43NzYtNC4yLjEwOC00LjIuMTA4YTE3LjE0LDE3LjE0LDAsMCwwLTQuMDkyLjc5MkM5Ljk1MiwyMS45LDguMzY4LDIzLDcuNzIsMjEuOTMyYy0uOC0xLjMzMiwyLjU1Ni0zLjA0OCwyLjU1Ni0zLjA0OEExNC41ODgsMTQuNTg4LDAsMCwwLDEyLjMsMTQuMzcybS43OCwxLjAwOGExOC42NzEsMTguNjcxLDAsMCwxLTEuNDQsMy4yMjgsMjcuNjgxLDI3LjY4MSwwLDAsMSwzLjI1Mi0uODc2LDcuMDM0LDcuMDM0LDAsMCwxLTEuODEyLTIuMzUybTMuNzY4LDIuNnMyLjEuNzgsMi4xNDguNDY4Yy4wODQtLjMyNC0xLjYtLjYxMi0yLjE0OC0uNDY4TTEwLjA2LDE5Ljc3MmMtLjkyNC4zNi0xLjgxMiwxLjktMS42LDEuOWEzLjQ3MywzLjQ3MywwLDAsMCwxLjYtMS45bTMuMDI0LTYuNjZjMC0uMDYuNTE2LTIuMDE2LDAtMi4wNzZDMTIuNzI0LDExLDEzLjA3MiwxMy4wNjQsMTMuMDg0LDEzLjExMloiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00IC0yKSIvPjwvc3ZnPg==");
		
		background-size: 0.7778rem;
	}
</style> <!-- END OF Fonts CSS -->
    <!-- Global Head CSS -->
    <style>
	:root
	{
		color-scheme: only light;
	}
</style> <style class="normalize-css">/*modified version of https://github.com/necolas/normalize.css/blob/73b6b0c7e8690ab5005bca9d7e13d3fb319c98ac/normalize.css*//*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{margin:.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace}dfn{font-style:italic}mark{background-color:#ff0;color:#000}sub,sup{position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}template{display:none}[hidden]{display:none}</style>
    <style>
	*:not(summary)[aria-expanded="false"]:not([aria-controls]):not([aria-haspopup]) + *
	{
		display: none;
	}
	
	[aria-pressed="true"] > .showWhenNotExpanded
	, [aria-pressed="false"] > .showWhenExpanded
	{
		display: none;
	}
	
	[aria-expanded="true"]:not([aria-pressed]) > .showWhenNotExpanded
	, [aria-expanded="false"]:not([aria-pressed]) > .showWhenExpanded
	{
		display: none;
	}
	
	*[aria-expanded="true"] > .showWhenNotHoveredOrExpanded
	, *:focus > .showWhenNotHoveredOrExpanded
	, *:hover > .showWhenNotHoveredOrExpanded
	{
		display: none !important;
	}
	
	*:not([aria-expanded="true"]):not(:focus):not(:hover) > .showWhenHoveredOrExpanded
	{
		display: none !important;
	}
	
	html.hasMouseCursor .noMouseOnlyContent
	{
		display: none !important;
	}
	
	html:not(.hasMouseCursor) .mouseOnlyContent
	{
		display: none !important;
	}
	
	*:not(:empty) + .prefixSpaceWhenPreviousSiblingIsNotEmpty:before
	{
		content: " ";
	}
	
	*:not(:empty) + .showWhenPreviousSiblingIsEmpty
	{
		display: none !important;
	}
</style><template id="dialog-polyfill">
      <link href="dialog-polyfill-2.1.0.css" rel="stylesheet" integrity="sha256-JUZIq+dno9b51u/u8BJLFxxz2fERhPXJ+DzhY3qzajQ="

        crossorigin="anonymous">
    </template>
    <style>
	*:not(input[type="search"]):not([role="searchbox"])[aria-haspopup="listbox"]
	{
		display: block;
		
		border: 1px solid #C2D1D9;
		padding: 0.8333rem 3rem 0.8333rem 0.8333rem;
		width: 100%;
		
		border-radius: 3px;
		
		background-color: white;
		background-repeat: no-repeat;
		background-image: url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAxNSI+PHRpdGxlPmNoZXZyb24tZG93bl9pY29uPC90aXRsZT48cGF0aCBpZD0iY2hldnJvbi1yaWdodCIgZD0iTTIuODQuMDksMTIsOS4yNSwyMS4xOC4wOSwyNCwyLjkxbC0xMiwxMkwwLDIuOTFaIiBmaWxsPSIjMDA1ZGFhIi8+PC9zdmc+);
		background-size: 1rem 1rem;
		background-position: right 1rem center;
		
		color: #183152;
		
		text-align: left;
		
		cursor: pointer;
		
		outline-offset: 0px !important;
	}
	
	input:not([type="search"])[aria-haspopup="listbox"][aria-label]:not([aria-label=""]):before
	, *:not([role="searchbox"])[aria-haspopup="listbox"][aria-label]:not([aria-label=""]):before
	{
		content: attr(aria-label);
		
		display: block;
		
		white-space: pre;
		
		text-overflow: ellipsis;
		
		overflow: hidden;
	}
	
	[role="listbox"]
	{
		--scrollbarTrackHeight: 0.5rem;
	}
	
	[role="listbox"]
	{
		position: absolute;
		
		left: -100vw;
		
		border: 1px solid #C2D1D9;
		
		border-radius: 3px;
		
		background-color: white;
		
		opacity: 0;
		
		overflow-x: hidden;
		overflow-y: auto;
		
		overscroll-behavior: none;
		
		box-shadow: 0rem 0.75rem 1rem 0.5rem rgba(0, 0, 0, 0.06);
		
		z-index: 9000;
		
		transform: translateY(-1px);
	}
	
	[role="option"].target  /* //??? unsure if this class is needed or could be replaced with an aria-* */
	{
		background: #D8D8D8;
	}
	
	[role="option"] > label
	{
		display: flex;
		
		padding: 0.5rem 0.8333rem;
	}
	
	[role="option"] > label > input[type="radio"]
	, [role="option"] > label > input[type="checkbox"]
	{
		flex-shrink: 0;
	}
</style><template id="virtualcursor">
      <link href="virtualCursor-2.1.0.css" rel="stylesheet" integrity="sha256-+3YO23cQwnuU7kryKgGFwE8upxnm6vwxBSgBEPr+YSQ="

        crossorigin="anonymous">
      <style class="virtual-cursor-shame">
		article[data-infocard-name] .CTALinkContainer[style*="--outsideFocusOutlineColor:"]:not([style*="--outsideFocusOutlineColor:;"]):not([style*="--outsideFocusOutlineColor: ;"])
		{
			--focusOutlineColor: var(--outsideFocusOutlineColor) !important;
		}
		
		article[data-infocard-name].headerLinkInfoCardTheme .CTALinkContainer
		{
			--outsideFocusOutlineColor: currentColor !important;  /* focus-color should match border-color */
		}
		
		article[data-infocard-name].headerLinkInfoCardTheme:focus-within *
		{
			outline: none !important;
		}
		
		article[data-infocard-name].headerLinkInfoCardTheme:focus-within
		{
			outline: 2px solid currentColor !important;
			outline-offset: 0.3888rem;
		}
		
		article[data-infocard-name].storyCardNarrowCTAPromoInfoCardTheme .CTALinkContainer
		, article[data-infocard-name].fullImageStoryCardFlexCTAPromoInfoCardTheme .CTALinkContainer
		{
			--outsideFocusOutlineColor: currentColor !important;  /* focus-color should match border-color */
		}
	</style> </template>
    <style class="tlfixes-240">
	@supports (-ms-ime-align: auto) {
		@media (min-resolution: 192dpi) {
			body
			{
				font-size: 1.5rem;
			}
		}
	}
	
	html
	{
		-ms-scroll-chaining: none;
		overscroll-behavior: none;
	}
	
	html
	, form
	, details > *
	, summary
	, label
	{
		box-sizing: border-box;
	}
	
	*
	, *:before
	, *:after
	{
		box-sizing: inherit;
		
		scrollbar-width: inherit;
	}
	
	body
	{
		padding: 0px;
		margin: 0px;
		
		min-width: 320px !important; /* WCAG 2.1 #1.4.10 */
		min-height: 256px !important; /* WCAG 2.1 #1.4.10 */
		
		scrollbar-gutter: stable both-edges;
	}
	
	*:is(h1, h2, h3, h4, h5, h6) *:is(h1, h2, h3, h4, h5, h6) /* do not allow nesting of <h#> inside <h#> */
	{
		display: none !important;
	}
	
	blockquote[cite]:not([cite^="https://"]):not([cite^="http://"]):not([cite^="/"])
	, blockquote[cite^="https://"]:not([cite*="."])
	, blockquote[cite^="http://"]:not([cite*="."])
	, q[cite]:not([cite^="https://"]):not([cite^="http://"]):not([cite^="/"])
	, q[cite^="https://"]:not([cite*="."])
	, q[cite^="http://"]:not([cite*="."])
	{
		display: none;
	}
	
	a:not([href])
	, a[href]:not([href^="/"]):not([href*="a"]):not([href*="b"]):not([href*="c"]):not([href*="d"]):not([href*="e"]):not([href*="f"]):not([href*="g"]):not([href*="h"]):not([href*="i"]):not([href*="j"]):not([href*="k"]):not([href*="l"]):not([href*="m"]):not([href*="n"]):not([href*="o"]):not([href*="p"]):not([href*="q"]):not([href*="r"]):not([href*="s"]):not([href*="t"]):not([href*="u"]):not([href*="v"]):not([href*="w"]):not([href*="x"]):not([href*="y"]):not([href*="z"]) /* do not display a link element with an HREF that doesn't have any letters */
	{
		display: none;
	}
	
	a[href*="##"] /* do not display a link element with an HREF containing 2 or more hashes in a row - only at most 1 hash is allowed */  
	{
		display: none !important;
	}
	
	img
	{
		width: 100%;
		height: auto;
		
		max-width: 100%;
		
		min-height: 1px; /* DOC: Teng + Emily think this solves a flexbox bug in IE11 */
		
		vertical-align: middle;  /* removes the space at the bottom of an image because they are display:inline by default */
		
		color: inherit;
		
		object-fit: contain;
		
		-ms-user-select: none;
		-moz-user-select: none;
		-webkit-user-select: none;
		user-select: none;
	}
	
	img[src=""] /* do not display an image that can never render */
	, img:not([src]):not([data-lazy-src]) /* do not display an image or lazy-loaded image that can never render */
	, img:not([alt]):not([role="presentation"]):not([role="none"]) /* do not display an image if it is neither inline-image or purely-decorative */
	, img[alt][role="presentation"] /* do not display an image if it has both inline-image and purely-decorative attributes */
	, img[alt][role="none"] /* do not display an image if it has both inline-image and purely-decorative attributes */
	, img[alt^="image" i] /* do not display an inline-image with ALT text that begins with 'image' because the IMG tag itself already declares it's an image */
	, img[alt="null" i] /* do not display an inline-image with ALT text set to 'null' because that implies a JS or data error */
	, img[alt^="undefined" i] /* do not display an inline-image with ALT text set to 'undefined' because that implies a JS or data error */
	, img[alt]:not([alt=""]):not([alt*="a"]):not([alt*="b"]):not([alt*="c"]):not([alt*="d"]):not([alt*="e"]):not([alt*="f"]):not([alt*="g"]):not([alt*="h"]):not([alt*="i"]):not([alt*="j"]):not([alt*="k"]):not([alt*="l"]):not([alt*="m"]):not([alt*="n"]):not([alt*="o"]):not([alt*="p"]):not([alt*="q"]):not([alt*="r"]):not([alt*="s"]):not([alt*="t"]):not([alt*="u"]):not([alt*="v"]):not([alt*="w"]):not([alt*="x"]):not([alt*="y"]):not([alt*="z"]) /* do not display an inline-image because any not-empty ALT text without letters is useless */
	{
		display: none;
	}
	
	img[src*=".svg"]:not([width])
	, img[src*="data:image/svg"]:not([width])
	{
		width: 100%;
	}
	
	img[loading]:not([loading="eager"]):not([loading="lazy"])
	,  img[decoding]:not([decoding="auto"]):not([decoding="async"]):not([decoding="sync"])
	{
		display: none !important;
	}
	
	time
	{
		display: contents;
	}
	
	time:not([datetime])
	, time[datetime=""]
	{
		display: none !important;
	}
	
	video
	{
		width: 100%;
	}
	
	a *
	, button *
	, summary *
	, [role="button"] *
	{
		pointer-events: none;
	}
	
	a
	, button
	, [role="button"]
	, input:not([type="range"])
	, label
	, select
	, summary
	, textarea
	{
		touch-action: manipulation;
	}
	
	[role="button"]
	{
		overflow: hidden;
	}
	
	input:not([type="radio"]):not([type="checkbox"]):not(:disabled):not([readonly])
	{
		background-color: white;
	}
	
	input[pattern]:not([title]) /* all patterns must have a title attribute describing the pattern requirements */
	, input[pattern][title=""] /* all patterns must have a title attribute describing the pattern requirements */
	, textarea[pattern]:not([title]) /* all patterns must have a title attribute describing the pattern requirements */
	, textarea[pattern][title=""] /* all patterns must have a title attribute describing the pattern requirements */
	{
		display: none !important;
	}
	
	/* fixes an issue where Chrome sets opacity to 0.7 for disabled <select> */
	select:disabled
	{
		opacity: 1;
	}
	
	select[multiple]:not([size]) /* multiselects must have a [size] */
	, select[multiple][size=""] /* multiselects must not have an empty [size] */
	, select[multiple][size="0"] /* multiselects must have a [size] of 0 */
	, select[multiple][size^="-"] /* multiselects must have a negative [size] */
	, select[multiple][size]:not([size*="1"]):not([size*="2"]):not([size*="3"]):not([size*="4"]):not([size*="5"]):not([size*="6"]):not([size*="7"]):not([size*="8"]):not([size*="9"]) /* multiselects must have a [size] with a number */
	, select[multiple][size][size*="a"] /* letters are not allowed inside the size attribute */
	, select[multiple][size][size*="b"]
	, select[multiple][size][size*="c"]
	, select[multiple][size][size*="d"]
	, select[multiple][size][size*="e"]
	, select[multiple][size][size*="f"]
	, select[multiple][size][size*="g"]
	, select[multiple][size][size*="h"]
	, select[multiple][size][size*="i"]
	, select[multiple][size][size*="j"]
	, select[multiple][size][size*="k"]
	, select[multiple][size][size*="l"]
	, select[multiple][size][size*="m"]
	, select[multiple][size][size*="n"]
	, select[multiple][size][size*="o"]
	, select[multiple][size][size*="p"]
	, select[multiple][size][size*="q"]
	, select[multiple][size][size*="r"]
	, select[multiple][size][size*="s"]
	, select[multiple][size][size*="t"]
	, select[multiple][size][size*="u"]
	, select[multiple][size][size*="v"]
	, select[multiple][size][size*="w"]
	, select[multiple][size][size*="x"]
	, select[multiple][size][size*="y"]
	, select[multiple][size][size*="z"]
	{
		display: none !important;
	}
	
	textarea
	{
		vertical-align: bottom;
	}
	
	button
	{
		border: none;
		
		color: inherit;
	}
	
	button:not([type="button"]):not([type="submit"]):not([type="reset"])  /* buttons must have a type*/
	{
		display: none !important;
	}
	
	button[role="button"]  /* button role on a button is redundant */ 
	{
		display: none !important;
	}
	
	[aria-expanded]:not(button):not([role="button"]) /* all aria-expanded must be buttons because that is the only interactable element that makes sense to have an aria-expanded attribute */
	{
		display: none !important;
	}
	
	/* //??? add a note about how searchboxes can have aria-haspopup, but not aria-expanded; make sure to reference a spec doc */
	[aria-haspopup]:not(input[type="search"]):not([role="searchbox"]):not([aria-expanded]) /* aria-haspopup must have aria-expanded so the screenreader knows if the popup is closed or open */
	, [aria-haspopup]:not(input[type="search"]):not([role="searchbox"])[aria-expanded=""]  /* aria-haspopup must have aria-expanded so the screenreader knows if the popup is closed or open */
	, [aria-haspopup]:not([aria-controls])  /* aria-haspopup must have aria-controls so the screenreader knows what the popup is */
	, [aria-haspopup][aria-controls=""]  /* aria-haspopup must have aria-controls so the screenreader knows what the popup is */
	{
		display: none !important;
	}
	
	[type="checkbox"]:not([value])  /* checkboxes must have a value */
	, [type="checkbox"][value=""]  /* checkboxes must have a value */
	{
		display: none;
	}
	
	[type="radio"]:not([name]) /* radio buttons must have a name */
	, [type="radio"][name=""]  /* radio buttons must have a name */
	, [type="radio"]:not([value]) /* radio buttons must have a value */
	, [type="radio"][value=""] /* radio buttons must have a value */
	{
		display: none;
	}
	
	input[type="search"][aria-expanded]  /* searchboxes must not have aria-expanded */
	, [role="searchbox"][aria-expanded]  /* searchboxes must not have aria-expanded */
	{
		display: none !important;
	}
	
	[type="password"]:disabled  /* password inputs are not allowed to be disabled */
	, [type="password"][readonly]  /* password inputs are not allowed to be readonly */
	{
		display: none !important;
	}
	
	[type="tel"]:not([maxlength])
	, [type="tel"][maxlength]:not([maxlength="14"]):not([maxlength="16"])
	, [type="tel"][maxlength="14"]:not([minlength="14"])
	, [type="tel"][maxlength="16"]:not([minlength="13"])
	, [type="tel"]:not([minlength])
	, [type="tel"][minlength]:not([minlength="14"]):not([minlength="13"])
	, [type="tel"][minlength="14"]:not([maxlength="14"])
	, [type="tel"][minlength="13"]:not([maxlength="16"])
	, [type="tel"]:not([pattern="^[\\(]?[2-9]{1}\\d{2}[\\)][ ]\\d{3}[\\-]\\d{4}$"]):not([pattern="^[\\(]\\d{3}[\\)][ ]\\d{3}[\\-]\\d{4}$"]):not([pattern="^[\\(]\\d{3}[\\)][ ]\\d{3}[\\-](\\d{3}|\\d{4}|\\d{5}|\\d{6})$"])
	{
		display: none !important;
	}
	
	[type="email"]:not([maxlength])
	, [type="email"][maxlength]:not([maxlength="254"])
	{
		display: none !important;
	}
	
	[type="email"]:not([pattern="^[a-zA-Z0-9._%+\\-]{1,64}@([a-zA-Z0-9\\-]{1,63}\\.)+[a-zA-Z]{2,63}$"])
	{
		display: none !important;
	}
	
	[type="datetime-local"]:not([max])
	, [type="datetime-local"][max]:not([max*="0"]):not([max*="1"]):not([max*="2"]):not([max*="3"]):not([max*="4"]):not([max*="5"]):not([max*="6"]):not([max*="7"]):not([max*="8"]):not([max*="9"])  /* do not display a datetime-local input element with a MAX that doesn't have any numbers */
	{
		display: none;
	}
	
	[type="date"]:not([max])
	, [type="date"][max]:not([max*="0"]):not([max*="1"]):not([max*="2"]):not([max*="3"]):not([max*="4"]):not([max*="5"]):not([max*="6"]):not([max*="7"]):not([max*="8"]):not([max*="9"])  /* do not display a date input element with a MAX that doesn't have any numbers */
	{
		display: none;
	}
	
	*:disabled[autocomplete]:not([autocomplete="Off"])  /* autocomplete must be 'Off' when the element is disabled because browsers will still try to autofill a value */
	{
		display: none;
	}
	
	/*  //??? cannot use the readonly version because there is no JS to autosave the autocomplete value for readonly - only for disabled
	
	*:disabled[autocomplete]:not([autocomplete="Off"])  /* autocomplete must be 'Off' when the element is disabled because browsers will still try to autofill a value */
	, [readonly][autocomplete]:not([autocomplete="Off"])  /* autocomplete must be 'Off' when the element is readonly because browsers may still try to autofill a value */
	{
		display: none;
	}
	*/
	
	/* the <legend> element has layout that is controlled directly by the renderer and not CSS; specifically, it isn't contained by its parent, so we need display:contents to delete <legend>'s bounding box so its text can flow inline */
	legend
	{
		display: contents;
	}
	
	output
	{
		display: block;
	}
	
	iframe
	{
		display: block;
	}
	
	iframe:not([title]) /* do not display an iframe without a title */
	, iframe[title=""] /* do not display an iframe with an empty title */
	, iframe[title]:not([title*="a"]):not([title*="b"]):not([title*="c"]):not([title*="d"]):not([title*="e"]):not([title*="f"]):not([title*="g"]):not([title*="h"]):not([title*="i"]):not([title*="j"]):not([title*="k"]):not([title*="l"]):not([title*="m"]):not([title*="n"]):not([title*="o"]):not([title*="p"]):not([title*="q"]):not([title*="r"]):not([title*="s"]):not([title*="t"]):not([title*="u"]):not([title*="v"]):not([title*="w"]):not([title*="x"]):not([title*="y"]):not([title*="z"]) /* do not display an iframe with a title that doesn't have any letters */
	{
		display: none !important;
	}
	
	iframe[width=""]
	, iframe[width*=" "]
	, iframe[width*="a" i]
	, iframe[width*="b" i]
	, iframe[width*="c" i]
	, iframe[width*="d" i]
	, iframe[width*="e" i]
	, iframe[width*="f" i]
	, iframe[width*="g" i]
	, iframe[width*="h" i]
	, iframe[width*="i" i]
	, iframe[width*="j" i]
	, iframe[width*="k" i]
	, iframe[width*="l" i]
	, iframe[width*="m" i]
	, iframe[width*="n" i]
	, iframe[width*="o" i]
	, iframe[width*="p" i]
	, iframe[width*="q" i]
	, iframe[width*="r" i]
	, iframe[width*="s" i]
	, iframe[width*="t" i]
	, iframe[width*="u" i]
	, iframe[width*="v" i]
	, iframe[width*="w" i]
	, iframe[width*="x" i]
	, iframe[width*="y" i]
	, iframe[width*="z" i]
	, iframe[width*="v" i]
	, iframe[width^="0"]
	, iframe[width]:not([width*="1"]):not([width*="2"]):not([width*="3"]):not([width*="4"]):not([width*="5"]):not([width*="6"]):not([width*="7"]):not([width*="8"]):not([width*="9"])
	, iframe[width*="%"]
	{
		display: none !important;
	}
	
	iframe[height=""]
	, iframe[height*=" "]
	, iframe[height*="a" i]
	, iframe[height*="b" i]
	, iframe[height*="c" i]
	, iframe[height*="d" i]
	, iframe[height*="e" i]
	, iframe[height*="f" i]
	, iframe[height*="g" i]
	, iframe[height*="h" i]
	, iframe[height*="i" i]
	, iframe[height*="j" i]
	, iframe[height*="k" i]
	, iframe[height*="l" i]
	, iframe[height*="m" i]
	, iframe[height*="n" i]
	, iframe[height*="o" i]
	, iframe[height*="p" i]
	, iframe[height*="q" i]
	, iframe[height*="r" i]
	, iframe[height*="s" i]
	, iframe[height*="t" i]
	, iframe[height*="u" i]
	, iframe[height*="v" i]
	, iframe[height*="w" i]
	, iframe[height*="x" i]
	, iframe[height*="y" i]
	, iframe[height*="z" i]
	, iframe[height*="v" i]
	, iframe[height^="0"]
	, iframe[height]:not([height*="1"]):not([height*="2"]):not([height*="3"]):not([height*="4"]):not([height*="5"]):not([height*="6"]):not([height*="7"]):not([height*="8"]):not([height*="9"])
	, iframe[height*="%"]
	{
		display: none !important;
	}
	
	dialog
	{
		padding: 1rem;
		
		max-width: calc(100% - 44px);
		max-height: calc(100% - 44px);
		
		overflow-y: auto;
		
		-webkit-overflow-scrolling: touch;
	}
	
	*:not([role="presentation"]):not(td):not(th):not(input):not(textarea):not(progress):not(iframe):not(img):not(video):not(br):not(hr):not(source):empty
	{
		display: none !important;
	}
	
	div[aria-label] /* divs do not support aria-label */
	, div[aria-labelledby] /* divs do not support aria-labelledby */
	, div[aria-describedby] /* divs do not support aria-describedby */
	{
		display: none !important;
	}
	
	[hidden]
	{
		display: none !important;
	}
	
	*:disabled
	, [readonly]
	{
		cursor: not-allowed !important;
	}
</style> <style class="tlreset-231">
	html
	{
		-webkit-text-decoration-skip: ink;
		text-decoration-skip: ink;
		
		scroll-behavior: smooth;
	}
	
	@media screen and (prefers-reduced-motion: reduce) {
		html
		{
			scroll-behavior: auto;
		}
	}
	
	*::selection
	{
		background-color: #3297FD;
		color: white;
	}
	
	/* sync in-page scrollbar colors and width for all browsers (best attempt because APIs differ) */
	body
	{
		--scrollbarThumbColor: #005DAA;
		--scrollbarTrackColor: #F0F0F0;
		--scrollbarTrackHeight: 0.5rem;
	}
	
	body *
	{
		scrollbar-color: var(--scrollbarThumbColor) var(--scrollbarTrackColor);
	}
	
	body *::-webkit-scrollbar
	{
		height: var(--scrollbarTrackHeight);
		
		background-color: var(--scrollbarTrackColor);
	}
	
	body *::-webkit-scrollbar-thumb
	{
		background-color: var(--scrollbarThumbColor);
	}
	
	style
	, script
	, template
	{
		/* mostly copied from .hidden */
		
		display: none !important;
		
		position: absolute;
		
		left: -555.55rem;
		
		/* the datepicker UI requires the date input to be at least 1x1px big */
		outline: 0; /* this removes a red outline for mobile browsers*/
		
		margin: 0px;
		margin-top: -0.0555rem;
		margin-left: -0.0555rem;
		border: 0px;
		padding: 0px;
		padding-top: 0.0555rem;
		padding-left: 0.0555rem;
		width: 0px;
		height: 0px;
		
		border-color: transparent;
		background-color: transparent;
		color: transparent;
		
		overflow: hidden;
	}
	
	/* hide all usages of .jpeg filetype because the correct extension is .jpg */
	img[src*=".jpeg" i]
	, img[srcset*=".jpeg" i]
	, [style*=".jpeg" i]
	{
		display: none !important;
	}
	
	/* show a styled placeholder that is the same size as the non-presentational image while it is still loading or if it has an error - this does require JS to detect those image states and add the [data-is-not-loaded="true"]  */
	img[alt]:not([alt=""])[data-is-not-loaded="true"]
	{
		--borderWidthInPx: 2;
		
        display: block;
        
        border: calc(var(--borderWidthInPx) * 1px) dashed #C2D1D9;
		
        border-radius: 0.5rem;
        
        text-align: center;
        
        overflow: hidden;
    }
	
	img[alt]:not([alt=""])[data-is-not-loaded="true"][style*="--imageDefaultWidthInPx:"][style*="--imageDefaultHeightInPx:"]
	{
		aspect-ratio: var(--imageDefaultWidthInPx) / var(--imageDefaultHeightInPx);
    }
	
	/* sync text and caret colors inputs for all browsers (including those without HTML5 inputs) */
	input
	, textarea
	{
		caret-color: currentColor;
	}
	
	/* option elements should not have a preset background color */
	option
	{
		background-color: transparent;
	}
	
	/* remove background highlights when tapping in Chrome Android */
	a
	, label
	, input
	, textarea
	, select
	, option
	, button
	, summary
	{
		-webkit-tap-highlight-color: rgba(255, 255, 255, 0);
	}
	
	/* remove background highlights when tapping in Firefox for Android */
	@supports (-moz-appearance: none) {
		input:active
		, textarea:active
		, select:active
		, option:active
		{
			background-color: white;
		}	
		
		label:active
		{
			background-color: inherit;
		}
	}
	
	/* prevent horizontal resizing in all browsers because it is likely to cause horizontal scrollbars */
	textarea
	{
		resize: vertical;
	}
	
	/* do not display inputs that require a negative number of inputted characters */
	input[maxlength^="-"]
	, input[minlength^="-"]
	{
		display: none !important;
	}
	
	/* set input and label width to max-width to 'enforce' single column forms */
	input:not([type="radio"]):not([type="checkbox"])
	, textarea
	{
		width: 100%;
	}
	
	/* remove mobile control styles in non-Firefox browsers */
	@supports not (-moz-appearance: textfield)
	{
		input:not([type="radio"]):not([type="checkbox"])
		, textarea
		, select
		, button
		{
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
		}
	}
	
	/* remove mobile control styles in Firefox */
	@supports (-moz-appearance: textfield) {
		/* remove Firefox number-input control styles */
		input[type="number"]
		{
			-webkit-appearance: textfield;
			-moz-appearance: textfield;
			appearance: textfield;
		}
		
		input:not([type="radio"]):not([type="checkbox"]):not([type="number"])
		, textarea
		, select
		, button
		{
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
		}
	}
	
	/* undo default rounded <button> in Firefox for Android */
	button
	, button:active
	{
		border-radius: 0px;
	}
	
	input[type="date"]
	{
		/* 6.5rem for the 10 characters of 'yyyy-mm-dd' and 2.75rem to reserve space for a calendar icon */
		width: calc(6.5rem + 2.75rem);
		min-width: calc(6.5rem + 2.75rem); 
	}
	
	/* set min-width on time inputs to fit Firefox's wider timepicker text (12:00 a.m. compared to 12:00am on other browsers) */
	input[type="time"]
	{
		/* 6.5rem for the 10 characters of '12:00 a.m.' and 2.75rem to reserve space for a clock icon */
		width: calc(6.5rem + 2.75rem);
		min-width: calc(6.5rem + 2.75rem); 
	}
	
	/* remove Android Chrome's text-indent on date and time inputs */
	input[type="time"]::-webkit-date-and-time-value
	, input[type="date"]::-webkit-date-and-time-value
	, input[type="month"]::-webkit-date-and-time-value
	, input[type="datetime-local"]::-webkit-date-and-time-value
	{
		margin-left: 0px;
	}
	
	/* remove Android Chrome's default grey background color for dropdowns and some HTML5 inputs */
	input[type="month"]:not(:disabled):not([readonly])
	, input[type="date"]:not(:disabled):not([readonly])
	, input[type="time"]:not(:disabled):not([readonly])
	, input[type="datetime-local"]:not(:disabled):not([readonly])
	, select:not(:disabled):not([readonly])
	{
		background-color: white;
	}
	
	[type="text"][readonly]
	, [type="text"]:disabled
	, [type="search"][readonly]
	, [type="search"]:disabled
	, [type="tel"][readonly]
	, [type="tel"]:disabled
	, [type="email"][readonly]
	, [type="email"]:disabled
	, [type="password"][readonly]
	, [type="password"]:disabled
	, input[type="month"][readonly]
	, input[type="month"]:disabled
	, input[type="date"][readonly]
	, input[type="date"]:disabled
	, input[type="time"][readonly]
	, input[type="time"]:disabled
	, input[type="datetime-local"][readonly]
	, input[type="datetime-local"]:disabled
	, textarea[readonly]
	, textarea:disabled
	, select[readonly]
	, select:disabled
	, [aria-haspopup="listbox"][readonly]
	, [aria-haspopup="listbox"]:disabled
	{
		border-color: currentColor !important;
		
		background-color: #EDEDED !important;
		color: #666666 !important;
		
		cursor: not-allowed;
	}
	
	/* remove Chrome HTML5 ticker buttons */
	[type="number"]::-webkit-inner-spin-button
	, [type="number"]::-webkit-outer-spin-button
	, [type="time"]::-webkit-inner-spin-button
	, [type="time"]::-webkit-outer-spin-button
	, [type="date"]::-webkit-inner-spin-button
	, [type="date"]::-webkit-outer-spin-button
	, [type="month"]::-webkit-inner-spin-button
	, [type="month"]::-webkit-outer-spin-button
	, [type="datetime-local"]::-webkit-inner-spin-button
	, [type="datetime-local"]::-webkit-outer-spin-button
	{
		-webkit-appearance: none;
	}
	
	/* remove Chrome HTML5 'clear input' buttons */
	[type="number"]::-webkit-clear-button
	{
		display: none;
	}
	
	/* restore search-input styling removed by Normalize.css */
	input[type="search"]::-webkit-search-cancel-button
	, [type="time"]::-webkit-clear-button
	, [type="date"]::-webkit-clear-button
	, [type="month"]::-webkit-clear-button
	, [type="datetime-local"]::-webkit-clear-button
	{
		align-self: center;  /* make the clear button vertically-centered in iOS instead of top-aligned */
		
		margin: 0px;
		margin-left: 0.25rem;
		
		width: 1.1111rem;
		height: 1.1111rem;
		
		cursor: pointer;
		
		background-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5he2ZpbGw6IzAwNWRhYTt9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImEiIGQ9Ik0yOSw3LjQxNywyNi41ODMsNSwxNywxNC41ODMsNy40MTcsNSw1LDcuNDE3LDE0LjU4MywxNyw1LDI2LjU4Myw3LjQxNywyOSwxNywxOS40MTcsMjYuNTgzLDI5LDI5LDI2LjU4MywxOS40MTcsMTdaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNSAtNSkiLz48L3N2Zz4=");
		background-size: contain;
		
		-webkit-appearance: none;
	}
	
	/* when the input is not focused, do not reserve space for the cancel button because it only appears when the input is focused */
	input[type="search"]:not(:focus)::-webkit-search-cancel-button
	{
		display: none; 
	}
	
	/* when the input does not have any user input, do not reserve space for the cancel button because it only appears when there is user input */
	input[type="search"]:placeholder-shown::-webkit-search-cancel-button
	{
		display: none; 
	}
	
	/* //??? update this to use the new icon from webkit */
	input:not([type="search"])::-ms-clear
	{
		display: none;
	}
	
	/* replace default dropdown icon for date and time inputs */
	input[type="date"]
	, input[type="time"]
	, input[type="datetime-local"]
	{
		position: relative;
	}
	
	input[type="date"]::-webkit-calendar-picker-indicator
	, input[type="time"]::-webkit-calendar-picker-indicator
	, input[type="datetime-local"]::-webkit-calendar-picker-indicator
	{
		position: absolute;
		
		right: 0.655rem;
		top: 0.85rem;
		
		display: inline-block;
		
		width: 1.1111rem;
		height: 1.1111rem;
		
		color: rgba(0, 0, 0, 0);
		
		background-image: none;
		background-repeat: no-repeat;
		background-size: 1.1111rem 1.1111rem;
		background-color: transparent;
		
		cursor: pointer;
		
		outline: none;
	}
	
	input[type="date"]::-webkit-calendar-picker-indicator:focus
	, input[type="time"]::-webkit-calendar-picker-indicator:focus
	, input[type="datetime-local"]::-webkit-calendar-picker-indicator:focus
	{
		outline: 2px solid var(--focusOutlineColor, #0081C6);
		outline-offset: 1px;
	}
	
	/* display color input as a square */
	input[type="color"]
	{
		display: inline-block;
		
		aspect-ratio: 1 / 1;
	}
	
	/* remove spacing around color swatch */
	input[type="color"]
	{
		border: none;
		padding: 0px;
	}
	
	/* remove spacing around color swatch in Chrome */
	input[type="color"]::-webkit-color-swatch-wrapper
	, input[type="color"]::-webkit-color-swatch
	{
		border: none;
		padding: 0px;
	}
	
	/* remove spacing around color swatch in Firefox */
	input[type="color"]::-moz-color-swatch
	{
		border: none;
	}
	
	/* make the color swatch square in iOS 15.6 */
	input[type="color"]
	{
		border-radius: 0px;
	}
	
	/* make inline text next to color-input vertically centered */
	input[type="color"]
	{
		vertical-align: top;
	}
	
	/* remove IE control styles */
	select::-ms-expand
	{
		display: none;
	}
	
	/* remove Firefox HTML5 validation styles */
	:-moz-ui-invalid
	{
		box-shadow: none;
	}
	
	/* add 'interactable'/finger cursor to controls */
	input[type="submit"]
	, input[type="radio"]
	, input[type="checkbox"]
	, input[type="color"]
	, select
	, label
	, button
	, summary
	, [role="button"]
	, [tabindex]:not([tabindex="-1"]):not([role="tabpanel"]):not(form):not(dialog):not(table)
	{
		cursor: pointer;
	}
	
	/* add text cursor to controls */
	input[type="date"]
	, input[type="time"]
	, input[type="datetime-local"]
	{
		cursor: text;
	}
	
	/* hide default <summary> dropdown arrow in non-webkit browsers */
	summary
	{
		display: block;
	}
	
	/* hide default <summary> dropdown arrow on iOS Safari */
	summary::-webkit-details-marker
	{
		display: none;
	}
	
	/* hide default <summary> dropdown arrow in Chrome */
	summary::marker
	{
		display: none;
	}
	
	/* remove Chrome's down-arrow for text inputs using a <list> */
	input[list]::-webkit-calendar-picker-indicator
	{
		display: none !important;
	}
	
	/* remove Safari's down-arrow for text inputs using a <list> */
	input[list]::-webkit-list-button
	{
		/* display:none and user-select:none have no effect on this element due to other overriding rules - therefore no-size strategy is best to visually hide and prevent clicking */
		width: 0px;
		height: 0px;
	}
	
	/* standardize placeholder colors for Chrome */
	input::-webkit-input-placeholder
	{
		color: #76757A;
	}
	
	/* standardize placeholder colors for Firefox */
	input::placeholder
	{
		color: #76757A;
		
		opacity: 1;
	}
	
	/* remove iframe border */
	iframe
	{
		border: none;
	}
	
	dialog
	{
		--scrollbarThumbColor: #005DAA;
		--scrollbarTrackColor: #F0F0F0;
		--scrollbarTrackThickness: 10px;
	}
	
	dialog
	{
		margin-top: 0px;  /* Chrome adds default top and bottom margins that affect CSS-Transform rules because they do not include margins */
		margin-bottom: 0px;  /* Chrome adds default top and bottom margins that affect CSS-Transform rules because they do not include margins */
		
		border: none;
		
		border-radius: 3px;
		
		overscroll-behavior: contain;
		
		scrollbar-width: thin;
		scrollbar-color: var(--scrollbarThumbColor) var(--scrollbarTrackColor);
	}
	
	dialog::-webkit-scrollbar
	{
		width: var(--scrollbarTrackThickness);
		height: var(--scrollbarTrackThickness);
		
		background-color: var(--scrollbarTrackColor);
	}
	
	dialog::-webkit-scrollbar-thumb
	{
		background-color: var(--scrollbarThumbColor);
	}
	
	dialog::backdrop
	{
		display: block !important;
		
		background-color: black;
		
		opacity: 0.8;
	}
	
	.no-dialog dialog[open] + .backdrop
	{
		display: block !important;
		
		background-color: black;
		
		opacity: 0.8;
	}
</style> <style class="tlreset-shame">
	[id]:not([id=""])
	{
		scroll-margin: 2rem;
	}
	
	html.hasMouseCursor a[href^="tel:"]
	, html.hasMouseCursor a[href^="sms:"]
	{
		display: contents;
		
		color: inherit !important;
		
		text-decoration: inherit;
		
		pointer-events: none;
	}
	
	input[type="date"]::-webkit-date-and-time-value
	, input[type="time"]::-webkit-date-and-time-value
	, input[type="datetime-local"]::-webkit-date-and-time-value
	{
		text-align: left;
	}
	
	q:before
	, q:after
	{
		content: "";
	}
	
	blockquote
	{
		margin: 0px;
	}
</style> <style class="tlsec">
	input[type="file"]
	, input[type="password"]
	{
		/* mostly copied from .hidden */
		
		position: absolute !important;
		
		left: -555.55rem !important;
		
		display: none !important;
		
		margin: 0px !important;
		margin-top: -0.0555rem !important;
		margin-left: -0.0555rem !important;
		border: 0px !important;
		padding: 0px !important;
		padding-top: 0.0555rem !important;
		padding-left: 0.0555rem !important;
		width: 0px !important;
		height: 0px !important;
		
		border-color: transparent !important;
		
		background-color: transparent !important;
		color: transparent !important;
		
		overflow: hidden !important;
		
		outline: none !important;
		
		pointer-events: none !important;
		
		-ms-user-select: none;
		-moz-user-select: none;
		-webkit-user-select: none;
		user-select: none;
	}
</style> <style class="tlcompat">
	/* hide elements that reference .aspx or .ashx in HREF or SRC*/
	*:not(script):not(link)[href*=".aspx"]:not([href*="simplesurvey.com"]):not([href*="portmoody.ca"])
	, *:not(script):not(link)[href*=".ashx"]
	, *:not(script):not(link)[src*=".aspx"]:not([src*="simplesurvey.com"]):not([href*="portmoody.ca"])
	, *:not(script):not(link)[src*=".ashx"]
	{
		display: none !important;
	}
	
	/* hide elements that start with "[" in their TITLE or ALT] */
	*[title^="\["]
	, *[alt^="\["]
	{
		display: none !important;
	}
	
	/* hide links to pages that have not been published */
	a[href^="/404/?item="]
	{
		display: none !important;
	}
	
	iframe[src*=".youtube"]
	{
		aspect-ratio: 16 / 9;
		
		width: 100%;
		height: auto;
	}
	
	iframe[src*=".youtube-nocookie."]:not([title])
	, iframe[src*=".youtube-nocookie."][title=""]
	, iframe[src*=".youtube-nocookie."]:not([sandbox="allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts"])
	, iframe[src*=".youtube-nocookie."]:not([allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"])
	, iframe[src*=".youtube-nocookie."]:not([allowfullscreen])
	{
		display: none !important;
	}
	
	iframe[src*="app.everviz.com"]:not([sandbox="allow-downloads allow-forms allow-modals allow-scripts"])
	{
		display: none !important;
	}
	
	iframe[src*="redcircle.com/embedded-show-webplayer/"]:not([sandbox="allow-downloads allow-scripts"])
	{
		display: none !important;
	}
</style> <style class="tllayout-500">
	table
	{
		border-collapse: collapse;
	}
	
	/* HELPERS */
	
	.hidden
	{
		/* this rule is intentionally avoiding using '!important' to fit CSS best practices */
		
		/* 
			the standard method is 'display: none' but that is not used for several reasons:
			- other very high specificity rules may use 'display' for layout reasons
			- [at least] Android Chrome date inputs cannot activate the system's datepicker UI by clicking its label if the input is 'display: none'
		*/
		
		/* additional gotchas:
		   - [at least] iOS 9.1 Safari date inputs cannot activate the system's datepicker UI by clicking its label if the input is 'visibility: hidden'
		*/
		
		display: inline-block;
		
		position: absolute;
		
		left: -555.55rem;
		
		/* the datepicker UI requires the date input to be at least 1x1px big */
		outline: 0; /* this removes a red outline for mobile browsers*/
		
		margin: 0px;
		margin-top: -0.0555rem;
		margin-left: -0.0555rem;
		border: 0px;
		padding: 0px;
		padding-top: 0.0555rem;
		padding-left: 0.0555rem;
		width: 0px;
		height: 0px;
		
		border-color: transparent;
		background-color: transparent;
		color: transparent;
		
		overflow: hidden;
	}
	
	.noOverflow
	{
		overflow: hidden;
	}
	
	.noVerticalScroll
	{
		overflow-y: hidden;
	}
	
	/* .clearFix - modified from: http://nicolasgallagher.com/micro-clearfix-hack/ */
	.clearFix:not(:empty):before, .clearFix:not(:empty):after
	{
		content: " ";
		
		display: table;
	}
	
	.clearFix:not(:empty):after
	{
		clear: both;
	}
	
	.maxWidth
	{
		width: 100%;
	}
	
	.maxHeight
	{
		height: 100%;
	}
	
	.maxSize
	{
		width: 100%;
		height: 100%;
	}
	
	.stretchSize
	{
		top: 0px;
		right: 0px;
		bottom: 0px;
		left: 0px;
	}
	
	.absoluteContainer
	{
		position: relative;
	}
	
	.centerText
	{
		text-align: center;
	}
	
	.alignLeft
	{
		text-align: left;
	}
	
	.alignRight
	{
		text-align: right;
	}
	
	.menu
	, .horizontalMenu
	, .verticalMenu
	, .listing
	, ul[aria-orientation="vertical"]
	{
		margin-top: 0px;
		margin-bottom: 0px;
		padding: 0px;
		
		list-style: none;
	}
	
	.horizontalMenu > li
	, .listing:not([aria-orientation="vertical"]) > li
	{
		display: inline-block;
	}
	
	.reversedLayout
	{
		direction: rtl;
	}
	
	.reversedLayout > *
	{
		direction: ltr;
	}
	
	/* end of HELPERS */
	
	/* MAX CONTENT WIDTH LAYOUT */
	
	@media (min-width: 90em) {
		.maxContentWidth:not(.fullBleed)
		{
			margin-right: auto;
			margin-left: auto;
			
			max-width: calc(80rem - 2rem);
		}
	}
	
	@media not all and (min-width: 90em) {
		.maxContentWidth:not(.fullBleed)
		{
			padding-right: 1rem;
			padding-left: 1rem;
		}
	}
	
	.maxContentWidth.fullBleed
	{
		padding-right: 1rem;
		padding-left: 1rem;
	}
	
	.maxContentWidth.fullBleed > *
	{
		margin-right: auto;
		margin-left: auto;
		
		max-width: calc(80rem - 2rem);
	}
	
	/* end of MAX CONTENT WIDTH */
	
	/* HORIZONTAL FIT LAYOUT */
	
	.horizontalFitLayout > *
	{
		display: inline-block !important;
		
		margin-top: 0px !important;
	}
	
	.horizontalFitLayout > * + *
	{
		margin-left: 0.5555rem;
	}
	
	/* end of HORIZONTAL FIT LAYOUT */
	
	/* REVERSE ACCORDION LAYOUT */
	
	.reverseAccordionLayout
	{
		grid-template-areas: "InitialContent InitialContent InitialContent"
							 "Content Content Content"
							 ". . ."
							 "Header . Action";
		
		grid-template-columns: fit-content(50%) 1rem auto;
		grid-template-rows: auto min-content 1rem min-content;
	}
	
	.reverseAccordionLayout .InitialContent
	{
		grid-area: InitialContent;
	}
	
	.reverseAccordionLayout .Header
	{
		grid-area: Header;
		
		align-self: center;
		
		max-width: max-content;
	}
	
	.reverseAccordionLayout .Content
	{
		grid-area: Content;
	}
	
	.reverseAccordionLayout [aria-expanded="true"] + .Content
	{
		margin-top: 1rem !important;
	}
	
	.reverseAccordionLayout .Action
	{
		grid-area: Action;
	}
	
	/* end of REVERSE ACCORDION LAYOUT */
	
	/* DIRECTIONS FORM LAYOUT */
	
	.directionsFormLayout
	{
		display: grid;
		
		grid-template-areas: "OriginLabel . ."
							 "Origin . ."
							 "DestinationLabel . SwitchLocations"
							 "Destination . .";
		
		grid-template-columns: 1fr 1rem 32px;
		grid-template-rows: min-content min-content min-content min-content;
	}
	
	.directionsFormLayout > *
	{
		margin-top: 0px !important;
		margin-bottom: 0px !important;
	}
	
	.directionsFormLayout > label:first-of-type
	{
		grid-area: OriginLabel;
		
		align-self: flex-end;
	}
	
	.directionsFormLayout > input:first-of-type
	{
		grid-area: Origin;
	}
	
	.directionsFormLayout > label:last-of-type
	{
		grid-area: DestinationLabel;
		
		align-self: flex-end;
	}
	
	.directionsFormLayout > input:last-of-type
	{
		grid-area: Destination;
	}
	
	.directionsFormLayout > *:last-child
	{
		grid-area: SwitchLocations;
	}
	
	/* end of DIRECTIONS FORM LAYOUT */
	
	/* FORM SINGLE COLUMN LAYOUT */
	form.singleColumn > label + label
	, form.singleColumn > label + fieldset
	, form.singleColumn > fieldset + label
	, form.singleColumn > fieldset + fieldset
	, form.singleColumn > fieldset:not([data-type="radiogroup"]) > label + label
	, form.singleColumn > fieldset:not([data-type="radiogroup"]) > fieldset + label
	, form.singleColumn > fieldset:not([data-type="radiogroup"]) > label + fieldset
	, form.singleColumn > fieldset:not([data-type="radiogroup"]) > fieldset + fieldset
	, form.singleColumn > fieldset:not([data-type="radiogroup"]) > div > label + label
	, form.singleColumn > fieldset:not([data-type="radiogroup"]) > div > fieldset + label
	, form.singleColumn > fieldset:not([data-type="radiogroup"]) > div > label + fieldset
	, form.singleColumn > fieldset:not([data-type="radiogroup"]) > div > fieldset + fieldset
	{
		margin-top: 2.25rem !important;
	}
	/* end of FORM SINGLE COLUMN LAYOUT */
	
	/* HOLY GRAIL LAYOUT */
	
	.fixedWidthLeftColumn
	, .fixedWidthLeftColumnForBefore:before
	, .fixedWidthLeftColumnForAfter:before
	{
		float: left;
	}
	
	.fixedWidthRightColumn
	, .fixedWidthRightColumnForBefore:before
	, .fixedWidthRightColumnForAfter:before
	{
		float: right;
	}
	
	.flexWidthColumn
	{
		display: block;
		
		overflow: hidden;
	}
	
	/* end of HOLY GRAIL LAYOUT */
	
	/* TWO COLUMN LAYOUT */
	
	@media (min-width: 64.5em) {
		.twoColumnPromoLayout.masonryLayout-oneColumn
		, .twoColumnPromoLayout.masonryLayout-twoColumn
		{
			display: none;
		}
		
		.twoColumnPromoLayout.masonryLayout-threeColumn
		{
			columns: 2;
			column-gap: 1rem;
		}
		
		.twoColumnPromoLayout.masonryLayout-threeColumn:not(:empty)
		{
			margin-top: -0.5rem;
			margin-bottom: -0.5rem;
		}
		
		.twoColumnPromoLayout.masonryLayout-threeColumn > *
		{
			display: inline-block;
			
			margin-top: 0.5rem;
			margin-bottom: 0.5rem;
			
			width: 100%;
		}
	}
	
	@media (min-width: 43.3125em) and (max-width: 64.5em) {
		.twoColumnPromoLayout.masonryLayout-oneColumn
		, .twoColumnPromoLayout.masonryLayout-threeColumn
		{
			display: none;
		}
		
		.twoColumnPromoLayout.masonryLayout-twoColumn
		{
			columns: 2;
			column-gap: 1rem;
		}
		
		.twoColumnPromoLayout.masonryLayout-twoColumn
		{
			margin-top: -0.5rem;
			margin-bottom: -0.5rem;
		}
		
		.twoColumnPromoLayout.masonryLayout-twoColumn > *
		{
			display: inline-block;
			
			margin-top: 0.5rem;
			margin-bottom: 0.5rem;
			width: 100%;
		}
	}
	
	@media not all and (min-width: 43.3125em) {
		.twoColumnPromoLayout.masonryLayout-twoColumn
		, .twoColumnPromoLayout.masonryLayout-threeColumn
		{
			display: none;
		}
		
		.twoColumnPromoLayout.masonryLayout-oneColumn > * + *
		{
			display: inline-block;
			
			margin-top: 1rem;
			width: 100%;
		}
	}
	
	/* end of TWO COLUMN LAYOUT */
	
	/* TILE LAYOUT */
	
	.tileLayout
	{
		--grout: 1rem;
		--anti-grout: calc(var(--grout) / 2 * -1);
		
		display: flex !important;
		
		flex-wrap: wrap;
		
		margin: var(--anti-grout);
	}
	
	.tileLayout > .layoutItem
	{
		flex: 1 0 0%;
		
		margin-top: 0px !important;
		padding: calc(var(--grout) / 2);
	}
	
	.tileLayout.tileLayout-twoColumn > *:not(.fullWidth):not(.prioritized)
	{
		min-width: calc(100% / 2);
		max-width: calc(100% / 2);
	}
	
	.tileLayout.tileLayout-threeColumn > *:not(.fullWidth):not(.prioritized)
	{
		min-width: calc(100% / 3);
		max-width: calc(100% / 3);
	}
	
	.tileLayout.tileLayout-fourColumn > *:not(.fullWidth):not(.prioritized)
	{
		min-width: calc(100% / 4);
		max-width: calc(100% / 4);
	}
	
	.tileLayout.tileLayout-fiveColumn > *:not(.fullWidth):not(.prioritized)
	{
		min-width: calc(100% / 5);
		max-width: calc(100% / 5);
	}
	
	.tileLayout.tileLayout-sixColumn > *:not(.fullWidth):not(.prioritized)
	{
		min-width: calc(100% / 6);
		max-width: calc(100% / 6);
	}
	
	.tileLayout.tileLayout-sevenColumn > *:not(.fullWidth):not(.prioritized)
	{
		min-width: calc(100% / 7);
		max-width: calc(100% / 7);
	}
	
	.tileLayout > .layoutItem > *
	{
		width: 100%;
		height: 100%;
	}
	
	.tileLayout > .layoutItem.prioritized
	, .tileLayout > .layoutItem.fullWidth
	{
		min-width: calc(100% - var(--grout));
	}
	
	.tileLayout > .layoutItem.prioritized
	{
		order: -1;
	}
	
	/* end of TILE LAYOUT */
	
	/* GARAGE LAYOUT */
	
	.GarageLayout
	{
		position: -webkit-sticky;
		position: sticky;
		
		bottom: 0px;
		
		z-index: 9000;
		
		pointer-events: none;
	}
	
	.GarageLayout > *
	{
		pointer-events: auto;
	}
	
	/* end of GARAGE LAYOUT */
	
	/* MAXSIZE LAYOUT */
	
	.maxSizeLayout
	, .maxSizeLayout > .layoutItem
	{
		width: 100%;
		height: 100%
	}
	
	/* end of MAXSIZE LAYOUT */
	
	/* CONTENT SPACING LAYOUT */
	
	.contentSpacingLayout
	{
		display: flex;
		
		flex-direction: column;
		
		gap: 1rem;
	}
	
	/* end of CONTENT SPACING LAYOUT */
	
	/* PADDED CONTENT SPACING LAYOUT */
	
	.paddedContentSpacingLayout
	{
		display: flex;
		
		flex-direction: column;
		
		gap: 1rem;
		
		padding-top: 1rem;
	}
	
	/* end of PADDED CONTENT SPACING LAYOUT */
	
	/* STACK LAYOUT */
	
	.stackLayout
	{
		display: grid;
		
		grid-template-areas: "Content";
		grid-template-columns: minmax(auto, 100%);
		grid-template-rows: minmax(auto, 100%);
	}
	
	.stackLayout > .layoutItem
	{
		grid-area: Content;
	}
	
	/* end of STACK LAYOUT */
	
	/* TABLE LAYOUT */
	
	.topAligned
	{
		vertical-align: top
	}
	
	/* end of TABLE LAYOUT */
	
	/* FLEXBOX */
	
	.flexContainer
	{
		display: -ms-flexbox;
		display: flex;
	}
	
	.flexWrapper
	{
		-ms-flex-wrap: wrap;
		flex-wrap: wrap
	}
	
	.flexColumn
	{
		-ms-flex-direction: column;
		flex-direction: column;
	}
	
	.distributedContent
	{
		-ms-flex-pack: distribute;
		justify-content: space-around;
	}
	
	.fullyJustifiedContent
	{
		-ms-flex-pack: justify;
		justify-content: space-between;
	}
	
	.leftJustifiedContent:not(.flexColumn)
	{
		-ms-flex-pack: start;
		justify-content: flex-start;
	}
	
	.leftJustifiedContent.flexColumn
	{
		-ms-flex-align: start;
		align-items: flex-start;
	}
	
	.rightJustifiedContent:not(.flexColumn)
	{
		-ms-flex-pack: end;
		justify-content: flex-end;
	}
	
	.rightJustifiedContent.flexColumn
	{
		-ms-flex-align: end;
		align-items: flex-end;
	}
	
	.horizontallyCenteredContent:not(.flexColumn)
	{
		-ms-flex-pack: center;
		justify-content: center;
	}
	
	.horizontallyCenteredContent.flexColumn
	{
		-ms-flex-align: center;
		align-items: center;
	}
	
	.verticallyCenteredContent:not(.flexColumn)
	{
		-ms-flex-align: end;
		align-items: center;
	}
	
	.verticallyCenteredContent.flexColumn
	{
		-ms-flex-pack: center;
		justify-content: center;
	}
	
	.bottomAlignedContent.flexColumn
	{
		-ms-flex-pack: end;
		justify-content: flex-end;
	}
	
	*:not(.flexColumn) > .topAlignedItem
	{
		-ms-grid-row-align: start;
		align-self: flex-start;
	}
	
	*:not(.flexColumn) > .bottomAlignedItem
	{
		-ms-grid-row-align: end;
		align-self: flex-end;
	}
	
	.flexColumn > .leftJustifiedItem
	{
		-ms-grid-row-align: start;
		align-self: flex-start;
	}
	
	.flexColumn > .rightJustifiedItem
	{
		-ms-grid-row-align: end;
		align-self: flex-end;
	}
	
	.flexColumn .horizontallyCenteredItem
	, *:not(.flexColumn) > .verticallyCenteredItem
	{
		-ms-grid-row-align: center;
		align-self: center;
	}
	
	.fr-1
	{
		flex: 1;
	}
	
	.fr-2
	{
		flex: 2;
	}
	
	.fr-3
	{
		flex: 3;
	}
	
	.fr-4
	{
		flex: 4;
	}
	
	.fr-5
	{
		flex: 5;
	}
	
	/* end of FLEXBOX */
	
	/* GRID */
	
	.gridContainer
	{
		display: -ms-grid;
		display: grid;
	}
	
	.column-1
	{
		grid-column-start: 1;
		-ms-grid-column: 1;
	}
	
	.column-2
	{
		grid-column-start: 2;
		-ms-grid-column: 2;
	}
	
	.column-3
	{
		grid-column-start: 3;
		-ms-grid-column: 3;
	}
	
	.column-4
	{
		grid-column-start: 4;
		-ms-grid-column: 4;
	}
	
	.column-5
	{
		grid-column-start: 5;
		-ms-grid-column: 5;
	}
	
	.column-6
	{
		grid-column-start: 6;
		-ms-grid-column: 6;
	}
	
	.column-7
	{
		grid-column-start: 7;
		-ms-grid-column: 7;
	}
	
	.column-8
	{
		grid-column-start: 8;
		-ms-grid-column: 8;
	}
	
	.column-9
	{
		grid-column-start: 9;
		-ms-grid-column: 9;
	}
	
	.column-10
	{
		grid-column-start: 10;
		-ms-grid-column: 10;
	}
	
	.row-1
	{
		grid-row-start: 1;
		-ms-grid-row: 1;
	}
	
	.row-2
	{
		grid-row-start: 2;
		-ms-grid-row: 2;
	}
	
	.row-3
	{
		grid-row-start: 3;
		-ms-grid-row: 3;
	}
	
	.row-4
	{
		grid-row-start: 4;
		-ms-grid-row: 4;
	}
	
	.row-5
	{
		grid-row-start: 5;
		-ms-grid-row: 5;
	}
	
	.row-6
	{
		grid-row-start: 6;
		-ms-grid-row: 6;
	}
	
	.row-7
	{
		grid-row-start: 7;
		-ms-grid-row: 7;
	}
	
	.row-8
	{
		grid-row-start: 8;
		-ms-grid-row: 8;
	}
	
	.row-9
	{
		grid-row-start: 9;
		-ms-grid-row: 9;
	}
	
	.row-10
	{
		grid-row-start: 10;
		-ms-grid-row: 10;
	}
	
	.column-span-1
	{
		grid-column-end: span 1;
		-ms-grid-column-span: 1;
	}
	
	.column-span-2
	{
		grid-column-end: span 2;
		-ms-grid-column-span: 2;
	}
	
	.column-span-3
	{
		grid-column-end: span 3;
		-ms-grid-column-span: 3;
	}
	
	.column-span-4
	{
		grid-column-end: span 4;
		-ms-grid-column-span: 4;
	}
	
	.column-span-5
	{
		grid-column-end: span 5;
		-ms-grid-column-span: 5;
	}
	
	.column-span-6
	{
		grid-column-end: span 6;
		-ms-grid-column-span: 6;
	}
	
	.column-span-7
	{
		grid-column-end: span 7;
		-ms-grid-column-span: 7;
	}
	
	.column-span-8
	{
		grid-column-end: span 8;
		-ms-grid-column-span: 8;
	}
	
	.column-span-9
	{
		grid-column-end: span 9;
		-ms-grid-column-span: 9;
	}
	
	.column-span-10
	{
		grid-column-end: span 10;
		-ms-grid-column-span: 10;
	}
	
	.row-span-1
	{
		grid-row-end: span 1;
		-ms-grid-row-span: 1;
	}
	
	.row-span-2
	{
		grid-row-end: span 2;
		-ms-grid-row-span: 2;
	}
	
	.row-span-3
	{
		grid-row-end: span 3;
		-ms-grid-row-span: 3;
	}
	
	.row-span-4
	{
		grid-row-end: span 4;
		-ms-grid-row-span: 4;
	}
	
	.row-span-5
	{
		grid-row-end: span 5;
		-ms-grid-row-span: 5;
	}
	
	.row-span-6
	{
		grid-row-end: span 6;
		-ms-grid-row-span: 6;
	}
	
	.row-span-7
	{
		grid-row-end: span 7;
		-ms-grid-row-span: 7;
	}
	
	.row-span-8
	{
		grid-row-end: span 8;
		-ms-grid-row-span: 8;
	}
	
	.row-span-9
	{
		grid-row-end: span 9;
		-ms-grid-row-span: 9;
	}
	
	.row-span-10
	{
		grid-row-end: span 10;
		-ms-grid-row-span: 10;
	}
	
	/* end of GRID */
	
	/* COMPONENTS */
	
	.responsiveVideoContainer
	{
		position: relative;
		
		padding-bottom: 56%;
		
		width: 100%;
		height: 0px;
	}
	
    .responsiveVideoContainer .responsiveVideo
	{
        position: absolute;
		
        top: 0;
        left: 0;
		
        width: 100%;
        height: 100%;
    }
/* end of COMPONENTS */
</style> <style class="tllayout-shame">
	/* hack fixes an issue with verticallyCenteredContent and flexColumnWhenSmallViewOnlyContent because the latter didn't exist when the former was created */
	
	.verticallyCenteredContent.flexColumnWhenSmallViewOnlyContent
	{
		align-items: unset;
	}
	
	.tileLayout.tileLayout-threeColumnPromo > div:first-of-type
	{
		flex-basis: 66.6666%;
	}
	
	.tileLayout.tileLayout-threeColumnPromo > *:not(:first-child)
	{
		flex-basis: 33.3333%;
	}
	
	/* TILE LAYOUT */
	.verticallySparseTileLayout
	{
		--grout: 1rem;
		--anti-grout: calc(var(--grout) / 2 * -1);
		
		display: flex !important;
		
		flex-wrap: wrap;
		
		align-items: center;
		
		margin: var(--anti-grout);
	}
	
    .verticallySparseTileLayout > .layoutItem
	{
        flex: 1 0 0%;
		
        margin-top: 0px !important;
        padding: calc(var(--grout) / 2);
    }
	
    .verticallySparseTileLayout > .layoutItem > *
	{
        width: 100%;
    }
	
    .verticallySparseTileLayout > .layoutItem.prioritized, .verticallySparseTileLayout > .layoutItem.fullWidth
	{
        min-width: calc(100% - var(--grout));
    }
	
    .verticallySparseTileLayout > .layoutItem.prioritized
	{
        order: -1;
    }
	/* end of TILE LAYOUT */
	
	/* TILE LAYOUT */
	.flexColumnLayout
	{
		columns: 3;
		column-width: 320px;
	}
	
	.flexColumnLayout > *
	{
		display: inline-block;
		
		margin-top: 0.5rem;
		margin-bottom: 0.5rem;
		width: 100%;
	}
	
	/* end of TILE LAYOUT */
	
	/* VISUALIZER LAYOUT */
	.visualizerLayout article
	{
		padding: 1rem;
	}
	
	.visualizerLayout article + article
	, .visualizerLayout details + details
	, .visualizerLayout details + article + details
	, .visualizerLayout article + details + article
	{
		margin-top: 0px !important;
	}
	
	.visualizerLayout output
	{
		overscroll-behavior-x: contain;
	}
	
	@media (min-width: 48em) {
		.visualizerLayout
		{
			display: grid;
			
			grid-template-columns: 20rem 2fr;
			grid-template-rows: min-content 1fr;
			
			height: 75vh;
			max-height: 75vh;
		}
		
		.visualizerLayout > *:nth-child(1)
		{
			grid-column: 1;
			grid-row: 1;
			
			border-right: 2px solid #E6EBEF;
		}
		
		.visualizerLayout > *:nth-child(2)
		{
			grid-column: 1;
			grid-row: 2; 
			
			border-right: 2px solid #E6EBEF;
		}
		
		.visualizerLayout > *:nth-child(3)
		{
			grid-column: 2;
			grid-row: 1 / 3; 
		}
		
		.visualizerLayout > *:not(:nth-child(1)):not(:nth-child(2)):not(:nth-child(3))
		{
			display: none !important;
		}
	}
	
	@media not all and (min-width: 48em) {
		.visualizerLayout
		{
			display: flex;
			
			flex-direction: column;
		}
		
		.visualizerLayout > *:nth-child(1)
		{
			order: 0;
		}
		
		.visualizerLayout > *:nth-child(2)
		{
			order: 2;
			
			border-top: 2px solid #E6EBEF;
			
			background-color: #F2F5F7;
		}
		
		.visualizerLayout > *:nth-child(3)
		{
			order: 1;
			
			height: 100vmin;
		}
		
		.visualizerLayout output
		{
			display: flex !important;
			
			overflow-x: scroll;
			
			scroll-snap-type: x mandatory;
		}
		
		.visualizerLayout article
		{
			min-width: 100vw;
			width: 100vw;
			
			scroll-snap-align: center;
		}
		
		.visualizerLayout article > *
		{
			flex-shrink: 0;
			
			margin-right: auto;
			margin-left: auto;
			width: calc(100% - 5.5rem - 2rem); /* //??? what is the 5.5rem magic number */
		}
		
		.visualizerLayout pam-map-marker + div
		{
			display: block !important;
		}
	}
	/* end of VISUALIZER LAYOUT */
	
	@media (min-width: 48em) {
		.leftHeadingLayout
		{
			display: grid;
			
			grid-template-columns: 17.7778rem 1fr;
			grid-auto-rows: min-content;
			
			gap: 2rem;
		}
	}
	
	@media not all and (min-width: 48em) {
		.leftHeadingLayout
		{
			display: flex;
			
			flex-direction: column;
			
			gap: 1rem;
		}
	}
</style> <style class="blockslayout-400">
	[class*="Header"]
	{
		grid-area: Header;
	}
	
	[class*="CopyMain"]
	{
		grid-area: CopyMain;
	}
	
	@media not all and (min-width: 48em) {
		[class*="CopyMain"]
		{
			overflow: hidden;
		}
	}
	
	[class*="ImageMain"]
	{
		grid-area: ImageMain;
	}
	
	[class*="ImageTop"]
	{
		grid-area: ImageTop;
	}
	
	[class*="ImageBottom"]
	{
		grid-area: ImageBottom;
	}
	
	[class*="ImageBar"]
	{
		grid-column: ImageBar;
		grid-row: ImageBar;
	}
	
	[class*="Sidebar"]
	{
		grid-area: Sidebar;
			
		position: relative;
	}
	
	[class*="HorizontalRuler"]
	{
		grid-area: HorizontalRuler;
	}
	
	[class*="Pagination"]
	{
		grid-area: Pagination;
	}
	
	[class*="Background"]
	{
		grid-column: background;
		grid-row: background;
	}
		
	.fullHeight
	{
		min-height: 100vh;
	}
	
	@media (min-width: 48em) {
		.fullBleed > [class*="Background"]
		{
			grid-column: fullBleed;
		}
	}
	
	.gridContainer.forceSingleColumn
	{
		--blockPaddingTopRow: 3.3333rem !important;
		--blockPaddingBottomRow: 3.3333rem !important;
			
		grid-template-areas: "."
							 "Header"
							 "."
							 "ImageMain"
							 "."
							 "CopyMain"
							 "."
							 !important;
			
		grid-template-columns: [background-start] 1fr [background-end] !important;	
		grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content 1rem min-content 1rem min-content var(--blockPaddingBottomRow) [background-end] !important;
	}
	
	.gridContainer.forceSingleColumn > [class*="ImageMain"]:empty ~ [class*="CopyMain"]
	{
		grid-row: 4 / 7 !important;
	}
	
	.gridContainer.forceSingleColumn > [class*="Header"]:empty ~ [class*="ImageMain"]:empty ~ [class*="CopyMain"]
	{
		grid-row: 2 / 7 !important;
	}
	
	.gridContainer.noTopPadding
	{
		--blockPaddingTopRow: 0px !important;
	}
	
	.gridContainer.minimalTopPadding
	{
		--blockPaddingTopRow: 1rem !important;
	}
	
	.gridContainer.noBottomPadding
	{
		--blockPaddingBottomRow: 0px !important;
	}
	
	.gridContainer.minimalBottomPadding
	{
		--blockPaddingBottomRow: 1rem !important;
	}
	
	.gridContainer.noSidePadding
	{
		--blockPaddingColumn: 0px !important;
	}
	
	.gridContainer.forceSingleColumn > .Background[style*="background-color:"]:not([style*="background-color: transparent;"]):not([style*="background-color: white;"]) ~ [class*="Header"]
	, .gridContainer.forceSingleColumn > .Background[style*="background-color:"]:not([style*="background-color: transparent;"]):not([style*="background-color: white;"]) ~ [class*="CopyMain"]
	{
		padding-right: 1rem;
		padding-left: 1rem;
	}
</style> <style class="blockslayout-400-shame">
	div[data-block-name].hidden
	{
		display: none !important;
	}
</style> <style>
	[class*="CTALinkContainer"][style*="color:"]:not([style*="color: ;"]) > a
	,  .InfoCard[style*="color:"]:not([style*="color: ;"]) > header > h1
	,  .InfoCard[style*="color:"]:not([style*="color: ;"]) > header > h2
	,  .InfoCard[style*="color:"]:not([style*="color: ;"]) > header > h3
	,  .InfoCard[style*="color:"]:not([style*="color: ;"]) > header > h4
	,  .InfoCard[style*="color:"]:not([style*="color: ;"]) > header > h5
	,  .InfoCard[style*="color:"]:not([style*="color: ;"]) > header > h6
	{
		color: inherit !important;
	}
</style> <style>
	[data-faux-type="link"]
	{
		color:  #005DAA !important;
	}
        
	[data-faux-type="link"]:hover
	{
		color:  #00355F !important;
	}
	
	[data-faux-type="link"]
	, [data-faux-type="link"] > *
	{
		text-decoration: underline !important;
	}
</style> <style>
	[data-type="unstyledButton"]
	, [data-type="iconButton"]
	{
		border: 0px !important;
		padding: 0px !important;
		
		border-radius: 0px !important;
		
		background: none !important;
		
		text-align: left;
	}
	
	[data-type="iconButton"]
	, [data-type="iconButton"] *
	{
		font-size: 0px !important;
	}
</style> <style class="form splitcontrol styling-shame">
	.splitControl
	{
		display: flex;
	}
	
	.splitControl > *:first-child
	{
		border-right: none !important;
		
		border-top-right-radius: 0px !important;
		border-bottom-right-radius: 0px !important;
	}
	
	.splitControl > *:last-child
	{
		border-left: none !important;
		
		border-top-right-radius: 3px !important;
		border-bottom-right-radius: 3px !important;
		border-top-left-radius: 0px !important;
		border-bottom-left-radius: 0px !important;
	}
</style> <style class="tlcorrections">
	a[href*="account.translink.ca"]
	{
		display: none !important;
		
		position: absolute;
		left: -555.55rem;
		
		margin: 0px;
		margin-top: -0.0555rem;
		margin-left: -0.0555rem;
		border: 0px;
		padding: 0px;
		padding-top: 0.0555rem;
		padding-left: 0.0555rem;
		width: 0px;
		height: 0px;
		
		overflow: hidden;
		border-color: transparent;
		
		background-color: transparent;
		color: transparent;
		
		outline: 0;
	}
</style> <style class="youtube-embeddable-styling">
	youtube-embeddable
	{
		display: block;
	}
</style> <style class="pam-map-styling">
	pam-map
	{
		display: block;
	}
	
	pam-map-marker
	{
		display: block;
	}
</style> <link href="expandoAccordion-1.1.0.css" rel="preload" integrity="sha256-lQ9/HrgXCjpXCKCCNfgP/YF9kPqz1CFyQI7Wk/KIvJ0="

      crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";'

      fetchpriority="low">
    <style class="tabs-304">
	.Tabs
	{
		display: grid;
	}
	
	.Tabs [role="tabpanel"]
	{
	    min-width: calc(320px - 2rem);
	}
	
	@media (min-width: 48em) { /* LARGE */
		.Tabs
		{
			grid-template-areas: "HorizontalTabList HorizontalTabList HorizontalTabList"
								 "TabList . TabPanel"
								 "HorizontalTabPanel HorizontalTabPanel HorizontalTabPanel";
			
			grid-template-columns: min-content 2.7778rem 1fr;
			grid-template-rows: min-content min-content min-content;
		}
		
		.Tabs > [role="tablist"]:not([aria-orientation="vertical"])
		{
			grid-area: HorizontalTabList;
		}
		
		.Tabs > [role="tablist"]:not([aria-orientation="vertical"]) ~ [role="tabpanel"]
		, .Tabs > select + [role="tablist"]:not([aria-orientation="vertical"]) ~ [role="tabpanel"]
		{
			grid-area: HorizontalTabPanel;
		}
		
		.Tabs > [role="tablist"][aria-orientation="vertical"]
		{
			grid-area: TabList;
		}
		
		.Tabs > [role="tablist"][aria-orientation="vertical"] ~ [role="tabpanel"]
		, .Tabs > select + [role="tablist"][aria-orientation="vertical"] ~ [role="tabpanel"]
		{
			grid-area: TabPanel;
		}
		
		.Tabs > select
		{
			display: none !important;
		}
	}
	
	@media not all and (min-width: 48em) { /* SMALL */
		.Tabs
		{
			grid-template-areas: ". TabList ."
								 ". . ."
								 ". TabPanel .";
			
			grid-template-columns: 0.5556rem 1fr 0.5556rem;
			
			grid-template-rows: min-content 1.6667rem 1fr;
		}
		
		.Tabs > [role="tablist"]
		, .Tabs > select
		{
			grid-area: TabList;
		}
		
		.Tabs > select + [role="tablist"]
		{
			height: 0px;  /* role=tablist cannot be display:none because tabs.js's intersection observer for initing cannot run against a display:none element*/
			
			visibility: hidden;
		}
		
		.Tabs > [role="tabpanel"]
		{
			grid-area: TabPanel;
		}
	}
</style><!--
<link href="https://tlweblibs.translink.ca/InfoWindow-2.1.0.css" rel="preload" integrity="sha256-dAGg5fG8d7TawIh2rr1cdEbXOD3NLiiOt4roFFZCLHw=" crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";' fetchpriority="low" />-->
    <style class="infowindow-210">
	button[data-infowindow]:not([data-no-infowindow-icon])
	{
		display: inline-flex !important;
		
		vertical-align: text-top;
		
		font-size: 0px !important;
	}
	
	button[data-infowindow]:not([data-no-infowindow-icon]):before
	{
		content: "";
		
		display: inline-block;
		
		width: 1rem;
		height: 1rem;
		
		background-repeat: no-repeat;
		background-image: url("data:image/svg+xml;base64,CjxzdmcgaWQ9ImUxMTUyMzMyLTRkOWUtNGU2My05ZGMwLTk3OWI3NTE1YWU1YSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxOCAxOCI+CiAgPHRpdGxlPmluZm9ybWF0aW9uX2ljb248L3RpdGxlPgogIDxwYXRoIGQ9Ik04LjEsNi4zSDkuOVY0LjVIOC4xTTksMTYuMkE3LjIsNy4yLDAsMSwxLDE2LjIsOSw3LjIxLDcuMjEsMCwwLDEsOSwxNi4yTTksMGE5LDksMCwxLDAsOSw5QTksOSwwLDAsMCw5LDBNOC4xLDEzLjVIOS45VjguMUg4LjFaIiBmaWxsPSIjMDA1ZGFhIi8+Cjwvc3ZnPgo=");
		background-position: 0px 0px;
		
		vertical-align: text-top;
	}
	
	dialog[data-type="InfoWindow"]
	{
		position: fixed;
		
		top: 50%;
		
		width: 33.3333rem !important;
		
		transform: translateY(-50%);
	}
	
	dialog[data-type="InfoWindow"] > form > header > *
	{
		margin: 0px !important;
	}
	
	dialog[data-type="InfoWindow"] > form > header > button
	{
		align-self: flex-end;
	}
	
	@media (min-width: 48em) {
		dialog[data-type="InfoWindow"]
		{
			padding-bottom: 3rem;
		}
	}
</style> <style>
	document-library ul li:not(:last-child)
	{
		margin-bottom: 1rem;
	}
</style> <style>
	image-gallery
	{
		--scrollbarThumbColor: transparent;
		--scrollbarTrackColor: transparent;
		--scrollbarTrackHeight: 0px;
		
		display: flex;
		
		flex-wrap: wrap;
		
		max-height: 85vh;
		max-height: 90dvh;
		
		overflow-x: auto;
		overflow-y: hidden;
		
		scroll-snap-type: x mandatory;
		
		overscroll-behavior-x: contain;
		overscroll-behavior-y: auto;
	}
	
	image-gallery > *
	{
		margin-top: 0px !important;
	}
	
	image-gallery figure
	{
		/* //??? these size values are wrong, I think we'll need to calculate dynamically with JS */
		display: grid;
		
		grid-template-columns: 1fr;
		grid-template-rows: 1fr min-content;
		
		width: calc(var(--frameWidthInPX, 0px) * 1px);
		
		max-width: calc(var(--frameWidthInPX, 0px) * 1px);
		min-width: calc(var(--frameWidthInPX, 0px) * 1px);
		
		max-height: 100%;
		
		scroll-snap-align: center;
		
		overflow: hidden;
	}
	
	image-gallery figure img
	{
		place-self: center;
	}
	
	image-gallery figure figcaption
	{
		overflow-y: auto;
	}
</style> <style>
	/* change the default from normalize.css */
	image-gallery figure
	{
		margin: 0px;
	}
	
	image-gallery figure
	, image-gallery figure image
	{
		background-color: var(--image-background-fill-colour, rgba(0, 0, 0, 0.5));
	}
	
	image-gallery figure figcaption
	{
		padding: 1rem;
		
		background-color: var(--caption-background-colour, var(--lightGrey));
		color: var(--caption-text-colour, var(--nearBlack));
	}
</style> <!-- END OF Global Head CSS -->
    <!-- Site Head CSS -->
    <link href="tlTheme-4.1.0.css" rel="stylesheet" integrity="sha256-KxYAxsEb7FO4+EScMMo9nsw/2XXBWG/9IWZdSFauVKM="

      crossorigin="anonymous">
    <style class="tltheme-shame">
	summary
	{
		outline-offset: 1px !important;
	}
</style> <style class="tltheme-shame">
	[aria-invalid="true"]
	{
		border-color: var(--errorRed, #D01E11) !important;
	}
	
	*:not([type="radio"])[aria-invalid="true"] ~ *:not([role="alert"]):not(input):not(textarea):not(select):not(button)
	{
		display: none !important;
	}
	
	[role="alert"]
	, *:not([type="radio"])[aria-invalid="true"] ~ *:not([role="alert"])
	, *:not([type="radio"])[aria-invalid="true"] ~ input
	, *:not([type="radio"])[aria-invalid="true"] ~ textarea
	, *:not([type="radio"])[aria-invalid="true"] ~ select
	, *:not([type="radio"])[aria-invalid="true"] ~ button
	{
		color: var(--errorRed, #D01E11) !important;
	}
	
	[role="alert"][aria-controls]:not([aria-controls=""]):not(:empty) > *:first-child:before
	{
	    content: url("-/media/translink/icons/forms/error_red.svg");
		
		display: inline-block;
		
		margin-right: 0.25rem;
		width: 1.25rem;
	}
</style> <style class="tltheme-shame">
	[type="radio"]:not(:checked):not([readonly])
	, [type="radio"]:not(:checked):not(:disabled)
	{
		background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2ZmZjt9LmN7ZmlsbDojMDAzNTVmO308L3N0eWxlPjwvZGVmcz48Y2lyY2xlIGNsYXNzPSJiIiBjeD0iMTIiIGN5PSIxMiIgcj0iOS42Ii8+PHBhdGggY2xhc3M9ImMiIGQ9Ik0xMiwwQzUuMzcsMCwwLDUuMzcsMCwxMnM1LjM3LDEyLDEyLDEyLDEyLTUuMzcsMTItMTJTMTguNjMsMCwxMiwwWk0yLjQsMTJDMi40LDYuNyw2LjcsMi40LDEyLDIuNHM5LjYsNC4zLDkuNiw5LjYtNC4zLDkuNi05LjYsOS42UzIuNCwxNy4zLDIuNCwxMloiLz48L3N2Zz4=") !important;
	}
	
	[type="radio"][readonly]:not(:checked)
	, [type="radio"]:disabled:not(:checked)
	{
		background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2U1ZTVlNTt9LmN7ZmlsbDojY2NjO308L3N0eWxlPjwvZGVmcz48Y2lyY2xlIGNsYXNzPSJiIiBjeD0iMTIiIGN5PSIxMiIgcj0iOS42Ii8+PHBhdGggY2xhc3M9ImMiIGQ9Ik0xMiwwQzUuMzcsMCwwLDUuMzcsMCwxMnM1LjM3LDEyLDEyLDEyLDEyLTUuMzcsMTItMTJTMTguNjMsMCwxMiwwWk0yLjQsMTJDMi40LDYuNyw2LjcsMi40LDEyLDIuNHM5LjYsNC4zLDkuNiw5LjYtNC4zLDkuNi05LjYsOS42UzIuNCwxNy4zLDIuNCwxMloiLz48L3N2Zz4=") !important;
	}
	
	[type="radio"]:checked:not([readonly]):not(:disabled)
	{
		background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2ZmZjt9LmN7ZmlsbDojMDAzNTVmO308L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iYiIgZD0iTTEyLDIuNEM2LjcsMi40LDIuNCw2LjcsMi40LDEyczQuMyw5LjYsOS42LDkuNiw5LjYtNC4zLDkuNi05LjZTMTcuMywyLjQsMTIsMi40Wm0wLDE1LjZjLTMuMzEsMC02LTIuNjktNi02czIuNjktNiw2LTYsNiwyLjY5LDYsNi0yLjY5LDYtNiw2WiIvPjxwYXRoIGNsYXNzPSJjIiBkPSJNMTIsMEM1LjM3LDAsMCw1LjM3LDAsMTJzNS4zNywxMiwxMiwxMiwxMi01LjM3LDEyLTEyUzE4LjYzLDAsMTIsMFptMCwyMS42Yy01LjMsMC05LjYtNC4zLTkuNi05LjZTNi43LDIuNCwxMiwyLjRzOS42LDQuMyw5LjYsOS42LTQuMyw5LjYtOS42LDkuNloiLz48Y2lyY2xlIGNsYXNzPSJjIiBjeD0iMTIiIGN5PSIxMiIgcj0iNiIvPjwvc3ZnPg==") !important;
	}
	
	[type="radio"][readonly]:checked
	, [type="radio"]:disabled:checked
	{
		background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2U1ZTVlNTt9LmN7ZmlsbDojY2NjO308L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iYiIgZD0iTTEyLDIuNEM2LjcsMi40LDIuNCw2LjcsMi40LDEyczQuMyw5LjYsOS42LDkuNiw5LjYtNC4zLDkuNi05LjZTMTcuMywyLjQsMTIsMi40Wm0wLDE1LjZjLTMuMzEsMC02LTIuNjktNi02czIuNjktNiw2LTYsNiwyLjY5LDYsNi0yLjY5LDYtNiw2WiIvPjxwYXRoIGNsYXNzPSJjIiBkPSJNMTIsMEM1LjM3LDAsMCw1LjM3LDAsMTJzNS4zNywxMiwxMiwxMiwxMi01LjM3LDEyLTEyUzE4LjYzLDAsMTIsMFptMCwyMS42Yy01LjMsMC05LjYtNC4zLTkuNi05LjZTNi43LDIuNCwxMiwyLjRzOS42LDQuMyw5LjYsOS42LTQuMyw5LjYtOS42LDkuNloiLz48Y2lyY2xlIGNsYXNzPSJjIiBjeD0iMTIiIGN5PSIxMiIgcj0iNiIvPjwvc3ZnPg==") !important;
	}
	
	[type="checkbox"]:not(:checked):not([readonly]):not(:disabled)
	{
		background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2ZmZjt9LmN7ZmlsbDojMDAzNTVmO308L3N0eWxlPjwvZGVmcz48cmVjdCBjbGFzcz0iYiIgeD0iMi42NyIgeT0iMi42NyIgd2lkdGg9IjE4LjY3IiBoZWlnaHQ9IjE4LjY3Ii8+PHBhdGggY2xhc3M9ImMiIGQ9Ik0yMS4zNCwwSDIuNjdDMS4yLDAsMCwxLjE4LDAsMi42NVYyMS4zM0MwLDIyLjgxLDEuMTksMjQsMi42NywyNEgyMS4zM2MxLjQ3LDAsMi42Ny0xLjE5LDIuNjctMi42N1YyLjY3QzI0LDEuMTksMjIuODEsMCwyMS4zNCwwWm0wLDIxLjMzSDIuNjdWMi42N0gyMS4zM1YyMS4zM1oiLz48L3N2Zz4=") !important;
	}
	
	[type="checkbox"][readonly]:not(:checked)
	, [type="checkbox"]:disabled:not(:checked)
	{
		background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2U1ZTVlNTt9LmN7ZmlsbDojY2NjO308L3N0eWxlPjwvZGVmcz48cmVjdCBjbGFzcz0iYiIgeD0iMi42NyIgeT0iMi42NyIgd2lkdGg9IjE4LjY3IiBoZWlnaHQ9IjE4LjY3Ii8+PHBhdGggY2xhc3M9ImMiIGQ9Ik0yMS4zNCwwSDIuNjdDMS4yLDAsMCwxLjE4LDAsMi42NVYyMS4zM0MwLDIyLjgxLDEuMTksMjQsMi42NywyNEgyMS4zM2MxLjQ3LDAsMi42Ny0xLjE5LDIuNjctMi42N1YyLjY3QzI0LDEuMTksMjIuODEsMCwyMS4zNCwwWm0wLDIxLjMzSDIuNjdWMi42N0gyMS4zM1YyMS4zM1oiLz48L3N2Zz4=") !important;
	}
	
	[type="checkbox"]:checked:not([readonly]):not(:disabled)
	{
		background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2ZmZjt9LmN7ZmlsbDojMDAzNTVmO308L3N0eWxlPjwvZGVmcz48cG9seWdvbiBjbGFzcz0iYiIgcG9pbnRzPSI5LjMzIDE0Ljg5IDQuNTUgMTAuMTEgMi42NyAxMiA5LjMzIDE4LjY3IDIxLjMzIDYuNjcgMTkuNDUgNC43NyA5LjMzIDE0Ljg5Ii8+PHBhdGggY2xhc3M9ImMiIGQ9Ik0yMS4zNCwwSDIuNjdDMS4yLDAsMCwxLjE4LDAsMi42NVYyMS4zM0MwLDIyLjgxLDEuMTksMjQsMi42NywyNEgyMS4zM2MxLjQ3LDAsMi42Ny0xLjE5LDIuNjctMi42N1YyLjY3QzI0LDEuMTksMjIuODEsMCwyMS4zNCwwWk05LjMzLDE4LjY3TDIuNjcsMTJsMS44OC0xLjg5LDQuNzksNC43OUwxOS40NSw0Ljc3bDEuODgsMS44OS0xMiwxMloiLz48L3N2Zz4=") !important;
	}
	
	[type="checkbox"][readonly]:checked
	, [type="checkbox"]:disabled:checked
	{
		background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2U1ZTVlNTt9LmN7ZmlsbDojY2NjO308L3N0eWxlPjwvZGVmcz48cG9seWdvbiBjbGFzcz0iYiIgcG9pbnRzPSI5LjMzIDE0Ljg5IDQuNTUgMTAuMTEgMi42NyAxMiA5LjMzIDE4LjY3IDIxLjMzIDYuNjcgMTkuNDUgNC43NyA5LjMzIDE0Ljg5Ii8+PHBhdGggY2xhc3M9ImMiIGQ9Ik0yMS4zNCwwSDIuNjdDMS4yLDAsMCwxLjE4LDAsMi42NVYyMS4zM2MwLDEuNDcsMS4xOSwyLjY3LDIuNjcsMi42N0gyMS4zM2MxLjQ3LDAsMi42Ny0xLjE5LDIuNjctMi42N1YyLjY3YzAtMS40Ny0xLjE5LTIuNjctMi42Ni0yLjY3Wk05LjMzLDE4LjY3TDIuNjcsMTJsMS44OC0xLjg5LDQuNzksNC43OUwxOS40NSw0Ljc3bDEuODgsMS44OS0xMiwxMloiLz48L3N2Zz4=") !important;
	}
	
	[type="radio"][readonly] + span
	, [type="radio"]:disabled + span
	, [type="checkbox"][readonly] + span
	, [type="checkbox"]:disabled + span
	{
		color: #666666;
	}
</style> <style class="switchelementtheme">
	[role="switch"]
	{
		position: relative;
		
		display: flex;
		
		align-items: center;
		
		border: 1px solid #707070 !important;
		padding: 0.5rem !important;
		height: 1.8333rem;
		
		border-radius: 1.35rem !important;
		
		overflow: hidden;
	}
	
	[role="switch"][aria-checked="true"]
	{
		background-color: #C0D646 !important;
		color: #494949 !important;
	}
	
	[role="switch"][aria-checked="false"]
	{
		background-color: white !important;
		color: #00355F !important;
	}
	
	[role="switch"]:disabled
	{
		background-color: #EDEDED !important;
		color: #666666 !important;
	}
	
	[role="switch"]:after
	{
		content: " ";
		
		position: absolute;
		
		top: 50%;
		
		display: block;
		
		border: 1px solid #707070;
		width: 1.5rem;
		height: 1.5rem;
		
		border-radius: 50%;
		
		background-color: white;
		
		transform: translateY(-50%);
	}
	
	[role="switch"][aria-checked="true"]:after
	{
		right: 2px;
	}
	
	[role="switch"][aria-checked="false"]:after
	{
		left: 2px;
	}
	
	[role="switch"] > *
	{
	    position: relative;
		
		top: 1px;
	}
</style> <style class="tlTheme-shame">
	[data-styling="button"]:focus
	, [data-styling="button"]:hover
	{
		background-color: #00355F !important;
		color: white !important;
	}
	
	@media (min-width: 48em) {
		[data-styling="button"]
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif !important; /* override normalize.css for button, input, optgroup, select, textarea */
			
			font-size: 1rem !important; /* override normalize.css for button, input, optgroup, select, textarea */
			line-height: 1.15rem !important;
			
			font-weight: normal !important;
		}
	}
	
	@media not all and (min-width: 48em) {
		[data-styling="button"]
		{
			font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif !important; /* override normalize.css for button, input, optgroup, select, textarea */
			
			font-size: 0.8888rem !important; /* override normalize.css for button, input, optgroup, select, textarea */
			line-height: 1.3333rem !important;
			
			font-weight: normal !important;
		}
	}
</style> <style>
	.SiteNav > .SiteLogo
	{
		display: inline-block;
	}
	
	.SiteNav > nav ul
	, .SiteNav > * > nav ul
	{
		margin-top: 0.75rem;
		margin-bottom: -1rem;
		
		padding-left: 1rem;
		
		list-style: none;
	}

	.SiteNav > nav [aria-expanded="false"] + ul
	, .SiteNav > * > nav [aria-expanded="false"] + ul
	{
		display: none !important;
	}
	
	@media (min-width: 76.875em) {
		.SiteNav
		{
			--bottomSpacing: 1rem;
		}
		
		.SiteNav > nav > ul
		, .SiteNav > * > nav > ul
		{
			display: flex;
			
			flex-wrap: wrap;
			
			margin-bottom: 0px;
		}
		
		.SiteNav > nav > ul > li
		, .SiteNav > * > nav > ul > li
		{
			position: relative;
		}
		
		.SiteNav > nav > ul > li > [aria-expanded]
		, .SiteNav > * > nav > ul > li > [aria-expanded]
		{
			margin-left: 0.3333rem;
			padding-right: 0px;
		}
		
		.SiteNav > nav > ul > li > [aria-expanded] > *:first-child
		, .SiteNav > * > nav > ul > li > [aria-expanded] > *:first-child
		{
			width: 0.5rem;
		}
		
		.SiteNav > nav > ul > li > [aria-expanded="true"] + ul
		, .SiteNav > * > nav > ul > li > [aria-expanded="true"] + ul
		{
			position: absolute;
			
			top: 100%;
			
			display: inline-block !important;
			
			margin-top: 0px;
			
			transform: translateX(calc(-50% - 0.26rem));
			
			z-index: 9000;
		}
		
		.SiteNav > nav > ul > li:last-child > [aria-expanded="true"] + ul
		, .SiteNav > * > nav > ul > li:last-child > [aria-expanded="true"] + ul
		{
			right: 0px;
			left: unset;
			
			transform: unset;
		}
		
		.SiteNav > nav > ul > li > [aria-expanded="true"] + ul:before
		, .SiteNav > * > nav > ul > li > [aria-expanded="true"] + ul:before
		{
			content: " ";
			
			position: absolute;
			
			top: -1rem;
			left: 50%;
			
			display: inline-block;
			
			width: 1rem;
			height: 1rem;
			
			transform: translateX(-50%) translateY(50%) rotate(45deg);
		}
		
		.SiteNav > nav > ul > li:last-child > [aria-expanded="true"] + ul:before
		, .SiteNav > * > nav > ul > li:last-child > [aria-expanded="true"] + ul:before
		{
			right: 1rem;
			left: unset;
			
			transform: translateY(50%) rotate(45deg);
		}
		
		.SiteNav > nav > ul > li > ul > li > *:not(a)
		, .SiteNav > * > nav > ul > li > ul > li > *:not(a)
		{
			display: none;
		}
		
		.SiteNav .HamburgerMenuButton
		{
			display: none !important;
		}
	
		.SiteNav .HamburgerMenuButton + *
		{
			display: block !important;
		}
	}

	@media not all and (min-width: 76.875em)
	{
		.SiteNav
		{
			flex-wrap: wrap;
		}
		
		.SiteNav > nav
		, .SiteNav > * > nav
		{
			flex-basis: 100%;
		}
		
		.SiteNav > nav ul
		, .SiteNav > * > nav ul
		{
			flex-basis: 100%;
		}
		
		.SiteNav > nav ul > li
		, .SiteNav > * > nav ul > li
		{
			display: flex;
			
			flex-wrap: wrap;
			justify-content: space-between;
		}
		
		.SiteNav > nav > ul > li > [aria-expanded]
		, .SiteNav > * > nav > ul > li > [aria-expanded]
		{
			position: relative;
		}

		.SiteNav > nav > ul > li > [aria-expanded]:focus
		, .SiteNav > * > nav > ul > li > [aria-expanded]:focus
		{
            outline: none !important;
		}  
		
		.SiteNav > nav > ul > li > [aria-expanded] *
		, .SiteNav > * > nav > ul > li > [aria-expanded] *
		{
			display: none;
		}
		
		.SiteNav > nav > ul > li > [aria-expanded]:before
		, .SiteNav > * > nav > ul > li > [aria-expanded]:before
		, .SiteNav > nav > ul > li > [aria-expanded="false"]:after
		, .SiteNav > * > nav > ul > li > [aria-expanded="false"]:after
		{
			content: " ";
			
			position: absolute;
			
			top: 50%;
			
			transform: translateY(-50%);
		}
		
		.SiteNav > nav > ul > li > [aria-expanded]:before
		, .SiteNav > * > nav > ul > li > [aria-expanded]:before
		{
			right: 0px;
			
			width: 1.1111rem;
			height: 0.2222rem;
		}

		.SiteNav > nav > ul > li > [aria-expanded]:focus-visible:before
		, .SiteNav > * > nav > ul > li > [aria-expanded]:focus-visible:before
		{
			outline: 2px solid var(--focusOutlineColor, #0081C6);
			outline-offset: 0.8rem;
		}
		
		.SiteNav > nav > ul > li > [aria-expanded]:after
		, .SiteNav > * > nav > ul > li > [aria-expanded]:after
		{
			right: 0.45rem;
			
			width: 0.2222rem;
			height: 1.1111rem;
		}
		
		.SiteNav > nav > ul > li > a
		, .SiteNav > * > nav > ul > li > a
		{
			flex: 1;
			
			display: flex;
			
			justify-content: space-between;
		}
		
		.SiteNav > nav > ul > li > a[target="_blank"]:after
		, .SiteNav > * > nav > ul > li > a[target="_blank"]:after
		{
			content: " ";
			
			display: inline-block;
			
			width: 1rem;
			height: 100%;
			
			background-repeat: no-repeat;
			background-position: center center;
		}
		
		.SiteNav > nav > ul > li > a + button
		, .SiteNav > * > nav > ul > li > a + button
		{
			flex-grow: 0;
			flex-shrink: 0;
			flex-basis: 34px;
			
			padding: 0px
		}
		
		.SiteNav > nav > ul > li > ul > li > a
		, .SiteNav > * > nav > ul > li > ul > li > a
		{
			flex: 1;
		}
		
		.SiteNav .HamburgerMenuButton
		{
			margin-left: auto;
		}
		
		.SiteNav .HamburgerMenuButton[aria-expanded="false"]:not(aria-controls) + *
		{
			display: none;
		}
	}
</style> <style class="translink-sitenavtheme">
	.SiteNav
	{
		--fontColor: #00355F;
		
		--bottomDividingBorder: 1px solid #DBE5EB;
		
		--linkSpacing: 1.75rem;
		--linkDividingBorderStyle: 1px solid;
		--linkDividingBorderColor: #E6EBEF;
		--linkOpenInNewWindowIcon: url("data:image/svg+xml;base64,PHN2ZyBpZD0iZWZhNmVlMTItYmE1My00MGYyLTg0MTctN2FiZmJjOWFkNWZjIiBkYXRhLW5hbWU9IkxheWVyIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8dGl0bGU+b3Blbi1pbi1uZXc8L3RpdGxlPgogIDxwYXRoIGQ9Ik0xNC42NywwVjIuNjdoNC43OEw2LjM1LDE1Ljc3bDEuODgsMS44OCwxMy4xLTEzLjFWOS4zM0gyNFYwTTIxLjMzLDIxLjMzSDIuNjdWMi42N0gxMlYwSDIuNjdBMi42NywyLjY3LDAsMCwwLDAsMi42N1YyMS4zM0EyLjY2LDIuNjYsMCwwLDAsMi42NywyNEgyMS4zM0EyLjY2LDIuNjYsMCwwLDAsMjQsMjEuMzNWMTJIMjEuMzNaIiBmaWxsPSIjMDA1ZGFhIi8+Cjwvc3ZnPgo=");
		
		--defaultLinkUnderline: none;
		--hoverLinkUnderline: underline;
		
		--dropdownMenuBorderStyle: 1px solid;
		--dropdownMenuBorderColor: #DBE5EB;
		--dropdownMenuPadding: 1.6666rem 1rem;
		--dropdownMenuBackgroundColor: white;
		--dropdownMenuDropShadow: 0rem 0.75rem 1rem 0.5rem rgba(0, 0, 0, 0.06);
		
		--sublinkTextWrapping: pre;
		--sublinkDividingBorderStyle: 1px solid;
		--sublinkDividingBorderColor: white;
		--sublinkAccordionIconColor: #005DAA;
		--sublinkAccordionDividerBorderStyle: 1px solid;
		--sublinkAccordionDividerBorderColor: #E6EBEF;
	}
	
	.SiteNav
	{
		border-bottom: var(--bottomDividingBorder);
		
		color: var(--fontColor);
	}
	
	.SiteNav > .SiteLogo
	{
		display: inline-block;
	}
	
	.SiteNav > nav a
	, .SiteNav > * > nav a
	{
		text-decoration: var(--defaultLinkUnderline);
		
		white-space: nowrap;
	}
	
	.SiteNav > nav a:focus
	, .SiteNav > * > nav a:focus
	, .SiteNav > nav a:hover
	, .SiteNav > * > nav a:hover
	{
		text-decoration: var(--hoverLinkUnderline);
	}
	
	.SiteNav > nav > ul
	, .SiteNav > * > nav > ul
	{
		margin-top: 0px;
		margin-bottom: 0px;
		padding-left: 0px;
	}
	
	.SiteNav > nav > ul > li
	, .SiteNav > * > nav > ul > li
	{
		padding-top: 1rem;
		padding-bottom: var(--bottomSpacing);
	}
	
	.SiteNav .HamburgerMenuButton
	{
		font-size: 0.75rem !important;
	}
	
	.SiteNav .fullBleed
	{
		position: relative;
	}
	
	.SiteNav .fullBleed:before
	, .SiteNav .fullBleed:after
	{
		content: " ";
		
		position: absolute;
		
		top: 0px;
		bottom: 0px;
		
		width: 1rem;
		
		background-color: inherit;
	}
	
	.SiteNav .fullBleed:before
	{
		left: -1rem;
	}
	
	.SiteNav .fullBleed:after
	{
		right: -1rem;
	}
	
	@media (min-width: 76.875em) {
		.SiteNav
		{
			--superNavLinkPadding: 1rem;
			--sublinkSpacing: 1.5rem;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul
		{
			border-left: 1px solid white;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li
		{
			border-right: 1px solid white;
			padding: var(--superNavLinkPadding);
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li *
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li *
		{
			text-transform: uppercase;
		}
		
		.SiteNav > nav > ul > li > button:not(:focus):not(:hover)
		, .SiteNav > * > nav > ul > li > button:not(:focus):not(:hover)
		{
			text-decoration: none !important;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li.activeSuperNav
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li.activeSuperNav
		{
			background-color: white;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li.activeSuperNav *
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li.activeSuperNav *
		{
			color: #005DAA !important;
		}
		
		.SiteNav > nav:not([aria-label="Super Navigation"]):not([aria-label="Account Navigation"]) > ul > li:not(:last-child)
		, .SiteNav > * > nav:not([aria-label="Super Navigation"]):not([aria-label="Account Navigation"]) > ul > li:not(:last-child)
		{
			padding-right: var(--linkSpacing);
		}
		
		.SiteNav > nav:not([aria-label="Super Navigation"]) > ul > li > [aria-expanded="true"] + ul
		, .SiteNav > * > nav:not([aria-label="Super Navigation"]) > ul > li > [aria-expanded="true"] + ul
		{
			border: var(--dropdownMenuBorderStyle);
			border-color: var(--dropdownMenuBorderColor);
			padding: var(--dropdownMenuPadding);
			
			background-color: var(--dropdownMenuBackgroundColor);
			
			box-shadow: var(--dropdownMenuDropShadow);
		}
		
		.SiteNav > nav:not([aria-label="Super Navigation"]) > ul > li > [aria-expanded="true"] + ul:before
		, .SiteNav > * > nav:not([aria-label="Super Navigation"]) > ul > li > [aria-expanded="true"] + ul:before
		{
			border: 1px solid var(--dropdownMenuBorderColor);
			border-right: 1px solid var(--dropdownMenuBackgroundColor);
			border-bottom: 1px solid var(--dropdownMenuBackgroundColor);
			
			background-color: var(--dropdownMenuBackgroundColor);
		}
		
		.SiteNav > nav:not([aria-label="Super Navigation"]) > ul > li > [aria-expanded] + ul > li
		, .SiteNav > * > nav:not([aria-label="Super Navigation"]) > ul > li > [aria-expanded] + ul > li
		{
			white-space: var(--sublinkTextWrapping);
		}
		
		.SiteNav > nav:not([aria-label="Super Navigation"]) > ul > li > [aria-expanded] + ul > li + li
		, .SiteNav > * > nav:not([aria-label="Super Navigation"]) > ul > li > [aria-expanded] + ul > li + li
		{
			margin-top: var(--sublinkSpacing) !important;
		}
		
		.SiteNav > nav[aria-label="Account Navigation"]
		{
			display: flex !important;
			
			justify-content: flex-end;
		}
		
		.SiteNav > nav[aria-label="Account Navigation"] > ul > li
		, .SiteNav > * > nav[aria-label="Account Navigation"] > ul > li
		{
			justify-content: flex-end;
			
			padding-top: var(--superNavLinkPadding);
			padding-bottom: var(--superNavLinkPadding);
		}
		
		.SiteNav > nav[aria-label="Account Navigation"] > ul > li > a
		, .SiteNav > * > nav[aria-label="Account Navigation"] > ul > li > a
		, .SiteNav > nav[aria-label="Account Navigation"] > ul > li > p
		, .SiteNav > * > nav[aria-label="Account Navigation"] > ul > li > p
		, .SiteNav > nav[aria-label="Account Navigation"] > ul > li > button
		, .SiteNav > * > nav[aria-label="Account Navigation"] > ul > li > button
		{
			font-size: 0.8888rem !important;
		}
		
		.SiteNav > nav[aria-label="Account Navigation"] > ul > li:not(:empty) + li:before
		, .SiteNav > * > nav[aria-label="Account Navigation"] > ul > li:not(:empty) + li:before
		{	
			display: inline-block;
			
			content: "";
			
			margin-right: 1.1111rem;
			margin-left: 1.1111rem;
			border-right: 2px solid white;
			height: calc(1em - 1px);
			
			vertical-align: middle;
			
			pointer-events: none;
		}
	}
	
	@media not all and (min-width: 76.875em) {
		.SiteNav
		{
			--topSpacing: 0.75rem;
			--bottomSpacing: 0px;
			
			--linkFont: "Fira Sans Bold", Arial, Helvetica, sans-serif;
			--sublinkFont: var(--linkFont);
			
			--superNavLinkPadding: 1rem;
			--sublinkSpacing: 1rem 0px;
		}
		
		.SiteNav
		{
			padding-top: var(--topSpacing);
			padding-bottom: var(--bottomSpacing);
		}
		
		.SiteNav > *:first-child
		, .SiteNav > nav > *:not([aria-expanded]) + *
		{
			margin-bottom: 0.75rem;
		}
		
		.SiteNav > nav ul > li
		, .SiteNav > * > nav ul > li
		{
			padding: var(--sublinkSpacing);
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul
		{
			display: flex;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li
		{
			display: flex;
			align-content: center;
			
			flex: 1;
			
			padding: 0px;
		}
		
		.SiteNav > nav:not([aria-label="Super Navigation"]) > ul > li + li
		, .SiteNav > * > nav:not([aria-label="Super Navigation"]) > ul > li + li
		{
			border-top: var(--linkDividingBorderStyle) var(--linkDividingBorderColor);
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li + li
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li + li
		{
			border-left: 1px solid white;
		}
		
		.SiteNav > nav > ul > li > [aria-expanded]:before
		, .SiteNav > * > nav > ul > li > [aria-expanded]:before
		, .SiteNav > nav > ul > li > [aria-expanded="false"]:after
		, .SiteNav > * > nav > ul > li > [aria-expanded="false"]:after
		{
			background-color: var(--sublinkAccordionIconColor);
		}
		
		.SiteNav > nav > ul > li > [aria-expanded="true"] + ul
		, .SiteNav > * > nav > ul > li > [aria-expanded="true"] + ul
		{
			margin-bottom: 1px;
			
			background-color: #F2F5F7;
		}

		.SiteNav > nav > ul > li > ul > li
		, .SiteNav > * > nav > ul > li > ul > li
		{
			padding: var(--sublinkSpacing);
		}
		
		.SiteNav > nav > ul > li > ul li + li
		, .SiteNav > * > nav > ul > li > ul li + li
		{
			border-top: var(--sublinkDividingBorderStyle) var(--sublinkDividingBorderColor);
		}
		
		.SiteNav > nav > ul > li > a
		, .SiteNav > * > nav > ul > li > a
		, .SiteNav > nav > ul > li > button
		, .SiteNav > * > nav > ul > li > button
		{
			font-family: var(--linkFont) !important;
		}
		
		.SiteNav > nav > ul > li > button:not(:focus):not(:hover)
		, .SiteNav > * > nav > ul > li > button:not(:focus):not(:hover)
		{
			text-decoration: none !important;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li > a
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li > a
		{
			display: flex;
			
			justify-content: center;
			align-items: center;
			
			padding: var(--superNavLinkPadding) 0.5rem;
			height: 100%;
			
			color: white;
			
			text-align: center;
			
			text-transform: uppercase;
			
			white-space: normal;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li.activeSuperNav > a
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li.activeSuperNav > a
		{
			background-color: white;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li.activeSuperNav *
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li.activeSuperNav *
		{
			color: #005DAA !important;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"] > ul > li:not(.activeSuperNav) > a:focus
		, .SiteNav > nav[aria-label="Super Navigation"] > ul > li:not(.activeSuperNav) > a:hover
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li:not(.activeSuperNav) > a:focus
		, .SiteNav > * > nav[aria-label="Super Navigation"] > ul > li:not(.activeSuperNav) > a:hover
		{
			color: white !important;
		}
		
		.SiteNav > nav[aria-label="Account Navigation"] > ul > li > p
		, .SiteNav > * > nav[aria-label="Account Navigation"] > ul > li > p
		{
			word-break: break-word;
		}
		
		.SiteNav > nav > ul > li > a[target="_blank"]:after
		, .SiteNav > * > nav > ul > li > a[target="_blank"]:after
		{
			background-image: var(--linkOpenInNewWindowIcon);
		}
		
		.SiteNav > nav > ul > li > a + button
		, .SiteNav > * > nav > ul > li > a + button
		{
			border-left: var(--sublinkAccordionDividerBorderStyle) var(--sublinkAccordionDividerBorderColor) !important;
		}
		
		.SiteNav > nav > ul > li > ul > li > a
		, .SiteNav > * > nav > ul > li > ul > li > a
		{
			font-family: var(--sublinkFont);
		}
	}
</style> <style class="tripplanner-tabTheme">
	.Tabs
	{
		--tabWidgetOutlineColor: #D0D7DC;
	}
	
	.Tabs
	{
		border-radius: 3px;
		
		width: 100%;
	}
	
	.Tabs > select
	{
		margin-bottom: 1rem;
	}
	
	[role="tablist"]
	{
		display: flex;
		
		flex-wrap: wrap;
		
		margin: 0px;
		margin-top: 0px !important; /* NOTE: override margin-top added by tltheme */
		padding: 0px;
		
		border-radius: 3px 3px 0px 0px;
		
		list-style: none;
	}
	
	[role="tablist"] > li
	{
		flex: 1;
	}
	
	[role="tablist"] > li:first-child > [role="tab"]
	{
		border-top-left-radius: 3px;
	}
	
	[role="tablist"] > li:last-child > [role="tab"]
	{
		border-top-right-radius: 3px;
	}
	
	[role="tab"]
	{
		display: inline-flex;
		
		justify-content: center;
		align-items: center;
		
		gap: 1rem;
		
		padding: 1rem;
		width: 100%;
		height: 100%;
		
		font-size: 1.3333rem;
		
		background-color: #F2F5F7;
		color: inherit;
		
		background-clip: padding-box;
	}
	
	[role="tablist"] > li:not(:first-child) > [role="tab"]
	{
		border-left: 1px solid #E6EBEF;
	}
	
	[role="tablist"] > li:not(:last-child) > [role="tab"]
	{
		border-right: 1px solid #E6EBEF;
	}
	
	[role="tab"]:not([aria-selected="true"])
	{
		margin-top: 5px;
	}
	
	[role="tablist"] > li > [role="tab"][aria-selected="true"]
	{
		position: relative;
		
		border-top: 5px solid #003460;
		border-right: 1px solid var(--tabWidgetOutlineColor);
		border-left: 1px solid var(--tabWidgetOutlineColor);
		
		border-radius: 3px 3px 0px 0px !important;
		
		font-weight: bold;
		
		background-color: white;
	}
	
	[role="tab"][aria-selected="true"]:after
	{
		content: "";
		
		position: absolute;
		
		right: 0px;
		bottom: -2px;
		left: 0px;
		
		display: block;
		
		height: 2px;
		
		background-color: inherit;
	}
	
	[role="tabpanel"]
	{
		margin-top: 0px !important;
		border: 1px solid var(--tabWidgetOutlineColor);
		padding: 1rem;
		height: min-content !important;
		
		border-radius: 0px 0px 3px 3px;
		
		background-color: white;
	}
	
	@media not all and (min-width: 48em) {
		.Tabs
		{
			grid-template-columns: 0px 100% 0px;
			grid-template-rows: min-content 0px 1fr;
		}
		
		.Tabs > select
		{
			font-family: "Fira Sans Bold", Arial, Helvetica, sans-serif;
			
			font-weight: 700;
		}
		
		[role="tabpanel"]
		{
			border-radius: 3px;
		}
		
		[role="tabpanel"] .CopyMain
		{
			overflow: unset !important;
		}
	}
</style> <link href="scrollTable-tableTheme-2.0.0.css" rel="preload" integrity="sha256-Zjdnu6KT0uOyuGaLbhKEtQQZtPqrJ/OsJzXgQcrdyIs="

      crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";'

      fetchpriority="low">
    <link href="dynamicTable-tableTheme-1.0.0.css" rel="preload" integrity="sha256-Xa/7gQ2hGk786nSJDfBypeT+uO243tX8gkIAwYLVJYI="

      crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";'

      fetchpriority="low">
    <link href="tlTheme-switchTheme-2.0.0.css" rel="preload" integrity="sha256-55SWYVLsNZDrmVqDUDqsLf84rOJzhY8s6opWIj9sm0g="

      crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";'

      fetchpriority="low">
    <style class="overflowableBlockTheme">
	[data-block-name].OverflowableBlockTheme .CopyMain
	{
		overflow: visible;
	}
</style> <link href="fullPromo-blockTheme-1.0.0.css" rel="preload" integrity="sha256-wdfQvbhP6wypvMDjBZr71nuo3toJ2vi9YdMU5/THZEc="

      crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";'

      fetchpriority="low">
    <style class="repeatingBackgroundTheme">
	.repeatingBackgroundTheme .Background
	{
		background-repeat: repeat !important;
		background-size: auto !important;
	}
</style> <style class="horizontallyRepeatingBackgroundTheme">
	.horizontallyRepeatingBackgroundTheme .Background
	{
		background-repeat: repeat-x !important;
		background-size: auto !important;
	}
</style> <style class="verticallyRepeatingBackgroundTheme">
	.verticallyRepeatingBackgroundTheme .Background
	{
		background-repeat: repeat-y !important;
		background-size: auto !important;
	}
</style> <style class="verticalGradientBackgroundTheme">
	.verticalGradientBackground .Background
	{
		--gradientStartingColor: transparent;
		--gradientEndingColor: transparent;
	}
	
	.verticalGradientBackground .Background[style*="--gradientStartingColor:"][style*="--gradientEndingColor:"]
	{
		background-image: linear-gradient(to bottom, var(--gradientStartingColor), var(--gradientEndingColor)) !important;
	}
	
	.verticalGradientBackground .Background[style*="--gradientStartingColor:"]:not([style*="--gradientEndingColor:"])
	, .verticalGradientBackground .Background:not([style*="--gradientStartingColor:"])[style*="--gradientEndingColor:"]
	{
		--gradientStartingColor: transparent !important;
		--gradientEndingColor: transparent !important;
	}
</style> <link href="storyCard-infoCardTheme-1.1.1.css" rel="preload" integrity="sha256-RQfQRdT2Vs7f0suVjBHGu8GQ3YkZE2tAIqjs6wqjY84="

      crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";'

      fetchpriority="low">
    <style class="indexLink-infoCardTheme-122">
	.indexLinkInfoCardTheme
	{
		position: relative;
		
		display: grid;
		
		grid-template-areas: ". .        .      Chevron	."
							 ". Header   . 		Chevron	."
							 ". .        .      Chevron	."
							 ". CopyMain .      Chevron	."
							 ". .        .      Chevron	.";
		
		grid-template-columns: 2.2222rem 1fr 2rem min-content 2.2222rem;
		grid-template-rows: 2.2222rem auto 0.25rem auto 2.2222rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
	}
	
	.indexLinkInfoCardTheme:after
	{
		content: " ";
		
		grid-area: Chevron;
		
		align-self: center;
		
		width: 1.125rem;
		height: 1.125rem;
		
		pointer-events: none;
	}
	
	.indexLinkInfoCardTheme[style*="--chevronColor: " i]:after
	{
		background-color: var(--chevronColor);
		
		mask-repeat: no-repeat;
		mask-image: url("data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAxNSI+PHRpdGxlPmNoZXZyb24tZG93bl9pY29uPC90aXRsZT48cGF0aCBpZD0iY2hldnJvbi1yaWdodCIgZD0iTTIuODQuMDksMTIsOS4yNSwyMS4xOC4wOSwyNCwyLjkxbC0xMiwxMkwwLDIuOTFaIiBmaWxsPSIjMDA1ZGFhIi8+PC9zdmc+");
		
		transform: rotate(-90deg);
	}
	
	.indexLinkInfoCardTheme:not([style*="--chevronColor: " i]):after
	{
		background-repeat: no-repeat;
		background-image: url("data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAxNSI+PHRpdGxlPmNoZXZyb24tZG93bl9pY29uPC90aXRsZT48cGF0aCBpZD0iY2hldnJvbi1yaWdodCIgZD0iTTIuODQuMDksMTIsOS4yNSwyMS4xOC4wOSwyNCwyLjkxbC0xMiwxMkwwLDIuOTFaIiBmaWxsPSIjMDA1ZGFhIi8+PC9zdmc+");
		background-size: contain;
		
		transform: rotate(-90deg);
	}
	
	.indexLinkInfoCardTheme .Header
	{
		display: flex;
		
		align-items: flex-end;
	}
	
	.indexLinkInfoCardTheme .Header h1
	, .indexLinkInfoCardTheme .Header h2
	, .indexLinkInfoCardTheme .Header h3
	, .indexLinkInfoCardTheme .Header h4
	, .indexLinkInfoCardTheme .Header h5
	, .indexLinkInfoCardTheme .Header h6
	{
		font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif !important;
	}
	
	.indexLinkInfoCardTheme .ImageMain
	{
		display: none;
	}
	
	.indexLinkInfoCardTheme .CopyMain
	{
		margin-top: 0px !important;
	}
	
	.indexLinkInfoCardTheme .CTALinkContainer
	{
		visibility: hidden;
	}
	
	.indexLinkInfoCardTheme .CTALinkContainer a
	{
		position: absolute;
		
		top: 0px;
		right: 0px;
		bottom: 0px;
		left: 0px;
		
		font-size: 0px;
		
		visibility: visible;
		
		user-select: none;
	}
</style> <style class="AlertsBanner-infoCardTheme-111">
	.AlertBannerInfoCardTheme
	{
		--criticalAlertIconBase64: url("data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcC1wYXRoIj48cmVjdCB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiLz48L2NsaXBQYXRoPjwvZGVmcz48dGl0bGU+Y3JpdGljYWxfYWxlcnRfaWNvbjwvdGl0bGU+PGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAtcGF0aCkiPjxnIGlkPSJDb21wb25lbnQiPjxwYXRoIGlkPSJQYXRoXzc4IiBkYXRhLW5hbWU9IlBhdGggNzgiIGQ9Ik0xMiwwQTEyLDEyLDAsMSwxLDAsMTIsMTIsMTIsMCwwLDEsMTIsMFoiIGZpbGw9IiNlZjQxMzUiLz48ZyBpZD0iR3JvdXBfOTEiIGRhdGEtbmFtZT0iR3JvdXAgOTEiPjxwYXRoIGlkPSJQYXRoXzc5IiBkYXRhLW5hbWU9IlBhdGggNzkiIGQ9Ik0xMiwyMC41YTEuOTEsMS45MSwwLDAsMS0xLjktMS45NGgwYTEuOTQsMS45NCwwLDAsMSwzLjg4LS4wN3YuMDdBMiwyLDAsMCwxLDEyLDIwLjVaTTEzLjE5LDE1aC0yLjRMMTAuMDgsNGwzLjc3LS41NFoiIGZpbGw9IiNmZmYiLz48L2c+PC9nPjwvZz48L3N2Zz4=");
		--advisoryAlertIconBase64: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgNDAgNDAiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiNmZjg3MGY7fS5ie2ZpbGw6IzAwMzU1Zjt9PC9zdHlsZT48L2RlZnM+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg2NyAtNDkpIj48cGF0aCBjbGFzcz0iYSIgZD0iTTIwLDBBMjAsMjAsMCwxLDEsMCwyMCwyMCwyMCwwLDAsMSwyMCwwWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODY3IDQ5KSIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDg3NC4xMDYgNTcuNTMzKSI+PHBhdGggY2xhc3M9ImIiIGQ9Ik0xNS4xMjgsOS4yNTFINC42MjZBMi42MjYsMi42MjYsMCwwLDAsMiwxMS44Nzd2NS4yNTFhMi42MjYsMi42MjYsMCwwLDAsMi42MjYsMi42MjZINS45Mzh2NS4yNTFhMS4zMTMsMS4zMTMsMCwwLDAsMS4zMTMsMS4zMTNIOS44NzdhMS4zMTMsMS4zMTMsMCwwLDAsMS4zMTMtMS4zMTNWMTkuNzU0aDMuOTM4bDYuNTY0LDUuMjUxVjRMMTUuMTI4LDkuMjUxTTI3LjYsMTQuNWE1LjgsNS44LDAsMCwxLTMuMjgyLDUuMjUxVjkuMjUxQTUuODUsNS44NSwwLDAsMSwyNy42LDE0LjVaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMiAtNCkiLz48L2c+PC9nPjwvc3ZnPg==");
		--lightChevron: url("data:image/svg+xml;base64,CjxzdmcgaWQ9ImE3MGU2NzUwLWM2Y2UtNDFiOC1hYjY0LWI0ZThhOWQwYWU2ZiIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA4IDEyIj4KICA8dGl0bGU+Y2hldnJvbl9zdmc8L3RpdGxlPgogIDxwYXRoIGQ9Ik0yLDAsLjU5LDEuNDEsNS4xNyw2LC41OSwxMC41OSwyLDEyLDgsNloiIGZpbGw9IiNmZmZmZmYiLz4KICA8cGF0aCBkPSJNLTgtNkgxNlYxOEgtOFoiIGZpbGw9Im5vbmUiLz4KPC9zdmc+Cg==");
		--defaultChevron: url("data:image/svg+xml;base64,PHN2ZyBpZD0iYTcwZTY3NTAtYzZjZS00MWI4LWFiNjQtYjRlOGE5ZDBhZTZmIiBkYXRhLW5hbWU9IkxheWVyIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDggMTIiPgogIDx0aXRsZT5jaGV2cm9uX3N2ZzwvdGl0bGU+CiAgPHBhdGggZD0iTTIsMCwuNTksMS40MSw1LjE3LDYsLjU5LDEwLjU5LDIsMTIsOCw2WiIgZmlsbD0iIzEwNEY4NiIvPgogIDxwYXRoIGQ9Ik0tOC02SDE2VjE4SC04WiIgZmlsbD0ibm9uZSIvPgo8L3N2Zz4=");
		--darkChevron: url("data:image/svg+xml;base64,PHN2ZyBpZD0iYTcwZTY3NTAtYzZjZS00MWI4LWFiNjQtYjRlOGE5ZDBhZTZmIiBkYXRhLW5hbWU9IkxheWVyIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDggMTIiPgogIDx0aXRsZT5jaGV2cm9uX3N2ZzwvdGl0bGU+CiAgPHBhdGggZD0iTTIsMCwuNTksMS40MSw1LjE3LDYsLjU5LDEwLjU5LDIsMTIsOCw2WiIgZmlsbD0iIzAwMzU1RiIvPgogIDxwYXRoIGQ9Ik0tOC02SDE2VjE4SC04WiIgZmlsbD0ibm9uZSIvPgo8L3N2Zz4K");
		
		--borderColor: #DBE5EB;
		--timeTextColor: #757575;
	}
	
	.AlertBannerInfoCardTheme[data-alert-severity="Critical"]
	{
	   --alertIconURL: var(--criticalAlertIconBase64);
	   
	   --closedEffectTextColor: white;
	   --closedEffectBackgroundColor: #E72013;
	   --closedEffectBorderColor: #E72013;
	   --closedEffectAccordionIcon: var(--lightChevron);
	   --closedEffectAccordionIconRotation: rotate(90deg);
	   
	   --openedEffectTextColor: #104F86;
	   --openedEffectBackgroundColor: white;
	   --openedEffectBorderColor: #104F86;
	   --openedEffectAccordionIcon: var(--defaultChevron);
	   
	   --ctaColor: #E72013;
	}
	
	.AlertBannerInfoCardTheme[data-alert-severity="CriticalBundle"]
	{
	   --alertIconURL: var(--criticalAlertIconBase64);
	   
	   --closedEffectTextColor: white;
	   --closedEffectBackgroundColor: #E72013;
	   --closedEffectBorderColor: #E72013;
	   --closedEffectAccordionIcon: var(--lightChevron);
	   --closedEffectAccordionIconRotation: rotate(0deg);
	   
	   --openedEffectTextColor: #104F86;
	   --openedEffectBackgroundColor: white;
	   --openedEffectBorderColor: #104F86;
	   --openedEffectAccordionIcon: var(--defaultChevron);
	   
	   --ctaColor: #E72013;
	}
	
	.AlertBannerInfoCardTheme[data-alert-severity="Advisory"]
	{
	   --alertIconURL: var(--advisoryAlertIconBase64);
	   
	   --closedEffectTextColor: #00355F;
	   --closedEffectBackgroundColor: #FF870F;
	   --closedEffectBorderColor: #FF870F;
	   --closedEffectAccordionIcon: var(--darkChevron);
	   --closedEffectAccordionIconRotation: rotate(90deg);
	   
	   --openedEffectTextColor: #104F86;
	   --openedEffectBackgroundColor: white;
	   --openedEffectBorderColor: #104F86;
	   --openedEffectAccordionIcon: var(--defaultChevron);
	   
	   --ctaColor: #104F86;
	}
	
	.AlertBannerInfoCardTheme[data-alert-severity="AdvisoryBundle"]
	{
	   --alertIconURL: var(--advisoryAlertIconBase64);
	   
	   --closedEffectTextColor: #00355F;
	   --closedEffectBackgroundColor: #FF870F;
	   --closedEffectBorderColor: #FF870F;
	   --closedEffectAccordionIcon: var(--darkChevron);
	   --closedEffectAccordionIconRotation: rotate(0deg);
	   
	   --openedEffectTextColor: #104F86;
	   --openedEffectBackgroundColor: white;
	   --openedEffectBorderColor: #104F86;
	   --openedEffectAccordionIcon: var(--defaultChevron);
	   
	   --ctaColor: #104F86;
	}
	
	html:not([data-page-has-alerts-banner]) .AlertBannerInfoCardTheme
	{
		display: none !important;
	}
	
	.AlertBannerInfoCardTheme
	{
	   border-top: 1px solid var(--borderColor);
	   border-right: 1px solid var(--borderColor);
	   border-left: 1px solid var(--borderColor);
	}
	
	details[open].AlertBannerInfoCardTheme
	, *:not(details).AlertBannerInfoCardTheme
	{
	   border-bottom: 1px solid var(--borderColor);
	}
	
	details.AlertBannerInfoCardTheme .Header > div
	{
	   display: flex;
	   
	   align-items: center;
	   
	   border-bottom: 1px solid var(--borderColor);
	   padding: 1rem;
	}
	
	.AlertBannerInfoCardTheme .Header
	{
		align-self: flex-end;
	}
	
	.AlertBannerInfoCardTheme .Header > div > div
	{
	   margin-right: auto;
	}
	
	.AlertBannerInfoCardTheme .Header > div > div > *
	{
	   margin: 0px !important;
	}
	
	@media (min-width: 48em) {
		details.AlertBannerInfoCardTheme .Header > div:before
		{
		   content: "";
		   
		   flex-grow: 0;
		   flex-shrink: 0;
		   
		   display: inline-block;
		   
		   margin-right: 0.5rem;
		   width: 2.2222rem;
		   height: 2.2222rem;
		   
		   background-image: var(--alertIconURL);
		   background-repeat: no-repeat;
		   background-position: center center;
		   background-size: contain;
		}
	}
	
	.AlertBannerInfoCardTheme time
	{
		color: var(--timeTextColor) !important;
	}
	
	details.AlertBannerInfoCardTheme .Header > div > span
	, *:not(details).AlertBannerInfoCardTheme .CTALinkContainer a
	{
		display: flex;
		
		align-items: center;
		
		margin-left: 0.5rem;
		border-width: 1px;
		border-style: solid;
		padding: 0.4rem 0.5rem;
		
		border-radius: 15px;
	}
	
	details.AlertBannerInfoCardTheme:not([open]) .Header > div > span
	, *:not(details).AlertBannerInfoCardTheme .CTALinkContainer a
	{
		border-color: var(--closedEffectBorderColor);
		
		background-color: var(--closedEffectBackgroundColor);
		color: var(--closedEffectTextColor);
	}
	
	details.AlertBannerInfoCardTheme[open] .Header > div > span
	{
		border-color: var(--openedEffectBorderColor);
		
		background-color: var(--openedEffectBackgroundColor);
		color: var(--openedEffectTextColor);
	}
	
	details.AlertBannerInfoCardTheme .Header > div > span:after
	, *:not(details).AlertBannerInfoCardTheme .CTALinkContainer a:after
	{
	   content: "";
	   
	   display: inline-block;
	   
	   margin-left: 0.4rem;
	   width: 1rem;
	   height: 1rem;
	   
	   background-repeat: no-repeat;
	   background-position: center center;
	   background-size: contain;
	}
	
	details:not([open]).AlertBannerInfoCardTheme .Header > div > span:after
	, *:not(details).AlertBannerInfoCardTheme .CTALinkContainer a:after
	{
	   background-image: var(--closedEffectAccordionIcon);
		
	   transform: var(--closedEffectAccordionIconRotation);
	}
	
	details[open].AlertBannerInfoCardTheme .Header > div > span:after
	{
	   background-image: var(--openedEffectAccordionIcon);
	   
	   transform: rotate(270deg);
	}
	
	details.AlertBannerInfoCardTheme > div:last-child:nth-child(2)
	{
		padding: 1rem;
	}
	
	details.AlertBannerInfoCardTheme .CTALinkContainer
	{
		margin-top: 1rem;
	}
	
	.AlertBannerInfoCardTheme .CTALinkContainer a
	{
		display: inline-block;
	   
		border: 1px solid currentColor;
		padding: 0.4rem 0.75rem;
		
		border-radius: 15px;
		
		color: var(--ctaColor);
		
		text-decoration: none;
	}
	
	*:not(details).AlertBannerInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: ". . . . . . ."
							 ". ImageMain . Header . CTA ."
							 ". ImageMain . CopyMain . CTA ."
							 ". . . . . . .";
							 
		grid-template-columns: 1rem 2.2222rem 0.5rem minmax(min-content, auto) 0.5rem 1fr 1rem;
		grid-template-rows: 1rem min-content min-content 1rem;
	}
	
	*:not(details).AlertBannerInfoCardTheme > *:not(.Header):not(.ImageMain):not(.CopyMain):not(.CTALinkContainer)
	{
		display: none;
	}
	
	*:not(details).AlertBannerInfoCardTheme > .CTALinkContainer
	{
		grid-area: CTA;
		
		justify-self: flex-end;
		align-self: center;
	}
	
	*:not(details).AlertBannerInfoCardTheme > .ImageMain
	{
		align-self: center;
	}
</style> <style class="iconContentInfoCardTheme">
	@media (min-width: 48em) {
		.iconContentInfoCardTheme
		{
			display: grid;
			
			grid-template-areas: ". . . . ."
								 ". Header Header Header ."
								 ". . . . . "
								 ". ImageMain . CopyMain ."
								 ". . . . .";
			
			grid-template-columns: [background-start] 1rem minmax(2.2222rem, 5.5rem) 1rem minmax(auto, 1fr) 1rem [background-end];
			grid-template-rows: [background-start] 1rem min-content 1rem min-content 1rem [background-end];
			
			width: 100%;
			height: 100%;
			
			min-width: calc(320px - 2rem);
		}
	}
	
	@media not all and (min-width: 48em) {
		.iconContentInfoCardTheme
		{
			display: grid;
			
			grid-template-areas: ". . ."
								 ". Header ."
								 ". . ."
								 ". ImageMain ."
								 ". . ."
								 ". CopyMain ."
								 ". . .";
			
			grid-template-columns: [background-start] 1rem minmax(auto, 1fr) 1rem [background-end];
			grid-template-rows: [background-start] 1rem min-content 1rem min-content 1rem min-content 1rem [background-end];
			
			width: 100%;
			height: 100%;
			
			min-width: calc(320px - 2rem);
		}
		
		.iconContentInfoCardTheme .ImageMain
		{
			justify-self: center;
		}
	}
	
	.iconContentInfoCardTheme .CTALinkContainer 
	{
		display: none;
	}
</style> <style class="blogPostInfoCardTheme-100">
	.blogPostInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: ". . ."
							 ". ImageMain ."
							 ". . ."
							 ". Header ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: [background-start] 1rem 1fr 1rem [background-end];
		grid-template-rows: [background-start] 1rem min-content 1rem min-content 1rem min-content 1rem [background-end];
		
		width: 100%;
		height: 100%;
		
		min-width: calc(320px - 2rem);
	}
	
	.blogPostInfoCardTheme .Header
	{
		text-decoration: underline;
	}
	
	.blogPostInfoCardTheme .CTALinkContainer 
	{
		grid-area: Header;
		
		background-color: transparent !important;
		color: transparent !important;
		
		z-index: 1;
	}
	
	.blogPostInfoCardTheme .CTALinkContainer a
	{
		display: block;
		
		height: 100%;
		
		font-size: 0px;
		
		-ms-user-select: none;
		-moz-user-select: none;
		-webkit-user-select: none;
		user-select: none;
	}
</style> <style class="largeiconblogpostinfocardtheme">
	@media (min-width: 48em) {
		.largeIconBlogPostInfoCardTheme
		{
			display: grid;
			
			grid-template-areas: ". . . . ."
							      ". ImageMain . Header ."
							      ". ImageMain . . ."
							      ". ImageMain . CopyMain ."
							      ". . . . .";
			
			grid-template-columns: [background-start] 1rem minmax(2.2222rem, 21.6rem) 1rem minmax(50%, 1fr) 1rem [background-end];
			grid-template-rows: [background-start] 1rem min-content 1rem min-content 1rem [background-end];
			
			width: 100%;
			height: 100%;
			
			min-width: calc(320px - 2rem);
		}
	}
	
	@media not all and (min-width: 48em) {
		.largeIconBlogPostInfoCardTheme
		{
			display: grid;
			
			grid-template-areas: ". . ."
								 ". Header ."
								 ". . ."
								 ". CopyMain ."
								 ". . .";
			
			grid-template-columns: [background-start] 1rem minmax(auto, 1fr) 1rem [background-end];
			grid-template-rows: [background-start] 1rem min-content 1rem min-content 1rem [background-end];
			
			width: 100%;
			height: 100%;
			
			min-width: calc(320px - 2rem);
		}
		
		.largeIconBlogPostInfoCardTheme .ImageMain
		{
			display: none;
		}
	}
	
	.largeIconBlogPostInfoCardTheme .Header
	{
		text-decoration: underline;
	}
	
	.largeIconBlogPostInfoCardTheme .CTALinkContainer 
	{
		grid-area: Header;
		
		background-color: transparent !important;
		color: transparent !important;
		
		z-index: 1;
	}
	
	.largeIconBlogPostInfoCardTheme .CTALinkContainer a
	{
		display: block;
		
		height: 100%;
		
		color: transparent;
		
		-ms-user-select: none;
		-moz-user-select: none;
		-webkit-user-select: none;
		user-select: none;
	}
</style> <style class="BreadCrumbs-navTheme">
	nav[aria-label="Breadcrumbs"]
	{
		margin-top: 1rem;
		margin-bottom: 1rem;
	}
	
	nav[aria-label="Breadcrumbs"] ol
	{
		--chevronWidth: 1.35rem;
		
		display: flex;
		flex-wrap: wrap;
		
		margin: 0px;
		padding-left: 0px !important;
		
		list-style: none;
	}
	
	nav[aria-label="Breadcrumbs"] li
	{
		position: relative;
		
		display: flex;
		
		align-items: center;
		
		margin-bottom: 0.3333rem;
		margin-right: 0.5rem;
		padding: 0px 0.6667rem;
		
		background-color: #005DAA;
		color: white;
	}
	
	nav[aria-label="Breadcrumbs"] li > *
	{
		display: inline-block !important;
		
		max-width: calc(100vw - 5rem);
		
		line-height: 1.15rem;
		
		text-overflow: ellipsis;
		white-space: nowrap;
		
		overflow: hidden;
	}
	
	nav[aria-label="Breadcrumbs"] li:not(:first-child)
	{
		padding-left: 0px;
	}
	
	nav[aria-label="Breadcrumbs"] li:not(:first-child):not(:last-child):before
	, nav[aria-label="Breadcrumbs"] li:not(:last-child):after
	{
		content: " ";
		
		display: inline-block;
		
		border-top: calc(var(--chevronWidth) * 0.7) solid transparent;
		border-bottom: calc(var(--chevronWidth) * 0.7) solid transparent;
		width: 0px;
		height: 0px;
	}
	
	nav[aria-label="Breadcrumbs"] li:not(:first-child):not(:last-child):before
	{
		margin-right: 0.5rem;
		border-left: calc(var(--chevronWidth) * 0.7) solid white;
		
		background-color: transparent;
	}
	
	nav[aria-label="Breadcrumbs"] li:not(:last-child):after
	{
		position: absolute;
		
		left: 100%;
		
		border-left: calc(var(--chevronWidth) * 0.7) solid #005DAA;
		
		z-index: 7000;
	}
	
	nav[aria-label="Breadcrumbs"] li:last-child
	{
		border-top: 1px solid #005DAA;
		border-bottom: 1px solid #005DAA;
		
		background-color: white;
		color: #005DAA;
	}
	
	nav[aria-label="Breadcrumbs"] li:last-child:before
	, nav[aria-label="Breadcrumbs"] li:last-child:after
	{
		content: " ";
		
		display: inline-block;
		
		border-top: 1px solid #005DAA;
		border-right: 1px solid #005DAA;
		width: var(--chevronWidth);
		height: var(--chevronWidth);
		
		border-radius: 1px;
	}
	
	nav[aria-label="Breadcrumbs"] li:last-child:before
	{
		transform: translateX(-50%) rotate(45deg);
	}
	
	nav[aria-label="Breadcrumbs"] li:last-child:after
	{
		position: absolute;
		
		top: 50%;
		right: 0px;
		
		transform: translateX(50%) translateY(-50%) rotate(45deg);
	}
	
	nav[aria-label="Breadcrumbs"] a
	{
		margin-top: 0.25rem;
		margin-bottom: 0.25rem;
		
		color: inherit !important;
		
		text-decoration: none;
	}
	
	nav[aria-label="Breadcrumbs"] li:first-child a
	{
		border-bottom: 1px solid transparent;
	}
	
	nav[aria-label="Breadcrumbs"] li:first-child a:focus
	, nav[aria-label="Breadcrumbs"] li:first-child a:hover
	{
		border-bottom-color: currentColor;
	}
	
	nav[aria-label="Breadcrumbs"] a:focus
	, nav[aria-label="Breadcrumbs"] a:hover
	{
		text-decoration: underline;
		
		outline: none !important;
	}
</style> <link href="listTheme-pipeSeparatedList-1.0.0.css" rel="preload" integrity="sha256-L/oHT70AW4WQ2HcyhNScptSOQY526NrYE44pEy/uAHU="

      crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";'

      fetchpriority="low">
    <link href="tlIconography-1.1.1.css" rel="preload" integrity="sha256-wVLeu1vvzujcW1QjNiLNOcgvOnzIfbMU6P7+SbATGOU="

      crossorigin="anonymous" as="style" onload='this.onload=null; this.rel="stylesheet";'

      fetchpriority="low">
    <link href="expandoAccordionTheme-TYVExpandoAccordion-1.0.0.css" rel="preload"

      integrity="sha256-hF3RejBdQSkvIN90RFSybXBhyzObw0mB7Re/pG+K7E0=" crossorigin="anonymous"

      as="style" onload='this.onload=null; this.rel="stylesheet";' fetchpriority="low">
    <style class="pam-map-styling">
	pam-map
	{
		background-color: #E4E3DF;
	}
</style> <!-- END OF Site Head CSS -->
    <!-- Global Head CSS Tail -->
    <style class="tlhelpers-130">
	.isUpperCase
	{
		text-transform: uppercase;
	}
	
	.isUnderLine
	{
		text-decoration: underline;
	}
	
	.bottomUpWriting
	{
		display: flex;
		
		flex-direction: column;
		
		margin-top: auto;
	}
	
	.onFocusOnlyContent:not(:focus)
	{
		position: absolute;
		
		top: -100%;
	}
	
	@media (min-width: 48em) {
		.smallViewOnlyContent
		{
			display: none !important;
		}
	}
	
	@media not all and (min-width: 48em) {
		.largeViewOnlyContent
		{
			display: none !important;
		}
		
		.flexColumnWhenSmallViewOnlyContent
		{
			flex-direction: column;
		}
	}
	
	@media (min-width: 76.875em) {
		.mobileViewOnlyContent
		{
			display: none !important;
		}
	}
	
	@media not all and (min-width: 76.875em) {
		.desktopViewOnlyContent
		{
			display: none !important;
		}
	}
</style> <!-- END OF Global Head CSS Tail -->
    <!-- Page Head CSS -->
    <!-- END OF Page Head CSS -->
    <!--- Dynamic CSS Variables -->
    <style data-settings-folder="BackgroundColours">
html { 
--transparent: transparent;
--black: black;
--transparentBlack: rgba(0, 0, 0, 0.6);
--burnabyGreen: #006F51; --focusOutlineColor: white;;
--compassBlue: #009DDC; --focusOutlineColor: white;;
--compassBlueDark: #007CAD; --focusOutlineColor: white;;
--white: white; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: white;;
--lightCyan: #E6F4F8;
--navyblue: #00355F; --focusOutlineColor: white; --outsideFocusOutlineColor: #00355F;;
--expoblue: #005DAA; --focusOutlineColor: white; --outsideFocusOutlineColor: #005DAA;;
--lightblue: #0081C6;
--paleblue: #E5EBEF; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: #E5EBEF;;
--paleBlue: #E5EBEF; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: #E5EBEF;;
--skyBlue: #7FCEED;
--water: #C4E9FB;
--green: #00B259;
--translinkPurple: #89199C;
--nearblack: #183152;
--covidTeal: #76DEDD;
--lightgrey: #F2F5F7; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: #F2F5F7;;
--limeGreen: #C1D62F;
--translinkOrange: #F68E1E;
--translinkTeal: #45C1C0; --focusOutlineColor: white;;
--translinkYellow: #FFD200; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: #FFD200;;
--translinkGhostWhite: rgba(255, 255, 255, 0.9);
--summerCampaignMainAlernate: var(--gradientStartingColor); --gradientStartingColor: #EA5889; --gradientEndingColor: #00B0E9;;
--focusOutlineColor: #0081C6;
--gondolaPink: #F16F91;
--t2050Blue: #6698B0;
--t2050Green: #5CACA2;
--t2050Grey: #716586;
--sweepstakesBlue: #C4E5EC;
--tapInToWinCyan: #0099DD;
--summerCampaignMain: var(--gradientStartingColor); --gradientStartingColor: #46BBB9; --gradientEndingColor: #00B0E9;;
--summerCampaignMainReversed: var(--gradientStartingColor); --gradientStartingColor: #00B0E9; --gradientEndingColor: #46BBB9;;
--summerCampaignMainAlernateReversed: var(--gradientStartingColor); --gradientStartingColor: #00B0E9; --gradientEndingColor: #EA5889;;
--googleMapsLoadingColour: #E4E3DF;
--heroImageLoadingColour: #D4ECEF;
}
</style> <style data-settings-folder="ImageBarColours">
html { 
--transparent: transparent;
--green: green;
--limeGreen: #C1D62F;
}
</style> <style data-settings-folder="TextColours">
html { 
--green: #00B259;
--transparent: transparent;
--darkGrey: #757575;
--black: black;
--white: white;
--burnabyGreen: #006F51;
--navyBlue: #00355F;
--expoBlue: #005DAA;
--nearBlack: #183152;
--lightGrey: #F2F5F7;
--errorRed: #D01E11;
}
</style> <!-- END OF Dynamic CSS Variables -->
    <!-- Responsive Website META -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- END OF Responsive Website META -->
    <!-- Analytics META -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@translink">
    <meta property="og:url" content="https://www.translink.ca/etiquette">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Etiquette on Transit">
    <meta property="og:description" content="Learn about guidelines for a more safe and efficient trip.">
    <meta property="og:image" content="https://www.translink.ca/-/media/translink/images/homepage/responsive_site_og_image.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:locale" content="en_CA">
    <meta name="google-site-verification" content="M9C9fMUqauhf4FDnuL4QKimKAFsD3XwG2qKt0OZR8gM">
    <!-- END OF Analytics META -->
    <script class="finish-user-timing-for-dom-parsing">
        ; (() => {
            window.getElapsedTimeInMilliseconds && window.getElapsedTimeInMilliseconds("head-parsing-timer", "time-spent-parsing-html-head");
        })();
    </script>
  </head>
  <body>
    <script class="start-user-timing-for-dom-parsing">
        ; (() => {
            window.startTimer && window.startTimer("body-parsing-timer");
        })();
    </script>
    <!-- Page Beginning JS -->
    <script class="delete-file-inputs-and-labels">
    ; (function () {
        "use strict";
        
        window.findDynamicComponent && window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="file"]'
            , callbackFunction: function (target) {
                "use strict";
                
                //remove label for the input if it exists
                var allTargetInputLabelElements = target.labels;
                allTargetInputLabelElements && allTargetInputLabelElements.forEach(function (curTargetInputLabelElement) {
                    "use strict";
                    
                    curTargetInputLabelElement && curTargetInputLabelElement.remove && curTargetInputLabelElement.remove();
                });
                
                target.removeAttribute("type");  //remove the type, so if target input is clicked, it won't open up a file picker
                target.setAttribute("readonly", "");  //prevent the input from being activated by clicks
                target.setAttribute("disabled", "");  //prevent the input from being activated by clicks
                target.click = function () { };  //remove the click event handler so that nothing will happen on a click on the element or a programmatic click()
                Object.freeze(target);  //prevent reattaching of the native click event handler
                
                //remove the target
                target.remove();
            }
        });
    })();
</script> <script class="datetime-local detection">
    ; (function () {
        "use strict";
        
        var dateTimeLocalInput = document.createElement("input");
        dateTimeLocalInput.setAttribute('type', 'datetime-local');
        
        if (dateTimeLocalInput.type === "datetime-local") {
            document.documentElement.className += " datetimelocal";
        } else {
            document.documentElement.className += " no-datetimelocal";
        }
    })();
</script> <script class="delete-img-elements-that-cant-load-their-images">
    ; (function () {
        "use strict";
        
        window.findDynamicComponent && window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'img[role="presentation"]'
            , callbackFunction: function (target) {
                "use strict";
                
                target.addEventListener("error", function () {
                    "use strict";
                    
                    target.remove();
                });
            }
        });
    })();
</script> <script class="add-placeholder-styling-for-img-elements">
    ; (function () {
        "use strict";
        
        window.findDynamicComponent && window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'img:not([role="presentation"])'
            , callbackFunction: function (target) {
                "use strict";
                
                var PLACEHOLDER_STYLING_ATTRIBUTE = "data-is-not-loaded";
                
                if (target.complete !== true) {
                    target.setAttribute(PLACEHOLDER_STYLING_ATTRIBUTE, true);
                    
                    target.addEventListener("load", function () {
                        "use strict";
                        
                        target.removeAttribute(PLACEHOLDER_STYLING_ATTRIBUTE);
                    });
                }
                
                target.addEventListener("error", function () {
                    "use strict";
                    
                    target.setAttribute(PLACEHOLDER_STYLING_ATTRIBUTE, true);
                });
            }
        });
    })();
</script> <script class="add-aria-current-page">
    ; (function () {
        "use strict";
        
        var curPageURL = new URL(window.location.href);
        
        var curPageURLString = curPageURL && curPageURL.origin + curPageURL.pathname;
        
        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "a"
            , callbackFunction: function (target) {
                "use strict";
                
                var targetURLString = target.hasAttribute("href") && target.getAttribute("href");
                
                //GUARD: do nothing if there is no URL string
                if (!targetURLString || targetURLString === "") {
                    return;
                }
                
                var hasAriaCurrent = target.hasAttribute("aria-current");
                
                if (hasAriaCurrent === false && targetURLString === curPageURLString) {
                    target.setAttribute("aria-current", "page");
                }
            }
        });
    })();
</script><!-- END OF Page Beginning JS -->
    <!-- NoScript -->
    <!-- END OF NoScript -->
    <!-- Analytics NoScript -->
    <!-- Google Tag Manager (noscript) --> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PS4MHSN&gtm_auth=ib9Et0HQ2lWUjFhECqATCA&gtm_preview=env-2&gtm_cookies_win=x"

style="display:none;visibility:hidden" height="0" width="0"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <!-- END OF Analytics NoScript -->
    <style>
    .onFocusOnlyContent:not(:focus)
    {
        position: absolute;

        top: -100%;
    }
</style> <div class="flexContainer maxContentWidth useFontColorInfinitely"> <a

        href="#content" class="onFocusOnlyContent" style="margin-top: 1rem; margin-bottom: 1rem;">Skip
        to content</a> </div>
    <style media="(min-width: 76.875em)">
	.SiteNav
	{
		display: grid;
		
		grid-template-areas: ". .    . SuperNav QuickLinks ."
							 ". .    . .        .          ."
							 ". Logo . SiteNav  SiteNav    ."
							 ". .    . .        .          .";
		
		grid-template-columns: [fullBleed-start] minmax(1rem, 1fr) [background-start] 8rem 3.5rem minmax(calc((59.3333rem - 5.5rem) / 2), calc((72rem - 5.5rem) / 2)) minmax(calc((59.3333rem - 5.5rem) / 2), calc((72rem - 5.5rem) / 2)) [background-end] minmax(1rem, 1fr) [fullBleed-end];
		grid-template-rows: [background-start] min-content 1rem min-content 1rem [background-end];	
	}
	
	.SiteNav:before
	{
		content: " ";
		
		grid-column: 1 / -1;
		grid-row: 1 / 2;
		
		background-color: #00355F;
	}
	
	.SiteNav > *:first-child
	{
		grid-area: Logo;
	}
	
	.SiteNav > *:nth-child(2)
	{
		grid-area: SuperNav;
	}
	
	.SiteNav > *:nth-child(3)
	{
		grid-area: QuickLinks;
		
		align-self: center;
	}
	
	.SiteNav > *:nth-child(4)
	, .SiteNav > *:nth-child(5)
	{
		grid-area: SiteNav;
		
		align-self: center;
	}
	
	.SiteNav > *:nth-child(2) *
	, .SiteNav > *:nth-child(3) *
	{
		color: white !important;
	}
	
	.SiteNav > *:nth-child(5)
	{
		grid-area: SiteNav;
		
		align-self: center;
	}
	
	nav[aria-label="Account Navigation"] a
	{
		display: inline-block;
		
		height: 1.2778rem; /* CLS: prevents 1px worth of CLS by setting the height to 23px instead of it defaulting to 24px */
	}
</style> <style media="not all and (min-width: 76.875em)">
	.SiteNav
		{
			display: flex;
			
			flex-wrap: wrap;
			
			padding-right: 1rem;
			padding-left: 1rem;
		}
		
		.SiteNav > nav[aria-label="Super Navigation"]
		, .SiteNav > nav[aria-label="Account Navigation"]
		, .SiteNav > * > nav[aria-label="Account Navigation"]:not(.mobileViewOnlyContent)
		{
			display: none !important;
		}
</style> <style>
	.hasFullBleedWings
	{
		position: relative;
	}
	
	.hasFullBleedWings:before
	, .hasFullBleedWings:after
	{
		content: " ";
		
		position: absolute;
		
		top: 50%;
		
		width: 1rem;
		height: 100%;
		
		background-color: inherit;
	}
	
	.hasFullBleedWings:before
	{
		left: 0px;
		
		transform: translateX(-100%) translateY(-50%);
	}
	
	.hasFullBleedWings:after
	{
		right: 0px;
		
		transform: translateX(100%) translateY(-50%);
	}
</style> <style>
	#DesktopSiteSearchbarButton
	{
		--focusOutlineColor: white;
	}
	
	#DesktopSiteSearchbarButton:focus
	, #DesktopSiteSearchbarButton:hover
	, #DesktopSiteSearchbarButton[aria-expanded="true"]
	{
		background-color: #005DAA !important;
	}
</style> <style>
	#DesktopSiteSearchbar
	{
		display: grid;
		
		grid-template-columns: [fullBleed-start] minmax(1rem, 1fr) [background-start] 8rem 3.5rem minmax(calc((59.3333rem - 0.5972rem - 5.5rem) / 2), calc((72rem - 0.5972rem - 5.5rem) / 2)) minmax(calc((59.3333rem - 0.5972rem - 5.5rem) / 2), calc((72rem - 0.5972rem - 5.5rem) / 2)) 0.5972rem [background-end] minmax(1rem, 1fr) [fullBleed-end];
		
		background-color: #005DAA;
	}
	
	#DesktopSiteSearchbar > form
	{
		grid-column: 4 / 6;
	}
	
	html:not(.noFocus) #DesktopSiteSearchbar input:focus:not(:hover):not(:active)
	{
		outline: 2px solid var(--focusOutlineColor, #0081C6);
		outline-offset: 0.3888rem;
	}
</style><search id="DesktopSiteSearchbar" class="desktopViewOnlyContent useFontColorInfinitely useButtonInfinitely useFormFieldInfinitely"

      style="padding-top: 1.5rem; padding-bottom: 2rem; --focusOutlineColor: white;"

      hidden="">
      <form method="GET" action="/search" class="flexContainer"> <label style="flex-grow: 1; color: white;">
          Search <input name="term" placeholder="Search for transit schedules, projects, and documents..."

            list="searchQuerySuggestions" type="search"> </label> <button type="submit"

          class="bottomAlignedItem" style="margin-top: 0px; margin-left: 1rem; padding-top: 0.78rem; padding-bottom: 0.78rem; flex-shrink: 0; background-color: white; color: #005DAA;">
          <img src="-/media/translink/icons/shared/magnifier_blue.svg" loading="lazy"

            decoding="async" alt="" height="22" width="22"><span class="largeViewOnlyContent"

            style="margin-left: 0.5rem;">Search</span> </button> <label for="DesktopSiteSearchbarButton"

          tabindex="0" class="flexContainer verticallyCenteredContent" style="align-self: flex-start; margin-top: 0px; margin-left: 2rem; transform: translateY(-50%);">
          <span style="font-size: 0px; color: white;">Close</span> <img alt=""

            src="-/media/translink/icons/shared/close_white.svg?h=24px&amp;w=24px&amp;hash=81317ED5367BDE3576A61D4873B552FB"

            loading="lazy" decoding="async" style="width: 1.3334rem;" height="20"

            width="20"> </label> </form>
    </search>
    <header class="SiteNav noContentSpacing useFontColorInfinitely"> <a class="SiteLogo"

        href="/" title="Link to 'Home' page on this site"> <img src="-/media/translink/logos/translink_logo.svg"

          alt="TransLink" class="TransLinkLogo largeViewOnlyContent" height="63"

          width="144"> </a></header>
    <header><br>
    </header>
    <script>
	; (() => {
		var SEARCHBAR_ACCORDION_BUTTON_ID = "DesktopSiteSearchbarButton"; 
		
		var searchbarAccordionButton = document.getElementById(SEARCHBAR_ACCORDION_BUTTON_ID);
		
		var accordionBodySelector = searchbarAccordionButton.hasAttribute("aria-controls") && searchbarAccordionButton.getAttribute("aria-controls");
					
		var accordionBody = accordionBodySelector && document.getElementById(accordionBodySelector);
		
		var accordionBodyFirstSelectableElement = accordionBody && accordionBody.querySelector('a, button, select, option, input, summary, [tabindex]:not([tabindex=""]):not([tabindex="0"]):not([tabindex*="-"])');  //??? enhanced version used by virtualcursor, consider backporting
		
		//when pressing TAB on the accordion button, we must focus the first selectable element if the accordion is open
		searchbarAccordionButton && searchbarAccordionButton.addEventListener("keydown", e => {
			var isExpanded = searchbarAccordionButton.getAttribute("aria-expanded");
			
			var pressedKey = e.keyCode;
			var isShiftKeyPressed = e.shiftKey;
			
			if (pressedKey === KEYCODE.TAB && isShiftKeyPressed === false) {
				if (isExpanded === "true") {
					//get all focusable elements
					
					accordionBodyFirstSelectableElement && window.requestAnimationFrame(() => {  //for some reason, text input elements (at least those) need to be focused on the next cycle, using RAF to delay the focus until the next cycle
						accordionBodyFirstSelectableElement.focus();
					});
				}
			}
		});
		
		//when pressing shift-tab on the first element of the searchbar accordion, you must focus on the accordion-button
		accordionBodyFirstSelectableElement && accordionBodyFirstSelectableElement.addEventListener("keydown", e => {
			var pressedKey = e.keyCode;
			var isShiftKeyPressed = e.shiftKey;
			
			if (pressedKey === KEYCODE.TAB && isShiftKeyPressed === true) {
				searchbarAccordionButton && window.requestAnimationFrame(() => {  //for some reason, text input elements (at least those) need to be focused on the next cycle, using RAF to delay the focus until the next cycle
					searchbarAccordionButton.focus();
				});
			}
		});
		
		var searchbarAccordionCloseButton = document.querySelector('[for="' + SEARCHBAR_ACCORDION_BUTTON_ID + '"]');
		
		searchbarAccordionCloseButton && searchbarAccordionCloseButton.addEventListener("keydown", e => {
			var pressedKey = e.keyCode;
			
			switch (pressedKey) {
				case KEYCODE.TAB:
					; (() => {
						searchbarAccordionButton && searchbarAccordionButton.focus();
					})();
					
					break;
				case KEYCODE.ENTER:
					; (() => {
						searchbarAccordionButton && searchbarAccordionButton.click();
					})();
					
					break;
			}
		});
	})();
</script> <script class="generate-sitenav">
	; (async () => {
		var AUTHED_MODULE_URL_STRING = "/js/authed.mjs";
		
		var OPEN_HAMBURGER_MENU_ON_PAGELOAD_HASH = "#nav"
		
		var hamburgerMenuButton = document.querySelector(".HamburgerMenuButton");
		
		if (hamburgerMenuButton && window.location.hash === OPEN_HAMBURGER_MENU_ON_PAGELOAD_HASH) {
			hamburgerMenuButton.setAttribute("aria-expanded", true);
		}
		
		var curURLSubpath = (new URL(window.location)).pathname;
		
		var isPlansAndProjectsPage = curURLSubpath === "/plans-and-projects" || curURLSubpath.startsWith("/plans-and-projects/");
		
		var isAboutPage = (() => {
			var output = false;
			
			//??? replace with sitecore linkrefs?
			var allAboutPageURLs = [
				"/about-us"
				, "/accountability-centre"
				, "/business"
				, "/customer-service"
				, "/feedback"
				, "/media"
				, "/news"
				, "/podcast"
				, "/operating-companies"
			];
			
			output = allAboutPageURLs && allAboutPageURLs.some(curAboutPageURL => {
				return curURLSubpath === curAboutPageURL || curURLSubpath.startsWith(curAboutPageURL + "/");
			});
			
			return output;
		})();
		
		window.SiteNav && window.SiteNav.isInited && window.SiteNav.load({
			targetSelector: 'nav[aria-label="Super Navigation"]'
			, apiMenuID: "5DD4374A-9C87-46AF-AC35-630B7C4A2299"
			, apiMenuToken: "59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8"
			, cacheKey: "SuperNavHeaderData"
			, onAfterLoadSuccess: containerSelector => {
				//GUARD: do nothing if there is no way to select the containers
				if (!containerSelector) {
					return;
				}
				
				var allLinks = [];
				
				var allContainers = containerSelector && document.querySelectorAll(containerSelector);
				
				allContainers && allContainers.forEach(curContainer => {
					var curSiteNav = curContainer.querySelector("ul");
					
					//GUARD: do nothing if this container has no menu links
					if (!curSiteNav) {
						return;
					}
					
					var newActiveSuperNavPage;
					
					if (isAboutPage) {
						newActiveSuperNavPage = curSiteNav.children && curSiteNav.children[2];
					} else if (isPlansAndProjectsPage) {
						newActiveSuperNavPage = curSiteNav.children && curSiteNav.children[1];
					} else {
						newActiveSuperNavPage = curSiteNav.children && curSiteNav.children[0];
					}
					
					if (newActiveSuperNavPage && newActiveSuperNavPage.classList) {
						newActiveSuperNavPage.classList.add("activeSuperNav");
						
						var newActiveSuperNavPageLinkElement = newActiveSuperNavPage.querySelector("a");
						
						newActiveSuperNavPageLinkElement && newActiveSuperNavPageLinkElement.focus();
					}
					
					var isMobileSuperNav = curContainer.classList.contains("mobileViewOnlyContent");
					
					isMobileSuperNav && curContainer.querySelectorAll("a").forEach(curLink => {
						allLinks.push(curLink);
					});
				});
				
				allLinks && allLinks.forEach(curLink => {
					var curHref = curLink.hasAttribute("href") && curLink.getAttribute("href");
					
					curHref && curLink.setAttribute("href", curHref + OPEN_HAMBURGER_MENU_ON_PAGELOAD_HASH);
				});
			}
		});
		
		var allMainNavElements = document.querySelectorAll('nav[aria-label="Main Navigation"]');
		
		if (allMainNavElements) {
			if (isPlansAndProjectsPage) {
				allMainNavElements.forEach(curMainNavElement => {
					curMainNavElement.setAttribute("data-sitenav-menu-id", "1CA8BBE2-77B0-4289-A9D8-82FB9CA5416F");
					curMainNavElement.setAttribute("data-sitenav-menu-token", "59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8");
				});
			} else if (isAboutPage) {
				allMainNavElements.forEach(curMainNavElement => {
					curMainNavElement.setAttribute("data-sitenav-menu-id", "7FF39EED-BF95-4785-B326-377FE809A4B9");
					curMainNavElement.setAttribute("data-sitenav-menu-token", "59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8");
				});
			} else {
				allMainNavElements.forEach(curMainNavElement => {
					curMainNavElement.setAttribute("data-sitenav-menu-id", "7CB6E8FC-7592-4701-A2EB-448805B8E75A");
					curMainNavElement.setAttribute("data-sitenav-menu-token", "59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8");
				});
			}
		}
		
		var allAccountNavElements = Array.from(document.querySelectorAll('nav[aria-label="Account Navigation"]'));
		
		//GUARD: do nothing if there are no sitenav containers
		if (!allAccountNavElements || allAccountNavElements.length === 0) {
			return;
		}
		
		var authedModuleURL = AUTHED_MODULE_URL_STRING && new URL(AUTHED_MODULE_URL_STRING, document.location.origin);
		
		var { fetchIsAuthenticated, fetchAuthID, fetchAuthName } = authedModuleURL && await import(authedModuleURL);
		
		var [isAuthenticated, authID, authName] = await Promise.all([fetchIsAuthenticated, fetchAuthID, fetchAuthName]);
		
		if (isAuthenticated && authID && authName && authName.startsWith("sitecore\\") === false) {
			//create account nav for authenticated users
			window.SiteNav && window.SiteNav.isInited && window.SiteNav.load({
				targets: allAccountNavElements
				, apiMenuID: "637D90D6-22E6-4729-8EBA-987B9A141FC8"
				, apiMenuToken: "59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8"
				, cacheKey: "AccountNavHeaderData"
				, onAfterLoadSuccess: async (containerSelector, containers) => {
					var logoutAPIURLString = "/auth/signout";
					var logoutAPIURL = logoutAPIURLString && new URL(logoutAPIURLString, document.location.origin);
					
					if (logoutAPIURL) {
						var helloTextContainer = document.createElement("li");
						helloTextContainer.setAttribute("class", "flexContainer verticallyCenteredContent");
						
						var helloTextElement = document.createElement("p"); //??? this element shouldn't be added until 'transit-alerts-profile-display-name' has been populated with the right display name.  By not adding it so early, we can use CSS to detect that the first link container (the parent LI) is empty, so the next link container doesn't have to render the vertical-pipe-divider.  Note that this is harder than it sounds because the link container is actually cloned
						helloTextElement.setAttribute("style", "line-height: 23px;");  //NOTE: hardcode to 23px because that matches <a> line-height
						
						var nameElement = document.createElement("transit-alerts-profile-display-name");
						nameElement.setAttribute("data-is-read-only", true);
						nameElement.setAttribute("data-is-inheriting-font", true);
						nameElement.setAttribute("data-prefix-text", "Hi ");
						nameElement.setAttribute("data-show-validation-requirements", false);
						
						var nameElementSkeletonTextElement = document.createElement("span");  //??? better variable name needed?
						nameElementSkeletonTextElement.setAttribute("class", "smallViewOnlyContent");
						nameElementSkeletonTextElement.textContent = "Hi ";
						
						nameElement.append(nameElementSkeletonTextElement);
						
						helloTextElement.append(nameElement);
						
						helloTextContainer.append(helloTextElement);
						
						var logoutButtonContainer = document.createElement("li");
						logoutButtonContainer.setAttribute("class", "flexContainer verticallyCenteredContent");
						
						var logoutButton = document.createElement("button");
						logoutButton.setAttribute("type", "submit");
						logoutButton.setAttribute("data-type", "unstyledButton");
						logoutButton.setAttribute("data-faux-type", "link");
						logoutButton.setAttribute("form", "AccountLogout");
						logoutButton.textContent = "Sign Out";
						
						logoutButtonContainer.append(logoutButton);
						
						var logoutForm = document.createElement("form");
						logoutForm.setAttribute("id", "AccountLogout");
						logoutForm.setAttribute("name", "AccountLogout");
						logoutForm.setAttribute("method", "POST");
						logoutForm.setAttribute("action", logoutAPIURL);
						
						document.documentElement.append(logoutForm);
						
						containers.forEach(curContainer => {
							var listContainer = curContainer.querySelector("ul");
							
							//GUARD: do nothing if no <ul> is found
							if (!listContainer) {
								return;
							}
							
							listContainer.prepend(helloTextContainer.cloneNode(true));
							listContainer.append(logoutButtonContainer.cloneNode(true));
						});
					}
					
					allAccountNavElements.forEach(curAccountNavElement => {
						curAccountNavElement.removeAttribute("hidden");
					});
				}
			});
			
			//hide the entire nav so that we show all the links at once instead of half of them immediately and the other half after the user account is found
			allAccountNavElements.forEach(curAccountNavElement => {
				curAccountNavElement.setAttribute("hidden", "");
			});
		} else {
			//create account nav for unauthenticated users
			allAccountNavElements.forEach(curAccountNavElement => {
				curAccountNavElement.setAttribute("data-sitenav-menu-id", "157F6AD2-047C-4F98-BB45-86461DF0F494");
				curAccountNavElement.setAttribute("data-sitenav-menu-token", "59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8");
			});
		}
	})();
</script> <style class="setCustomHeightForBannerAlertsOnPageLoad">
    .bannerAlerts[style*="--customHeightInPXForPageLoad:"]:not([style*="--customHeightInPXForPageLoad: 0px;"]):empty
    {
        display: block !important;

        height: var(--customHeightInPXForPageLoad, auto);
    }
</style> <section class="bannerAlerts contentSpacingLayout maxContentWidth" style="padding-top: 1rem; padding-bottom: 1rem;"></section>
    <main id="content">
      <style class="narrowFlexColumnBlockLayout-large-100" media="(min-width: 48em)">
	.NarrowFlexColumnBlockLayout
	{
		--blockPaddingTopRow: 3.3333rem;
		--blockPaddingBottomRow: 3.3333rem;
		
		grid-template-areas: ". . . . ."
							 ". . Header . ."
							 ". . . . ."
							 ". . ImageMain . ."
							 ". . . . ."
							 ". . CopyMain . ."
							 ". . . . .";
		
		grid-template-columns: [fullBleed-start] 1fr [background-start] minmax(1rem, 18.8889rem) minmax(40.7222rem, 42.2222rem) minmax(1rem, 18.8889rem) [background-end] 1fr [fullBleed-end];
		grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content 1rem min-content 1rem min-content var(--blockPaddingBottomRow) [background-end];
	}
	
	.NarrowFlexColumnBlockLayout.noSidePadding
	{
		grid-template-areas: ". . . . ."
							 ". Header Header Header ."
							 ". . . . ."
							 ". CopyMain CopyMain CopyMain ."
							 ". . . . .";
	}
	
	.NarrowFlexColumnBlockLayout > *:not(.Background):not(.CopyMain):not(.ImageMain):not(.Header)
	{ 
		display: none;
	}
	
	.NarrowFlexColumnBlockLayout > .Header:empty ~ .ImageMain
	{
		grid-row: 2 / 5;
	}
	
	.NarrowFlexColumnBlockLayout > .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.NarrowFlexColumnBlockLayout > .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
	}
</style> <style class="narrowFlexColumnBlockLayout-small-100" media="not all and (min-width: 48em)">
	.NarrowFlexColumnBlockLayout
	{
		--blockPaddingColumn: 1rem;
		
		--blockPaddingTopRow: 3.3333rem;
		--blockPaddingBottomRow: 3.3333rem;
		
		grid-template-areas: ". . ."
							 ". Header ."
							 ". . ."
							 ". ImageMain ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: [background-start] var(--blockPaddingColumn) 1fr var(--blockPaddingColumn) [background-end];	
		grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content 1rem min-content 1rem min-content var(--blockPaddingBottomRow) [background-end];
	}
	
	.NarrowFlexColumnBlockLayout > *:not(.Background):not(.CopyMain):not(.ImageMain):not(.Header)
	{ 
		display: none;
	}
	
	.NarrowFlexColumnBlockLayout > .Header:empty ~ .ImageMain
	{
		grid-row: 2 / 5;
	}
	
	.NarrowFlexColumnBlockLayout > .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.NarrowFlexColumnBlockLayout > .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
	}
</style> <div data-block-name="Etiquette on Transit" class=" gridContainer NarrowFlexColumnBlockLayout minimalTopPadding noBottomPadding      "

        style="color: #183152;">
        <div role="presentation" class="Background" style="background-repeat: no-repeat; background-size: cover; background-color: white; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: white;;"></div>
        <div role="presentation" class="BgOverlay"></div>
        <header class="Header">
          <h1>Etiquette on Transit</h1>
        </header>
        <section class="ImageTop"></section>
        <section class="ImageMain"><img src="-/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_backpack.png?h=600&amp;w=1200&amp;la=en&amp;hash=3003BD5B73E01AA470E8C4EC5EED0178"

            sizes="(min-width: 90em) 1440px, 100vw" alt="Illustration of passenger with backpack and headphone"

            srcset="-/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_backpack-1.png 283w?w=283&amp;hash=3C7FA7ADA8C6499595533D6D7F505B52 283w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_backpack-2.png 678wg?w=678&amp;hash=BFB91792F5D00000478D26B246E096B3 678w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_backpack-3.png 768wg?w=768&amp;hash=ECCD094EBFBF2800353E72548560EC3B 768w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_backpack-4.png 1440w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_backpack-4.png 1920w"

            style="--imageDefaultWidthInPx: 1200; --imageDefaultHeightInPx: 600;"

            height="600" width="1200"></section>
        <section class="CopyMain">
          <p>Taking transit means sharing space. Even the simplest actions can
            make a trip more pleasant for everyone.</p>
        </section>
        <aside class="Sidebar">
          <section>
            <div class="contentSpacingLayout contentItem"> </div>
          </section>
        </aside>
        <div class="Pagination"></div>
        <div role="presentation" class="ImageBar" style="background-color: transparent;"></div>
        <section class="ImageBottom"></section>
        <hr class="HorizontalRuler"> </div>
      <div data-block-name="On this page" class=" gridContainer NarrowFlexColumnBlockLayout minimalTopPadding minimalBottomPadding      "

        style="color: #183152;">
        <div role="presentation" class="Background" style="background-repeat: no-repeat; background-size: cover; background-color: white; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: white;;"></div>
        <div role="presentation" class="BgOverlay"></div>
        <header class="Header"></header>
        <section class="ImageTop"></section>
        <section class="ImageMain"></section>
        <section class="CopyMain">
          <div class="contentSpacingLayout contentItem">
            <style class="plaintext-infocardtheme-110">
	.plainTextInfoCardTheme
	{
		--leftPadding: 1rem;
		--rightPadding: 1rem;
		
		display: grid;
		
		grid-template-areas: ". . ."
							 ". Header ."
							 ". . ."
							 ". Image ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: var(--leftPadding) calc(100% - var(--leftPadding) - var(--rightPadding)) var(--rightPadding);
		grid-template-rows: 1rem min-content 1rem min-content 1rem min-content 1rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
	}
	
	.plainTextInfoCardTheme .Header
	{
		grid-area: Header;
	}
	
	.plainTextInfoCardTheme .ImageMain
	{
		grid-area: Image;
	}
	
	.plainTextInfoCardTheme .CopyMain
	{
		grid-area: CopyMain;
		
		margin-top: 0px !important;
	}
	
	.plainTextInfoCardTheme .CTALinkContainer
	{
		display: none;
	}
	
	.plainTextInfoCardTheme .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.plainTextInfoCardTheme .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
		
		display: flex;
		
		flex-direction: column;
		justify-content: center;
	}
</style> <div data-infocard-name="On this page" class=" layoutItem fullWidth ">
              <article data-infocard-name="On this page" class="InfoCard plainTextInfoCardTheme layoutItemContent"

                style="color: #183152; background-color: #F2F5F7; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: #F2F5F7;; --chevronColor: #005DAA;">
                <div role="presentation" class="Background"> </div>
                <header class="Header">
                  <h3>On this page</h3>
                </header>
                <section class="ImageMain"></section>
                <section class="CopyMain">
                  <ul class="TableOfContents">
                  </ul>
                </section>
                <div class="CTALinkContainer " style="color: white; background-color: #005DAA; --focusOutlineColor: white; --outsideFocusOutlineColor: #005DAA;;">
                  <a href="/home"></a> </div>
              </article>
            </div>
          </div>
        </section>
        <aside class="Sidebar">
          <section>
            <div class="contentSpacingLayout contentItem"> </div>
          </section>
        </aside>
        <div class="Pagination"></div>
        <div role="presentation" class="ImageBar" style="background-color: transparent;"></div>
        <section class="ImageBottom"></section>
        <hr class="HorizontalRuler"> </div>
      <div data-block-name="Etiquette While on Transit" class=" gridContainer NarrowFlexColumnBlockLayout     fullBleed   "

        style="color: #183152;">
        <div role="presentation" class="Background" style="background-repeat: no-repeat; background-size: cover; background-color: transparent;"></div>
        <div role="presentation" class="BgOverlay"></div>
        <header class="Header">
          <h2>Etiquette While on Transit</h2>
        </header>
        <section class="ImageTop"></section>
        <section class="ImageMain"></section>
        <section class="CopyMain">
          <p>For the safety and comfort of everyone on board, please keep the
            following in mind.</p>
          <details>
            <summary role="button" aria-expanded="false">
              <h3>General Tips While on Transit</h3>
            </summary>
            <ul>
              <li>
                <p>Seats are for people — not feet, luggage, or bags.</p>
              </li>
              <li>
                <p>Remove your backpack, especially during busy times, to make
                  room for other passengers.</p>
              </li>
              <li>
                <p>Keep noise (including conversations, phone calls, and
                  personal music devices) to a minimum.</p>
              </li>
              <li>
                <p>Please be considerate with personal hygiene. Avoid strong
                  scents to prevent allergies or asthma in other riders.</p>
              </li>
              <li>
                <p>Please don’t eat or drink on board to help keep transit
                  clean.</p>
              </li>
              <li>
                <p>Wait for passengers to exit before you board.</p>
              </li>
              <li>
                <p>Respect personal space – keep a comfortable distance from
                  other riders when possible.</p>
              </li>
              <li>
                <p> Always keep your proof of payment — for example, a ticket,
                  or your Compass Card — with you. Be ready to show a uniformed
                  employee if asked.</p>
              </li>
            </ul>
          </details>
          <details>
            <summary role="button" aria-expanded="false">
              <h3>Priority Seating</h3>
            </summary>
            <p><img src="-/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_priority_seating.png"

                alt="Illustration of one passenger offering a seat to a pregnant woman"

                style="width: 100%; --imageDefaultWidthInPx: 1200; --imageDefaultHeightInPx: 600;"

                srcset="-/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_priority_seating-1.png 283w?w=283&amp;hash=9103A5AF0C106CDDB5E1BA8F71D87DFE 283w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_priority_seating-2.png 678wg?w=678&amp;hash=E905485F6090565A91700F6DA72509CD 678w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_priority_seating-3.png 768wg?w=768&amp;hash=C397E1784A74CF04E620B301865CB5A3 768w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_priority_seating.png 1440w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_priority_seating.png 1920w"

                loading="lazy" decoding="async" sizes="(min-width: 90em) 1440px, 100vw"

                height="600" width="1200"></p>
            <p>Seats closest to the doors are for passengers with mobility
              needs. This includes the following groups:</p>
            <ul>
              <li>
                <p>people with disabilities</p>
              </li>
              <li>
                <p>pregnant people</p>
              </li>
              <li>
                <p>older people</p>
              </li>
              <li>
                <p>people with injuries</p>
              </li>
            </ul>
            <p>Please remember that not all disabilities are visible. If someone
              asks for your seat, please take them at their word and give up
              your seat.</p>
            <p>If you are in a priority seat, be aware of those around you. Look
              up at stops to see if someone needs a seat. </p>
            <p>For more on travellers with accessibility needs, visit <a href="/rider-guide/transit-accessibility"

                title="Links to the 'Accessibility on Transit' page on this site - opens in the same window"

                target="_self">Accessibility on Transit</a>.</p>
          </details>
          <details>
            <summary role="button" aria-expanded="false">
              <h3>Smoking and Vaping</h3>
            </summary>
            <p>TransLink’s rules prohibit smoking and vaping on TransLink
              property and vehicles. Additionally, Customers are reminded to
              comply with all applicable laws, bylaws and regulations relating
              to smoking and vaping of tobacco and cannabis products, including
              the <a rel="noopener noreferrer" href="https://www.bclaws.gov.bc.ca/civix/document/id/complete/statreg/96451_01"

                target="_blank" title="Links to Tobacco and Vapour Products Control Act (BC) on bclaws.ca - opens in a new window">Tobacco
                and Vapour Products Control Act (BC)</a> and regulations, the <a

                rel="noopener noreferrer" href="https://www.bclaws.gov.bc.ca/civix/document/id/complete/statreg/18029"

                target="_blank" title="Links to Cannabis Control and Licensing Act (BC)) on bclaws.ca - opens in a new window">Cannabis
                Control and Licensing Act (BC)</a> and regulations, and the
              municipal bylaws of the municipalities in which TransLink provides
              transit services. Please be considerate of your fellow passengers
              and members of the public and avoid smoking and vaping where
              prohibited.</p>
          </details>
          <details>
            <summary role="button" aria-expanded="false">
              <h3>Travelling on the West Coast Express</h3>
            </summary>
            <p>West Coast Express (WCE) services have their own on-board rules,
              including:</p>
            <ul>
              <li>
                <p>Stow carry-on items beneath your seat.</p>
              </li>
              <li>
                <p>Be careful when moving through the train, especially on
                  stairways and between cars.</p>
              </li>
              <li>
                <p>Familiarize yourself with the exit routes and location of
                  onboard emergency equipment.</p>
              </li>
              <li>
                <p>Follow instructions from conductors and/or West Coast Express
                  staff.</p>
              </li>
            </ul>
          </details>
        </section>
        <aside class="Sidebar">
          <section>
            <div class="contentSpacingLayout contentItem"> </div>
          </section>
        </aside>
        <div class="Pagination"></div>
        <div role="presentation" class="ImageBar" style="background-color: transparent;"></div>
        <section class="ImageBottom"></section>
        <hr class="HorizontalRuler"> </div>
      <div data-block-name="Entering and Exiting Transit" class=" gridContainer NarrowFlexColumnBlockLayout minimalTopPadding       "

        style="color: #183152;">
        <div role="presentation" class="Background" style="background-repeat: no-repeat; background-size: cover; background-color: white; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: white;;"></div>
        <div role="presentation" class="BgOverlay"></div>
        <header class="Header">
          <h2>Entering and Exiting Transit</h2>
        </header>
        <section class="ImageTop"></section>
        <section class="ImageMain"><img src="-/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_entering_exiting.webp?h=600&amp;w=1200&amp;la=en&amp;extension=webp&amp;hash=BCB40E8D2038638474F0FE7E633DD609"

            sizes="(min-width: 90em) 1440px, 100vw" alt="Passengers getting off the bus at bus bay 2"

            srcset="-/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_entering_exiting-1.webp 283w?w=283&amp;extension=webp&amp;hash=4976918293A1ACA9DF3667C673F8BCFA 283w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_entering_exiting-2.webp 678wp?w=678&amp;extension=webp&amp;hash=A70E862C4448830CC485820EAF8B25B4 678w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_entering_exiting-3.webp 768wp?w=768&amp;extension=webp&amp;hash=1E0F0D2304B1469F8525BF8653F59313 768w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_entering_exiting-4.webp 1440wp?extension=webp 1440w, -/media/translink/images/rider-info/etiquette-on-transit/ct_etiquette_entering_exiting-4.webp 1920wp?extension=webp 1920w"

            style="--imageDefaultWidthInPx: 1200; --imageDefaultHeightInPx: 600;"

            loading="lazy" decoding="async" height="600" width="1200"></section>
        <section class="CopyMain">
          <p>When entering and exiting transit, try to keep the following in
            mind:</p>
          <p><strong>Escalators</strong></p>
          <ul>
            <li>
              <p>When using a station escalator, stand on the right to let
                others pass.</p>
            </li>
            <li>
              <p>Please use the elevator if you're travelling with a mobility
                device, stroller, bicycle, luggage, or other large item(s).</p>
            </li>
          </ul>
          <p><strong>SkyTrain and West Coast Express</strong></p>
          <ul>
            <li>
              <p>Tap your card, ticket, or mobile wallet to the card reader at
                the gate (or validator for West Coast Express) as you enter and
                exit the station to validate your fare. </p>
            </li>
            <li>
              <p>Keep the doors clear. </p>
            </li>
            <li>
              <p>Let others get off before you get on the train.</p>
            </li>
            <li>
              <p>Don’t hold the doors open, as this causes delays and could even
                shut the whole train down.</p>
            </li>
          </ul>
          <p><strong>Bus</strong></p>
          <ul>
            <li>
              <p>Tap the card reader when you enter the bus.&nbsp;You do not
                need to tap out of the bus.</p>
            </li>
            <li>
              <p>If paying with coins, put exact change into the farebox.&nbsp;</p>
              <ul>
                <li>
                  <p> When paying cash on buses, you will be given a paper bus
                    transfer. Show this to the operator when you transfer to
                    another bus.</p>
                </li>
              </ul>
            </li>
            <li>
              <p>Enter at the front of the bus and, when possible, exit at the
                rear. </p>
            </li>
            <li>
              <p>If you are travelling with your bike, if possible, sit near the
                front and exit from the front of the bus. </p>
            </li>
            <li>
              <p>Wait for passengers exiting the front (such as wheelchair users
                or passengers with strollers) to exit before you board.</p>
            </li>
            <li>
              <p>Don’t stand near the doors. It makes it hard for passengers to
                enter or exit the bus, and can confuse our bus operators.</p>
            </li>
            <li>
              <p>When paying cash on buses, you will be given a paper bus
                transfer. Show this to the operator when you transfer to another
                bus.</p>
            </li>
          </ul>
          <details>
            <summary role="button" aria-expanded="false">
              <h3>Boarding the Bus</h3>
            </summary>
            <p>Stand beside or behind the bus stop sign pole when waiting for a
              bus, safely back from the curb or roadside. Plan to be at the stop
              before the bus arrives, as this increases the chance that the
              operator will see you when approaching the stop.</p>
            <p>If there are others waiting for the bus, please form a line to
              ensure a smooth boarding experience.</p>
            <p>Board the bus at the front and exit out the back unless otherwise
              noted. When the bus stops, give the doors a push on the labelled
              strip to open them.</p>
          </details>
          <details>
            <summary role="button" aria-expanded="false">
              <h3>Using Strollers on Buses</h3>
            </summary>
            <p>When travelling with a stroller on our system:</p>
            <ul>
              <li>
                <p>The maximum size for strollers is 61 cm (24 in.) by 122 cm
                  (48 in.).</p>
              </li>
              <li>
                <p>Let the bus driver know if you need the ramp.</p>
              </li>
              <li>
                <p>Make sure your stroller is not obstructing aisles or doors.</p>
              </li>
              <li>
                <p>Before the bus departs, make sure to hold the stroller and
                  that the brakes are on.</p>
              </li>
            </ul>
            <p>Bus Operators may request that you leave the accessibility area
              to accommodate other priority customers who use wheelchairs,
              scooters, other mobility aids, or seniors.</p>
          </details>
        </section>
        <aside class="Sidebar">
          <section>
            <div class="contentSpacingLayout contentItem"> </div>
          </section>
        </aside>
        <div class="Pagination"></div>
        <div role="presentation" class="ImageBar" style="background-color: transparent;"></div>
        <section class="ImageBottom"></section>
        <hr class="HorizontalRuler"> </div>
      <div data-block-name="Pets on Transit" class=" gridContainer NarrowFlexColumnBlockLayout     fullBleed   "

        style="color: #183152;">
        <div role="presentation" class="Background" style="background-repeat: no-repeat; background-size: cover; background-color: #F2F5F7; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: #F2F5F7;;"></div>
        <div role="presentation" class="BgOverlay"></div>
        <header class="Header">
          <h2>Pets on Transit</h2>
        </header>
        <section class="ImageTop"></section>
        <section class="ImageMain"></section>
        <section class="CopyMain">
          <p>Pets are allowed on board transit services, provided they are kept
            in an appropriate carrier. Follow these rules when travelling with
            non-guide or non-service dogs:</p>
          <ul>
            <li>
              <p>Pets must be kept in small, hand-held, fully enclosed carriers
                that fit in your lap, with no part of the animal exposed.</p>
            </li>
            <li>
              <p>Carriers must be clean, odour-free, and with no sharp edges.</p>
            </li>
            <li>
              <p>Carriers may be placed on the floor, if they do not impede
                other passengers. They may not be placed near doors.</p>
            </li>
            <li>
              <p>Only one pet per passenger is permitted.</p>
            </li>
            <li>
              <p>Dog strollers are not permitted.</p>
            </li>
            <li>
              <p>Pets are not allowed on HandyDART. Assistance animals are
                accepted.</p>
            </li>
          </ul>
          <p>Please keep in mind that drivers may refuse to allow pets on board,
            at their discretion. This may be because of a risk to other
            passengers or because of limited space. We recommend travelling
            during off-peak times.</p>
        </section>
        <aside class="Sidebar">
          <section>
            <div class="contentSpacingLayout contentItem"> </div>
          </section>
        </aside>
        <div class="Pagination"></div>
        <div role="presentation" class="ImageBar" style="background-color: transparent;"></div>
        <section class="ImageBottom"></section>
        <hr class="HorizontalRuler"> </div>
      <div data-block-name="Extra Content Blocks" class=" gridContainer NarrowFlexColumnBlockLayout minimalTopPadding    fullBleed   "

        style="color: #183152;">
        <div role="presentation" class="Background" style="background-repeat: no-repeat; background-size: cover; background-color: #F2F5F7; --focusOutlineColor: #005DAA; --outsideFocusOutlineColor: #F2F5F7;;"></div>
        <div role="presentation" class="BgOverlay"></div>
        <header class="Header"></header>
        <section class="ImageTop"></section>
        <section class="ImageMain"></section>
        <section class="CopyMain">
          <div class="tileLayout tileLayout-preferThreeColumn contentItem">
            <style class="plaintext-infocardtheme-110">
	.plainTextInfoCardTheme
	{
		--leftPadding: 1rem;
		--rightPadding: 1rem;
		
		display: grid;
		
		grid-template-areas: ". . ."
							 ". Header ."
							 ". . ."
							 ". Image ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: var(--leftPadding) calc(100% - var(--leftPadding) - var(--rightPadding)) var(--rightPadding);
		grid-template-rows: 1rem min-content 1rem min-content 1rem min-content 1rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
	}
	
	.plainTextInfoCardTheme .Header
	{
		grid-area: Header;
	}
	
	.plainTextInfoCardTheme .ImageMain
	{
		grid-area: Image;
	}
	
	.plainTextInfoCardTheme .CopyMain
	{
		grid-area: CopyMain;
		
		margin-top: 0px !important;
	}
	
	.plainTextInfoCardTheme .CTALinkContainer
	{
		display: none;
	}
	
	.plainTextInfoCardTheme .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.plainTextInfoCardTheme .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
		
		display: flex;
		
		flex-direction: column;
		justify-content: center;
	}
</style> </div> </section>
        <aside class="Sidebar">
          <section>
            <div class="contentSpacingLayout contentItem"> </div>
          </section>
        </aside>
        <div class="Pagination"></div>
        <div role="presentation" class="ImageBar" style="background-color: transparent;"></div>
        <section class="ImageBottom"></section>
        <hr class="HorizontalRuler"> </div>
      <script class="remove ALT attribute on presentational images">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "img[role=presentation]"
            , callbackFunction: function (target) {
                "use strict";

                var targetRole = target.getAttribute("role");

                if (targetRole === "presentation") {
                    target.removeAttribute("alt");
                }
            }
        });
    })();
</script> <script class="add accessibility attributes to details/summary">
    ; (function () {
        "use strict";

        var addButtonRoleToSummaryElement = function (target) {
            "use strict";

            //GUARD: do nothing if the <summary> already has a role
            if (target.getAttribute("role")) {
                return;
            }

            target.setAttribute("role", "button");
        };

        var addAriaExpandedToSummaryElement = function (target) {
            "use strict";

            //GUARD: do nothing if the <summary> already has aria-expanded
            if (target.getAttribute("aria-expanded")) {
                return;
            }

            //GUARD: do nothing if the <summary> does not have a parent <detail>
            if (target.parentElement && target.parentElement.tagName !== "DETAILS") {
                return;
            }

            if (target.parentElement.getAttribute("open")) {
                target.setAttribute("aria-expanded", "true");
            } else {
                target.setAttribute("aria-expanded", "false");
            }
        };

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "summary"
            , callbackFunction: function (target) {
                "use strict";

                addButtonRoleToSummaryElement(target);
                addAriaExpandedToSummaryElement(target);
            }
        });
    })();
</script> <script class="add explicit default role to table">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "table"
            , callbackFunction: function (target) {
                "use strict";

                //GUARD: do nothing if the table already has a role
                if (target.hasAttribute("role")) {
                    return;
                }

                target.setAttribute("role", "table");
            }
        });
    })();
</script> <script class="add explicit default role to table row">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "tr"
            , callbackFunction: function (target) {
                "use strict";

                //GUARD: do nothing if the table row already has a role
                if (target.hasAttribute("role")) {
                    return;
                }

                target.setAttribute("role", "row");
            }
        });
    })();
</script> <script class="add explicit default role to table header">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "th"
            , callbackFunction: function (target) {
                "use strict";

                //GUARD: do nothing if the column header already has a role
                if (target.hasAttribute("role")) {
                    return;
                }

                target.setAttribute("role", "columnheader");
            }
        });
    })();
</script> <script class="add explicit default role to table cell">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "td"
            , callbackFunction: function (target) {
                "use strict";

                //GUARD: do nothing if the table cell already has a role
                if (target.hasAttribute("role")) {
                    return;
                }

                target.setAttribute("role", "cell");
            }
        });
    })();
</script> <script class="ponyfill for setting max datetime to current datetime">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "input[type=datetime-local]"
            , callbackFunction: function (target) {
                "use strict";

                var hasMaxDateTime = target.hasAttribute("max");

                if (!hasMaxDateTime) {
                    target.setAttribute("max", "9999-12-31T23:59");
                }
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "input[type=date]"
            , callbackFunction: function (target) {
                "use strict";

                var hasMaxDate = target.hasAttribute("max");

                if (!hasMaxDate) {
                    target.setAttribute("max", "9999-12-31");
                }
            }
        });
    })();
</script> <script class="replace datetime-local">
    ; (function () {
        "use strict";

        //GUARD: do not proceed if datetime-local is already supported
        if (!document.documentElement.classList.contains("no-datetimelocal")) {
            return;
        }

        var getDate = function (target) {
            "use strict";

            var output = target;

            if (target && target !== "currentDateTime") {
                output = target.split("T")[0];
            }

            return output || "";
        };

        var getTime = function (target) {
            "use strict";

            var output = target;

            if (target && target !== "currentDateTime") {
                output = target.split("T")[1];
            }

            return output || "";
        };

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "input[type=datetime-local]"
            , callbackFunction: function (target) {
                "use strict";

                var containerNode = document.createElement("div");
                containerNode.classList += " flexContainer";
                containerNode.setAttribute("style", "gap: 1rem;");

                var targetForm = target.getAttribute("form");

                var originalName = target.getAttribute("name") || "";
                var originalValue = target.getAttribute("value") || "";
                var originalMin = target.getAttribute("min") || "";
                var originalMax = target.getAttribute("max") || "";

                var newDate = document.createElement("input");
                var newDateName = originalName + "_date";
                newDate.setAttribute("type", "date");
                targetForm && newDate.setAttribute("form", targetForm);
                newDate.setAttribute("name", newDateName);
                newDate.setAttribute("value", getDate(originalValue));
                newDate.setAttribute("min", getDate(originalMin));
                newDate.setAttribute("max", getDate(originalMax));

                var newTime = document.createElement("input");
                var newTimeName = originalName + "_time";
                newTime.setAttribute("type", "time");
                targetForm && newTime.setAttribute("form", targetForm)
                newTime.setAttribute("name", newTimeName);
                newTime.setAttribute("value", getTime(originalValue));
                newTime.setAttribute("style", "margin-top: 0px");

                target.parentNode.append(containerNode);

                containerNode.append(newDate);
                containerNode.append(newTime);

                target.remove();
            }
        });
    })();
</script> <script class="add rel noopener">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "a[target=_blank]"
            , callbackFunction: function (target) {
                "use strict";

                //don't do anything if there is already a rel attribute
                if (target && !target.rel && target.target === "_blank") {
                    var linkURL = target.href;
                    //don't add noopener if the link is to the current website
                    if (linkURL && !(linkURL.startsWith(document.location.host) || linkURL.startsWith("https://" + document.location.host) || linkURL.startsWith("/"))) {
                        target.setAttribute("rel", "noopener");
                    }
                }
            }
        });
    })();
</script> <script class="Add support for currentDateTime to date and time widgets">
    ; (function () {
        "use strict";

        var currentDateTime = new Date();
        var month = currentDateTime.getMonth() + 1;
        var date = currentDateTime.getDate();
        var year = currentDateTime.getFullYear();
        var time = currentDateTime.toLocaleString("en-US", {
            hour: "numeric"
            , minute: "numeric"
            , hour12: false
        });

        if (time.startsWith("24:") === true) {
            time = time.replace("24:", "00:");
        }

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="datetime-local"][value="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("value", `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}T${time}`);
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="date"][value="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("value", `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}`);
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="time"][value="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("value", `${time}`);
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="datetime-local"][min="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("min", `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}T${time}`);
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="date"][min="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("min", `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}`);
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="time"][min="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("min", `${time}`);
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="datetime-local"][max="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("max", `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}T${time}`);
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="date"][max="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("max", `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}`);
            }
        });

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: 'input[type="time"][max="currentDateTime"]'
            , callbackFunction: function (curTarget) {
                "use strict";

                curTarget.setAttribute("max", `${time}`);
            }
        });
    })();
</script> <script class="add autocomplete-off to inputs">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "input:not([hidden]):not([autocomplete]), select:not([autocomplete]), textarea:not([autocomplete])"
            , callbackFunction: function (target) {
                "use strict";

                target.setAttribute("autocomplete", "Off");
            }
        });
    })();
</script> <script class="disable autocomplete for disabled inputs">
    ; (function () {
        "use strict";

        window.findDynamicComponent({
            parentContainer: "body"
            , targetSelector: "input, select, textarea"
            , callbackFunction: function (target) {
                "use strict";

                var DISABLED_AUTOCOMPLETE_ATTRIBUTE = "data-disabled-autocomplete";

                if (target.hasAttribute("disabled") === true) {
                    var curAutocompleteAttributeValue = target.hasAttribute("autocomplete") && target.getAttribute("autocomplete");

                    curAutocompleteAttributeValue && target.setAttribute(DISABLED_AUTOCOMPLETE_ATTRIBUTE, curAutocompleteAttributeValue);
                    target.setAttribute("autocomplete", "Off");
                } else if (target.hasAttribute("disabled") === false && target.hasAttribute(DISABLED_AUTOCOMPLETE_ATTRIBUTE) === true) {
                    var disabledAutocompleteAttributeValue = target.getAttribute(DISABLED_AUTOCOMPLETE_ATTRIBUTE);

                    target.setAttribute("autocomplete", disabledAutocompleteAttributeValue);
                    target.removeAttribute(DISABLED_AUTOCOMPLETE_ATTRIBUTE);
                }
            }
        });
    })();
            
                
        </script> </div>
        </div>
        <!-- End Newsletter Widget -->
        <!--<link href="https://tlweblibs.translink.ca/SiteFooter-2.0.0.css" rel="stylesheet" integrity="sha256-gdXV7zllAOUlluYsoWOku3vTW50yOJUpY0d5MjBtfxg=" crossorigin="anonymous" />-->
        <style class="siteFooter-200">
	footer ul
	{
		padding: 0px;
		
		list-style: none;
	}
	
	footer nav[aria-label="Social media links"] > ul
	{
		display: flex;
		
		flex-wrap: wrap;
		
		gap: 1rem;
	}
	
	footer nav[aria-label="Social media links"] a
	{
		display: inline-block;
		
		font-size: 0px;
	}
	
	footer nav[aria-label="Social media links"] img
	{
		width: 1.7778rem;
	}
	
	footer .siteLinksFooter > div a:not(:focus):not(:hover)
	{
		text-decoration: none;
	}
	
	footer .siteLinksFooter > div li
	{
		padding-bottom: 1rem;
	}
	
	.siteLinksFooter
	{
		background-color: var(--paleBlue);
		color: var(--navyBlue);
	}
	
	footer .siteLinksFooter > div .SiteLogo
	{
		display: inline-block;
		width: 8rem;
	}
	
	footer .siteLinksFooter > div *
	{
		color: inherit !important;
	}
	
	footer nav[aria-label="general links"] > ul
	{
		margin: 0px !important;
		padding-top: 1rem;
	}
	
	footer nav[aria-label="general links"] > ul > li
	{
		display: inline-block;
	}
	
	footer nav[aria-label="general links"] > ul > li + li:before
	{
		content: "";
		
		display: inline-block;
		
		margin-right: 0.4rem;
		margin-left: 0.4rem;
		border-right: 2px solid black;
		
		height: calc(1em - 1px);
		
		vertical-align: middle;
		
		pointer-events: none;
	}
	
	@media (min-width: 48em) {
		.footerLayout
		{
			grid-template-columns: minmax(calc((100% - 6rem) / 100 * 22), 1fr) calc((100% - 6rem) / 100 * 20) calc((100% - 6rem) / 100 * 20) calc((100% - 6rem) / 100 * 20);
			grid-template-rows: auto;
			
			grid-gap: 2rem;
			
			padding-top: 1.25rem;
			padding-bottom: 2.7778rem;
		}
		.legalFooterLayout
		{
			justify-content: space-between;
			
			padding-top: 1rem;
			padding-bottom: 1rem;
		}
		
		.legalFooterLayout > *
		{
			margin-top: 0px !important;
		}
	}
	
	@media not all and (min-width: 48em) {
		.legalFooterLayout
		{
			padding-top: 1rem;
			padding-bottom: 1rem;
			
			text-align: center;
		}
		
		.footerLayout
		{
			grid-gap: 2.25rem;
			
			padding-top: 1.25rem;
			padding-bottom: 2.7778rem;
			
			text-align: center;
		}
	}
</style> <div class="siteLinksFooter maxContentWidth fullBleed" style="--focusOutlineColor: var(--navyBlue);">
          <div class="gridContainer footerLayout useContentSpacingInfinitely">
            <div> <a href="/" title="Link to 'Home' page on this site" class="SiteLogo">
                <img src="-/media/translink/icons/home/translink_logo_navy.svg"

                  loading="lazy" decoding="async" alt="" height="63" width="144">
              </a>
              <p> Metro Vancouver's transportation network, serving residents
                and visitors with public transit, major roads, bridges and Trip
                Planning. </p>
            </div>
            <div>
              <h3>Getting Around</h3>
              <nav aria-label="getting around" data-sitenav-menu-id="45CC2AC1-1D25-4C13-97E8-3F78A4E49149"

                data-sitenav-menu-token="59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8">
              </nav>
            </div>
            <div>
              <h3>Resources</h3>
              <nav aria-label="resources" data-sitenav-menu-id="787D53DC-2D19-45E2-9A56-B9E330C9D5B1"

                data-sitenav-menu-token="59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8">
              </nav>
            </div>
            <div>
              <h3>Contact Us</h3>
              <nav aria-label="contact us" data-sitenav-menu-id="93363F24-AE0E-4528-B2F0-0ED4797CDCBA"

                data-sitenav-menu-token="59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8">
              </nav>
              <nav aria-label="Social media links" data-sitenav-menu-id="23110991-4ADD-4011-8C17-02C17CC31BB7"

                data-sitenav-menu-token="59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8" class="largeViewOnlyContent flexContainer">
              </nav>
              <nav aria-label="Social media links" data-sitenav-menu-id="23110991-4ADD-4011-8C17-02C17CC31BB7"

                data-sitenav-menu-token="59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8" class="smallViewOnlyContent flexContainer horizontallyCenteredContent">
              </nav>
            </div>
          </div>
        </div>
        <div class="landAcknowledgementFooter fullBleed maxContentWidth" style="padding-top: 2rem; padding-bottom: 2rem; background-color: var(--lightCyan); color: var(--navyBlue);">
          <div class="useContentSpacing centerText">
            <p> Ro-TransLink acknowledges we operate on the unceded territories of
              the First Nations, guardians of this land for countless
              generations. <br>
              As we connect communities throughout the region, Ro-TransLink is
              committed to honouring these long-time caretakers of the
              territory. </p>
          </div>
        </div>
        <div class="legalFooter fullBleed maxContentWidth">
          <nav aria-label="general links" data-sitenav-menu-id="9D820760-C62B-4583-B361-A2CEC19E5D0B"

            data-sitenav-menu-token="59f9fef8-f2d7-4212-87f3-5cf0adbb6ce8" data-sitenav-prepend-links="true"

            data-keep-placeholder-content="true" class="legalFooterLayout flexContainer flexWrapper flexColumnWhenSmallViewOnlyContent fullyJustifiedContent verticallyCenteredContent"

            style="padding-top: 0rem;"> <tl-copyright class="largeViewOnlyContent"

              style="padding-top: 1rem; margin-left: auto;"></tl-copyright> <tl-copyright

              class="smallViewOnlyContent" style="padding-top: 1rem;"></tl-copyright>
          </nav>
        </div>
      </footer>
      <script>
            ; (() => {
                window.addEventListener("load", () => {
                    var siteFooterWrapperElement = document.getElementById("SiteFooter");

                    //GUARD: do nothing if there is no site footer element
                    if (!siteFooterWrapperElement) {
                        return;
                    }

                    siteFooterWrapperElement.hasAttribute("hidden") && siteFooterWrapperElement.removeAttribute("hidden");
                });
            })();
        </script> </div>
    <div class="GarageLayout flexContainer flexColumn rightJustifiedContent"> <button

        type="button" id="ScrollToTop" class="smallViewOnlyContent flexContainer verticallyCenteredContent"

        onclick="window.scrollTo(0, 0);" style="margin-right: 1rem; margin-bottom: 1rem; padding: 0.5rem; border-radius: 50%; font-size: 0px !important; background-color: #078044; color: white; box-shadow: 0.2778rem 0.4444rem 0.5556rem 0px rgb(0 0 0 / 40%);"

        hidden=""> <img role="presentation" src="-/media/translink/icons/shared/back_to_top.svg"

          style="margin: 0.2rem !important; width: 1.75rem; height: 1.75rem;" loading="lazy"

          decoding="async" aria-hidden="true">Scroll to top </button>
      <script>
        ; (function () {
            "use strict";

            var ScrollToTopButton = document.getElementById("ScrollToTop");

            //GUARD: do nothing if there is no scroll-to-top button
            if (!ScrollToTopButton) {
                return;
            }

            var prevYPos = 0;

            window.addEventListener("scroll", function () {
                "use strict";

                var curYPos = window.pageYOffset || document.documentElement.scrollTop;

                if (curYPos < prevYPos) {
                    ScrollToTopButton.removeAttribute("hidden");
                } else {
                    ScrollToTopButton.setAttribute("hidden", "");
                }

                prevYPos = curYPos;
            }, window.setPassiveEventListener);
        })();
    </script> </div>
    <!-- Global Body JS -->
    <script class="responsivescrollbox">
	customElements.define("responsive-scrollbox", class ResponsiveScrollbox extends HTMLElement {
		constructor() {
			super();
			
			//??? since this is all DOM stuff, it is supposed to be moved into the connectedCallback()
			var template = document.createElement("template");
			//??? we absolutely need to not use innerHTML
			template.innerHTML = `
				<style>
					button:disabled
					{
						background-color: #E8EBED !important;
					}
				</style>
				<div class="smallViewOnlyContent" style="position: sticky; top: 0px; left: 0px; display: flex; width: 0px;">
					<button type="button" onclick='this.parentNode.parentNode.host.scrollBy({ top: 0, left: document.body.offsetWidth * 0.6666 * -1, behavior: "smooth" });' style="align-self: center; border: none; padding: 1rem !important; background-color: #005DAA; color: white;" hidden>
						<img role="presentation" src="/-/media/translink/icons/shared/chevron_white.svg" width="23" height="23" loading="lazy" decoding="async" style="width: 23px;" aria-hidden="true" />
						<span style="position: absolute; visibility: hidden; font-size: 0px;">Scroll left</span>
					</button>
				</div>
				<slot></slot>
				<div class="smallViewOnlyContent" style="position: sticky; top: 0px; right: 0px; display: flex; width: 0px;">
					<button type="button" onclick='this.parentNode.parentNode.host.scrollBy({ top: 0, left: document.body.offsetWidth * 0.6666, behavior: "smooth" });' style="align-self: center; border: none; padding: 1rem !important; background-color: #005DAA; color: white; transform: translateX(-100%);" hidden>
						<span style="position: absolute; visibility: hidden; font-size: 0px;">Scroll right</span>
						<img role="presentation" src="/-/media/translink/icons/shared/chevron_white.svg" width="23" height="23" loading="lazy" decoding="async" style="width: 23px; transform: rotate(180deg);" aria-hidden="true" />
					</button>
				</div>
			`;
			
			this.attachShadow({ mode: "open" });
			this.shadowRoot.appendChild(template.content.cloneNode(true));
		}
		
		connectedCallback() {
			var allScrollButtons = this.shadowRoot.querySelectorAll("button");
			
			var scrollboxResizeListener = new ResizeObserver((entries => {
				var hasHorizontalScrollbar = this.scrollWidth > this.clientWidth;
				
				if (hasHorizontalScrollbar === true) {
					allScrollButtons.forEach(curScrollButton => {
						curScrollButton.removeAttribute("hidden");
					});
					
					var beginningScrollButton = allScrollButtons[0];
					var endingScrollButton = allScrollButtons[allScrollButtons.length - 1];
					
					//??? should dedup this code
					var isScrolledToHorizontalBeginning = this.scrollLeft === 0;
					var isScrolledToHorizontalEnd = this.scrollWidth - this.scrollLeft === this.clientWidth;
					
					if (isScrolledToHorizontalBeginning === true) {
						beginningScrollButton.setAttribute("disabled", "");
					} else {
						beginningScrollButton.removeAttribute("disabled");
					}
					
					if (isScrolledToHorizontalEnd === true) {
						endingScrollButton.setAttribute("disabled", "");
					} else {
						endingScrollButton.removeAttribute("disabled");
					}
					
					this.addEventListener("scroll", (() => {
						var isScrolledToHorizontalBeginning = this.scrollLeft === 0;
						var isScrolledToHorizontalEnd = this.scrollWidth - this.scrollLeft < (this.clientWidth * 2);
						
						if (isScrolledToHorizontalBeginning === true) {
							beginningScrollButton.setAttribute("disabled", "");
						} else {
							beginningScrollButton.removeAttribute("disabled");
						}
						
						if (isScrolledToHorizontalEnd === true) {
							endingScrollButton.setAttribute("disabled", "");
						} else {
							endingScrollButton.removeAttribute("disabled");
						}
					}).bind(this), window.setPassiveEventListener);  //??? remove bind(this)?
				} else {
					allScrollButtons.forEach(curScrollButton => {
						curScrollButton.setAttribute("hidden", "");
					});
				}
			}).bind(this));  //??? remove bind(this)?
			
			allScrollButtons.length >= 2 && scrollboxResizeListener.observe(this);
		}
	});
</script><script class="responsivescrollboxv2">
	customElements.define("responsive-scrollbox-v2", class ResponsiveScrollboxV2 extends HTMLElement {
		constructor() {
			super();
			
			//??? since this is all DOM stuff, it is supposed to be moved into the connectedCallback()
			var template = document.createElement("template");
			//??? we absolutely need to not use innerHTML
			template.innerHTML = `
				<style>
					button:disabled
					{
						background-color: #E8EBED !important;
					}
					
					.content
					{
						--scrollbarThumbColor: #005DAA;
						--scrollbarTrackColor: #F0F0F0;
						--scrollbarTrackHeight: 0.5rem;
					}
					
					.content
					{
						scrollbar-color: var(--scrollbarThumbColor) var(--scrollbarTrackColor);
					}
					
					.content::-webkit-scrollbar
					{
						height: var(--scrollbarTrackHeight);
						
						background-color: var(--scrollbarTrackColor);
					}
					
					.content::-webkit-scrollbar-thumb
					{
						background-color: var(--scrollbarThumbColor);
					}
				</style>
				<div style="position: sticky; top: 0px; left: 0px; display: flex; width: 0px; flex: 0 0 auto;">
					<button type="button" onclick='this.parentNode.nextElementSibling.scrollBy({ top: 0, left: document.body.offsetWidth * 0.6666 * -1, behavior: "smooth" });' style="align-self: center; border: none; padding: 1rem !important; background-color: #005DAA; color: white;">
						<img role="presentation" src="/-/media/translink/icons/shared/chevron_white.svg" width="23" height="23" loading="lazy" decoding="async" style="width: 23px;" aria-hidden="true" />
						<span style="position: absolute; visibility: hidden; font-size: 0px;">Scroll left</span>
					</button>
				</div>
				<div class="content" style="display: flex; gap: 1rem; margin-right: auto; margin-left: auto; min-width: 320px; flex: 1 1 0px; overflow-x: auto; scroll-snap-type: x mandatory; scroll-snap-align: start;" hidden>
					<slot></slot>
				</div>
				<div style="position: sticky; top: 0px; right: 0px; display: flex; width: 0px; flex: 0 0 auto;">
					<button type="button" onclick='this.parentNode.previousElementSibling.scrollBy({ top: 0, left: document.body.offsetWidth * 0.6666, behavior: "smooth" });' style="align-self: center; border: none; padding: 1rem !important; background-color: #005DAA; color: white; transform: translateX(-100%);">
						<span style="position: absolute; visibility: hidden; font-size: 0px;">Scroll right</span>
						<img role="presentation" src="/-/media/translink/icons/shared/chevron_white.svg" width="23" height="23" loading="lazy" decoding="async" style="width: 23px; transform: rotate(180deg);" aria-hidden="true" />
					</button>
				</div>
			`;
			
			this.attachShadow({ mode: "open" });
			this.shadowRoot.appendChild(template.content.cloneNode(true));
		}
		
		connectedCallback() {
			var contentContainer = this.shadowRoot.querySelector(".content");
			
			//get width of parent
			var parentContainerResizeListener = new ResizeObserver(entries => {
				for (var entry of entries) {
					var newContainerWidthInPx = entry.contentBoxSize[0].inlineSize;
					
					this.setAttribute("style", `${this.getAttribute("style")}; width: ${newContainerWidthInPx}px !important;`);
					this.setAttribute("style", `${this.getAttribute("style")}; min-width: ${newContainerWidthInPx}px !important;`);
					this.setAttribute("style", `${this.getAttribute("style")}; max-width: ${newContainerWidthInPx}px !important;`);
					
					if (contentContainer) {
						contentContainer.removeAttribute("hidden");
						
						var contentContainerChildren = Array.from(contentContainer.querySelector("slot").assignedNodes());
						
						contentContainerChildren && contentContainerChildren.forEach(curContentContainerChild => {
							curContentContainerChild.removeAttribute && curContentContainerChild.removeAttribute("hidden");
						});
					}
				}
			});
			
			parentContainerResizeListener.observe(this.parentElement);
			
			var allScrollButtons = this.shadowRoot.querySelectorAll("button");
			
			var scrollboxResizeListener = new ResizeObserver(entries => {
				var hasHorizontalScrollbar = contentContainer.scrollWidth > contentContainer.clientWidth;
				
				if (hasHorizontalScrollbar === true) {
					allScrollButtons.forEach(curScrollButton => {
						curScrollButton.removeAttribute("hidden");
					});
					
					var beginningScrollButton = allScrollButtons[0];
					var endingScrollButton = allScrollButtons[allScrollButtons.length - 1];
					
					//??? should dedup this code
					var isScrolledToHorizontalBeginning = contentContainer.scrollLeft === 0;
					var isScrolledToHorizontalEnd = contentContainer.scrollWidth - contentContainer.scrollLeft === contentContainer.clientWidth;
					
					if (isScrolledToHorizontalBeginning === true) {
						beginningScrollButton.setAttribute("disabled", "");
					} else {
						beginningScrollButton.removeAttribute("disabled");
					}
					
					if (isScrolledToHorizontalEnd === true) {
						endingScrollButton.setAttribute("disabled", "");
					} else {
						endingScrollButton.removeAttribute("disabled");
					}
					
					contentContainer.addEventListener("scroll", () => {
						var isScrolledToHorizontalBeginning = contentContainer.scrollLeft === 0;
						var isScrolledToHorizontalEnd = contentContainer.scrollWidth - contentContainer.scrollLeft < (contentContainer.clientWidth * 2);
						
						if (isScrolledToHorizontalBeginning === true) {
							beginningScrollButton.setAttribute("disabled", "");
						} else {
							beginningScrollButton.removeAttribute("disabled");
						}
						
						if (isScrolledToHorizontalEnd === true) {
							endingScrollButton.setAttribute("disabled", "");
						} else {
							endingScrollButton.removeAttribute("disabled");
						}
					}, window.setPassiveEventListener);
				}
			});
			
			allScrollButtons.length >= 2 && scrollboxResizeListener.observe(contentContainer);
		}
	});
</script><script class="currentyear">
	customElements.define("current-year", class CurrentYear extends HTMLElement {
		constructor() {
			super();
		}
		
		connectedCallback() {
			var curYearString = (new Date()).getFullYear().toString();
			
			this.appendChild(document.createTextNode(curYearString));
		}
	});
</script><script class="tlcopyright">
	customElements.define("tl-copyright", class TransLinkCopyright extends HTMLElement {
		constructor() {
			super();
		}
		
		connectedCallback() {
			var wrapperElement = document.createElement("span");
			wrapperElement.setAttribute("style", "display: contents;");
			
			var curYearElement = document.createElement("current-year");
			
			wrapperElement.append(document.createTextNode("© "));
			wrapperElement.append(curYearElement);
			wrapperElement.append(document.createTextNode(" Ro-TransLink, P2P Studios, all rights reserved"));
			
			this.appendChild(wrapperElement);
		}
	});
</script><script class="offlinenotification">
	customElements.define("offline-notification", class OffLineNotification extends HTMLElement {
		constructor() {
			super();
		}
		
		connectedCallback() {
			var offlineNotificationElement = document.createElement("p");
			offlineNotificationElement.setAttribute("hidden", "");
			offlineNotificationElement.textContent = "You're experiencing internet connectivity issues. Please refresh your browser or try again later."
			
			window.addEventListener("offline", e => {
				offlineNotificationElement.removeAttribute("hidden");
			});
			
			this.appendChild(offlineNotificationElement);
		}
	});
</script><script class="googlerecaptchadisclaimer">
	customElements.define("google-recaptcha-disclaimer", class GoogleRecaptchaDisclaimer extends HTMLElement {
		constructor() {
			super();
		}
		
		connectedCallback() {
			try {
				var googlePrivacyPageURLString = "https://policies.google.com/privacy";
				var googlePrivacyPageURL = googlePrivacyPageURLString && new URL(googlePrivacyPageURLString);
				
				var googleTermsPageURLString = "https://policies.google.com/terms";
				var googleTermsPageURL = googleTermsPageURLString && new URL(googleTermsPageURLString);
				
				var refundPolicyPageURLString = "/transit-fares/compass-card" + "#refund-policy";
				var refundPolicyPageURL = refundPolicyPageURLString && new URL(refundPolicyPageURLString, document.location.origin);
				
				var customerInformationPhoneNumberURLString = "tel:6049533333";
				var customerInformationPhoneNumberURL = customerInformationPhoneNumberURLString && new URL(customerInformationPhoneNumberURLString);
				
				var termsAndConditionsTextElement = document.createElement("small");
				
				var googlePrivacyPageLinkElement = document.createElement("a");
				googlePrivacyPageLinkElement.setAttribute("href", googlePrivacyPageURL);
				googlePrivacyPageLinkElement.setAttribute("target", "_blank");
				googlePrivacyPageLinkElement.textContent = "Privacy Policy";
				
				var googleTermsPageLinkElement = document.createElement("a");
				googleTermsPageLinkElement.setAttribute("href", googleTermsPageURL);
				googleTermsPageLinkElement.setAttribute("target", "_blank");
				googleTermsPageLinkElement.textContent = "Terms of Service";
				
				termsAndConditionsTextElement.append(document.createTextNode("This site is protected by reCAPTCHA and the Google "));
				termsAndConditionsTextElement.append(googlePrivacyPageLinkElement);
				termsAndConditionsTextElement.append(document.createTextNode(" and "));
				termsAndConditionsTextElement.append(googleTermsPageLinkElement);
				termsAndConditionsTextElement.append(document.createTextNode(" apply."));
				
				var refundDisclaimerTextElement = document.createElement("small");
				
				var refundPolicyLinkElement = document.createElement("a");
				refundPolicyLinkElement.setAttribute("href", refundPolicyPageURL);
				refundPolicyLinkElement.setAttribute("title", "Link to 'Compass Card Refund Policy' page on this site");
				refundPolicyLinkElement.textContent = "Refund Policy";
				
				var customerInformationPhoneNumberLinkElement = document.createElement("a");
				customerInformationPhoneNumberLinkElement.setAttribute("href", customerInformationPhoneNumberURL);
				customerInformationPhoneNumberLinkElement.textContent = "call 604.953.3333";
				
				refundDisclaimerTextElement.append(document.createTextNode("Note: Please do not send us sensitive information such as credit card or debit card numbers. If you're inquiring about a refund, please visit our "));
				refundDisclaimerTextElement.append(refundPolicyLinkElement);
				refundDisclaimerTextElement.append(document.createTextNode(" page for appropriate contact information, or "));
				refundDisclaimerTextElement.append(customerInformationPhoneNumberLinkElement);
				refundDisclaimerTextElement.append(document.createTextNode("."));
				
				this.append(termsAndConditionsTextElement);
				this.append(refundDisclaimerTextElement);
				
				this.classList.add("useFontColor");
			} catch (error) {
				console.error(error);
			}
		}
	});
</script><script class="loadingMessage">
	customElements.define("loading-message", class LoadingMessage extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-delay-duration-in-milliseconds"
				, "data-first-loading-message"
				, "data-first-loading-message-duration-in-milliseconds"
				, "data-second-loading-message"
				, "data-second-loading-message-duration-in-milliseconds"
				, "data-third-loading-message"
			];
		}
		
		#delayDurationInMS = 0;
		
		#firstLoadingMessageDurationInMS = 3000;
		#firstLoadingMessage = "Loading...";
		
		#secondLoadingMessageDurationInMS = 5000;
		#secondLoadingMessage = "Sorry, we're experiencing a delay in processing your request";
		
		#thirdLoadingMessage = "Unexpected error, please refresh the page or try again later";
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			var noSnippetForGoogleSearchWrapperElement = document.createElement("div");
			noSnippetForGoogleSearchWrapperElement.setAttribute("data-nosnippet", "");
			noSnippetForGoogleSearchWrapperElement.setAttribute("style", "display: contents !important;");
			
			var loadingTextElement = document.createElement("p");
			
			if (this.#delayDurationInMS > 0) {
				loadingTextElement.textContent = " ";  //NOTE: We are inserting a single-whitespace so that the element has a size and can be lazyloaded
				
				window.createLazyLoader({
					lazyLoadTargets: this
					, onLoadFunction: curTarget => {
						window.setTimeout(() => {
							loadingTextElement.textContent = this.#firstLoadingMessage;
						}, this.#delayDurationInMS);
						
						window.setTimeout(() => {
							loadingTextElement.textContent = this.#secondLoadingMessage;
						}, this.#delayDurationInMS + this.#firstLoadingMessageDurationInMS);
						
						window.setTimeout(() => {
							loadingTextElement.textContent = this.#thirdLoadingMessage;
						}, this.#delayDurationInMS + this.#firstLoadingMessageDurationInMS + this.#secondLoadingMessageDurationInMS);
					}
				});
			} else {
				loadingTextElement.textContent = this.#firstLoadingMessage;
				
				window.createLazyLoader({
					lazyLoadTargets: this
					, onLoadFunction: curTarget => {
						window.setTimeout(() => {
							loadingTextElement.textContent = this.#secondLoadingMessage;
						}, this.#delayDurationInMS + this.#firstLoadingMessageDurationInMS);
						
						window.setTimeout(() => {
							loadingTextElement.textContent = this.#thirdLoadingMessage;
						}, this.#delayDurationInMS + this.#firstLoadingMessageDurationInMS + this.#secondLoadingMessageDurationInMS);
					}
				});
			}
			
			loadingTextElement && noSnippetForGoogleSearchWrapperElement.append(loadingTextElement);
			
			this.append(noSnippetForGoogleSearchWrapperElement);
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-delay-duration-in-milliseconds":
					; (() => {
						this.#delayDurationInMS = parseInt(curValue, 10);
					})();
					
					break;
				case "data-first-loading-message":
					; (() => {
						this.#firstLoadingMessage = curValue;
					})();
					
					break;
				case "data-first-loading-message-duration-in-milliseconds":
					; (() => {
						this.#firstLoadingMessageDurationInMS = parseInt(curValue, 10);
					})();
					
					break;
				case "data-second-loading-message":
					; (() => {
						this.#secondLoadingMessage = curValue;
					})();
					
					break;
				case "data-second-loading-message-duration-in-milliseconds":
					; (() => {
						this.#secondLoadingMessageDurationInMS = parseInt(curValue, 10);
					})();
					
					break;
				case "data-third-loading-message":
					; (() => {
						this.#thirdLoadingMessage = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="previous-page-link">
	customElements.define("previous-page-link", class PreviousPageLink extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-link-text"
				, "data-show-as-button"
			];
		}
		
		#linkText;
		#isLooksLikeButton;
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			//GUARD: do nothing if there is no link text
			if (!this.#linkText) {
				return;
			}
			
			try {
				var refererURLString = document.referrer;
				var refererURL = refererURLString && new URL(refererURLString);
				
				//GUARD: do nothing if there is no previous page URL
				if (!refererURL) {
					return;
				}
				
				var curPageURL = document.location.href && new URL(document.location.href);
				
				//GUARD: do nothing if the previous page is from another website
				if (refererURL.origin !== curPageURL.origin) {
					return;
				}
				
				var refererLinkElement = document.createElement("a");
				this.#isLooksLikeButton === true && refererLinkElement.setAttribute("role", "button");
				refererLinkElement.setAttribute("href", refererURL);
				refererLinkElement.textContent = this.#linkText;
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(refererLinkElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-link-text":
					; (() => {
						this.#linkText = curValue;
					})();
					
					break;
				case "data-show-as-button":
					; (() => {
						this.#isLooksLikeButton = curValue === "true" ? true : false;
					})();
					
					break;
			}
		}
	});
</script><script class="inputValueSyncer">
	customElements.define("input-value-syncer", class InputValueSyncer extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-target-form-id"
				, "data-target-input-name"
			];
		}
		
		#targetFormID;
		#targetInputName;
		
		#isClickEventListenerAttached;
		#isSubmitEventListenerAttached;
		
		#attachSubmitEventListener() {
			var isButton = this.hasAttribute("role") && this.getAttribute("role").toLowerCase() === "button";
			
			if (isButton === true) {
				//GUARD: do nothing if the click event listener has already been attached
				if (this.#isClickEventListenerAttached === true) {
					return;
				}
				
				this.addEventListener("click", () => {
					var targetForm = this.#targetFormID && document.getElementById(this.#targetFormID);
					var targetInput = targetForm && targetForm.tagName === "FORM" && this.#targetInputName && targetForm.elements[this.#targetInputName];
					
					if (!targetForm || !targetInput) {
						return;
					}
					
					targetInput.value = this.textContent;
				});
				
				this.#isClickEventListenerAttached = true;
			} else {
				window.runAfterDOMContentLoaded && window.runAfterDOMContentLoaded(document, () => {
					//GUARD: do nothing if the submit event listener has already been attached
					if (this.#isSubmitEventListenerAttached === true) {
						return;
					}
					
					//GUARD: do nothing if we don't have both a target form and a target input
					var targetForm = this.#targetFormID && document.getElementById(this.#targetFormID);
					var targetInput = targetForm && targetForm.tagName === "FORM" && this.#targetInputName && targetForm.elements[this.#targetInputName];
					
					if (!targetForm || !targetInput) {
						return;
					}
					
					this.textContent = targetInput.value;
					
					targetForm.addEventListener("submit", e => {
						try {
							this.textContent = targetInput.value;
						} catch (error) {
							console.error(error);
						}
					});
					
					this.#isSubmitEventListenerAttached = true;
				});
			}
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() { }
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-target-form-id":
					; (() => {
						this.#targetFormID = curValue;
						
						this.#targetFormID !== undefined && this.#targetInputName !== undefined && this.#attachSubmitEventListener();
					})();
					
					break;
				case "data-target-input-name":
					; (() => {
						this.#targetInputName = curValue;
						
						this.#targetFormID !== undefined && this.#targetInputName !== undefined && this.#attachSubmitEventListener();
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="youtubeembeddable">
	customElements.define("youtube-embeddable", class YoutubeEmbeddable extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-title"
				, "data-videoid"
			];
		}
		
		#videoTitle;
		#videoID;
		
		#lazyLoadingElement;
		
		#initYoutubeIFrame() {
			try {
				var youtubeVideoURLString = `https://www.youtube-nocookie.com/embed/${this.#videoID}?rel=0&amp;origin=${window.location.origin}`;
				var youtubeVideoURL = youtubeVideoURLString && new URL(youtubeVideoURLString);
				
				if (youtubeVideoURL) {
					var youtubeIFrame = document.createElement("iframe");
					youtubeIFrame.setAttribute("width", 560);
					youtubeIFrame.setAttribute("height", 315);
					youtubeIFrame.setAttribute("src", youtubeVideoURL);
					youtubeIFrame.setAttribute("title", this.#videoTitle);
					youtubeIFrame.setAttribute("sandbox", "allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts");
					youtubeIFrame.setAttribute("allow", "accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture");
					youtubeIFrame.setAttribute("allowfullscreen", "");
					youtubeIFrame.setAttribute("loading", "lazy");
					
					this.#lazyLoadingElement.after(youtubeIFrame);
				}
			} catch (error) {
				console.error(error);
			} finally {
				this.#lazyLoadingElement.remove();
			}
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			try {
				var posterImageURLString = `https://i.ytimg.com/vi_webp/${this.#videoID}/hqdefault.webp`;
				var posterImageURL = posterImageURLString && new URL(posterImageURLString);
				
				//GUARD: do nothing if there is no poster image URL
				if (!posterImageURL) {
					return;
				}
				
				this.#lazyLoadingElement = document.createElement("img");
				this.#lazyLoadingElement.setAttribute("role", "presentation");
				posterImageURL && this.#lazyLoadingElement.setAttribute("src", posterImageURL);
				this.#lazyLoadingElement.setAttribute("style", "height: auto; aspect-ratio: 16 / 9; object-fit: cover; object-position: center;");
				this.#lazyLoadingElement.setAttribute("loading", "lazy");
				this.#lazyLoadingElement.setAttribute("decoding", "async");
				this.#lazyLoadingElement.setAttribute("aria-hidden", true);
				
				this.#lazyLoadingElement.addEventListener("load", this.#initYoutubeIFrame.bind(this), { once: true });
				
				posterImageURL && this.setAttribute("style", `${this.getAttribute("style")}; background-image: url("${posterImageURL.toString()}"); background-repeat: no-repeat !important; background-size: cover !important; background-position: center center;`);
				
				this.appendChild(this.#lazyLoadingElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-title":
					; (() => {
						this.#videoTitle = curValue;
					})();
					
					break;
				case "data-videoid":
					; (() => {
						this.#videoID = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><template id="image-gallery_shadow-dom">
      <style>
		:host
		{
			overflow-anchor: none;
		}
		
		slot
		{
			display: flex;
		}
		
		.paginationButtons
		{
			position: sticky;
			
			bottom: 0px;
			left: 0px;
			
			display: flex;
			
			flex-wrap: wrap;
			
			justify-content: space-between;
			
			padding-top: 1rem;
			width: calc(var(--frameWidthInPX, 0px) * 1px);
			height: fit-content;
			
			min-width: calc(var(--frameWidthInPX, 0px) * 1px);
			max-width: calc(var(--frameWidthInPX, 0px) * 1px);
			
			background-color: inherit;
		}
		
		.paginationButtons button
		{
			cursor: pointer;
			
			border: none;
			padding: 1rem !important;
			
			background-color: #005DAA;
			color: white;
		}
		
		.paginationButtons button:disabled
		{
			background-color: #E8EBED !important;
			
			cursor: not-allowed;
		}
	</style> <slot></slot>
      <div class="paginationButtons flexContainer verticallyCenteredContent"> <button

          type="button" hidden=""> <img src="-/media/translink/icons/shared/chevron_white.svg"

            loading="lazy" decoding="async" style="width: 23px;" alt="" height="23"

            width="23"> <span style="position: absolute; visibility: hidden; font-size: 0px;">Scroll
            left</span> </button> <span class="pageCounter" style="align-self: center;"></span>
        <button type="button" hidden=""> <span style="position: absolute; visibility: hidden; font-size: 0px;">Scroll
            right</span> <img src="-/media/translink/icons/shared/chevron_white.svg"

            loading="lazy" decoding="async" style="width: 23px; transform: rotate(180deg);"

            alt="" height="23" width="23"> </button> </div>
    </template>
    <script type="module" class="imageGallery">
	import { isValidNumber } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	
	customElements.define("image-gallery", class ImageGallery extends HTMLElement {
		#validImageGalleryFrameElementTagNames = [
			"FIGURE"
		];
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.scrollLeft = 0;
			this.style.visibility = "hidden";
			
			/* Set proper sizing for the frames inside the gallery */
			var imageGalleryParentContainer = this.closest(".CopyMain");  //??? temporary pick, there might be a better algorithmic pick once we think more about it....
			
			if (imageGalleryParentContainer) {
				var imageGalleryParentContainerResizeObserver = new ResizeObserver(entries => {
					for (var entry of entries) {
						this.style.setProperty("--frameWidthInPX", `${entry.borderBoxSize[0].inlineSize}`);
					}
				});
				
				imageGalleryParentContainerResizeObserver.observe(imageGalleryParentContainer);
			}
			
			/* Add pagination buttons */
			var allImageGalleryFrames = Array.from(this.children).filter(curImageGalleryFrame => {
				return this.#validImageGalleryFrameElementTagNames.includes(curImageGalleryFrame.tagName);
			});
			
			var numImageGalleryFrames = allImageGalleryFrames.length;
			
			if (numImageGalleryFrames > 1) {
				const shadowDOMTemplateID = "image-gallery_shadow-dom";
				var shadowDOMTemplate = shadowDOMTemplateID && document.getElementById(shadowDOMTemplateID);
				
				//??? GUARD: verify that this is a <template> element?
				
				if (shadowDOMTemplate) {
					this.attachShadow({ mode: "open" });
					
					this.shadowRoot.appendChild(shadowDOMTemplate.content.cloneNode(true));
					
					//NOTE: Run pagination code after page load because hopefully by then the widget is done rendering and intersection observers can run safely
					window.runAfterLoad(document, () => {
						var prevImageGalleryFrameButton = this.shadowRoot.querySelector("button:first-of-type");
						var nextImageGalleryFrameButton = this.shadowRoot.querySelector("button:last-of-type");
						
						prevImageGalleryFrameButton.removeAttribute("hidden");
						nextImageGalleryFrameButton.removeAttribute("hidden");
						
						prevImageGalleryFrameButton.addEventListener("click", e => {
							this.scrollBy({
								top: 0
								, left: this.style.getPropertyValue("--frameWidthInPX") * -1
								, behavior: "smooth"
							});
						});
						
						nextImageGalleryFrameButton.addEventListener("click", e => {
							this.scrollBy({
								top: 0
								, left: this.style.getPropertyValue("--frameWidthInPX")
								, behavior: "smooth"
							});
						});
						
						window.requestAnimationFrame(() => {
							window.requestAnimationFrame(() => {
								var allPageCounters = this.shadowRoot.querySelectorAll(".pageCounter");
								
								var firstImageGalleryFrame = allImageGalleryFrames[0];
								var lastImageGalleryFrame = allImageGalleryFrames[numImageGalleryFrames - 1];
								
								allImageGalleryFrames.forEach((curImageGalleryFrame, curImageGalleryFrameIndex) => {
									var observer = new IntersectionObserver(entries => {
										entries.forEach(entry => {
											if (entry.isIntersecting === true) {
												if (entry.target === firstImageGalleryFrame) {
													prevImageGalleryFrameButton.setAttribute("disabled", "");
												} else {
													prevImageGalleryFrameButton.removeAttribute("disabled");
												}
												
												if (entry.target === lastImageGalleryFrame) {
													nextImageGalleryFrameButton.setAttribute("disabled", "");
												} else {
													nextImageGalleryFrameButton.removeAttribute("disabled");
												}
												
												isValidNumber(curImageGalleryFrameIndex) === true && allPageCounters.forEach(curPageCounter => {
													var formattedCurImageGalleryFrameIndex = curImageGalleryFrameIndex + 1;
													
													curPageCounter.textContent = `${formattedCurImageGalleryFrameIndex} / ${numImageGalleryFrames}`;
												});
											}
										});
									}
									, {
										root: this
										, threshold: [0.51]
									});
									
									observer.observe(curImageGalleryFrame);
								});
								
								this.style.visibility = "visible";
							});
						});
						
						this.scrollLeft = 0;
					});
				}
			} else {
				this.scrollLeft = 0;
				this.style.visibility = "visible";
			}
		}
	});
</script><script class="transitalertscounter">
	customElements.define("transit-alerts-counter", class TransitAlertsCounter extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-timeframe"
				, "data-always-count-mode-alerts"
				, "data-alert-count-singular-suffix-text"
				, "data-alert-count-multiples-suffix-text"
				, "data-gtfs-mode-number"
				, "data-gtfs-routeline-number"  //??? this is a typo?  should be 'data-gtfsrouteline-number'
				, "data-no-alerts-text"
			];
		}
		
		#alertCountSingularSuffixText = "";
		#alertCountMultiplesSuffixText = "";
		#noAlertsText = "None";
		
		#showTodayAlertsOnly = true;  //??? we gotta think about how to update the code to use this because we need it for deploying to the alerts page with its today/all toggle
		#alwaysCountModeAlerts;
		#gtfsModeNumber;
		#gtfsRouteLineNumber;
		
		async #render() {
			const TRANSIT_ALERTS_MODULE_URL_STRING = "/js/transitAlerts.mjs";
			
			var transitAlertsModuleURL = TRANSIT_ALERTS_MODULE_URL_STRING && new URL(TRANSIT_ALERTS_MODULE_URL_STRING, document.location.origin);
			
			var { fetchAllAlertsByMode } = transitAlertsModuleURL && await import(transitAlertsModuleURL);  //??? import needs to be inside try-catch
			
			var allAlertsByMode = fetchAllAlertsByMode && await fetchAllAlertsByMode;
			
			var curModeAlerts = allAlertsByMode && allAlertsByMode.get(this.#gtfsModeNumber) || {};  //NOTE: 'curModeAlerts' must be a valid and empty object so it can be parsed by the rendering code below so that the 'None' alerts counter can be rendered.  Otherwise, if the entire mode has no alerts, processing will stop immediately and 'None' alerts counter will not be rendered.
			
			var numAlerts = 0;
			
			if (this.#gtfsRouteLineNumber) {
				var allAlertsForRouteLine = curModeAlerts[this.#gtfsRouteLineNumber];
				
				if (allAlertsForRouteLine && allAlertsForRouteLine.filter) {  //??? convert to simply check that it's an array instead of duck typing
					if (this.#showTodayAlertsOnly === true) {
						var allValidAlertsForRouteLine = allAlertsForRouteLine && allAlertsForRouteLine.filter && allAlertsForRouteLine.filter(curAlert => {
							var startTimeDate = new Date(curAlert.startTime);
							
							if (startTimeDate >= window.NEXT_SERVICE_DAY_START_TIME) {
								return false;
							} else {
								return true;
							}
						});
						
						if (allValidAlertsForRouteLine) {
							numAlerts = numAlerts + allValidAlertsForRouteLine.length;
						}
					} else {
						numAlerts = numAlerts + allAlertsForRouteLine.length;
					}
				}
				
				if (this.#alwaysCountModeAlerts === true) {
					var allModeWideAlertsForCurMode = curModeAlerts.modeWideAlerts;
					
					if (allModeWideAlertsForCurMode && allModeWideAlertsForCurMode.filter) {  //??? convert to simply check that it's an array instead of duck typing
						if (this.#showTodayAlertsOnly === true) {
							var allValidModeWideAlertsForCurMode = allModeWideAlertsForCurMode && allModeWideAlertsForCurMode.filter && allModeWideAlertsForCurMode.filter(curAlert => {
								var startTimeDate = new Date(curAlert.startTime);
								
								if (startTimeDate >= window.NEXT_SERVICE_DAY_START_TIME) {
									return false;
								} else {
									return true;
								}
							});
							
							if (allValidModeWideAlertsForCurMode) {
								numAlerts = numAlerts + allValidModeWideAlertsForCurMode.length;
							}
						} else {
							numAlerts = numAlerts + allModeWideAlertsForCurMode.length;
						}
					}
				}
			} else {
				switch (this.#gtfsModeNumber) {
					case 1:
					case 2:
					case 3:
					case 4:
					case 6:
					case 715:
						; (() => {
							curModeAlerts && Object.keys(curModeAlerts).forEach(curGTFSRouteLineNumber => {
								var curGTFSRouteLineAlerts = curModeAlerts[curGTFSRouteLineNumber];
								
								if (this.#showTodayAlertsOnly === true) {
									var allValidCurGTFSRouteLineAlerts = curGTFSRouteLineAlerts && curGTFSRouteLineAlerts.filter && curGTFSRouteLineAlerts.filter(curGTFSRouteLineAlert => {
										var startTimeDate = new Date(curGTFSRouteLineAlerts.startTime);
										
										if (startTimeDate >= window.NEXT_SERVICE_DAY_START_TIME) {
											return false;
										} else {
											return true;
										}
									});
									
									if (allValidCurGTFSRouteLineAlerts) {
										numAlerts = numAlerts + allValidCurGTFSRouteLineAlerts.length;
									}
								} else {
									if (curGTFSRouteLineAlerts && curGTFSRouteLineAlerts.length) {
										numAlerts = numAlerts + curGTFSRouteLineAlerts.length;
									}
								}
							});
						})();
						
						break;
					default:
						; (() => {
							//??? add error logging?
						})();
						
						break;
				}
			}
			
			//??? this is bad, we should never be overriding the style attribute like this
			if (numAlerts === 0) {
				this.setAttribute("style", "margin-top: 0px !important; border: 1px solid #C2D9D1; padding: 0.1rem 0.8888rem; border-radius: 3px; background-color: white; text-align: center;");
			} else {
				this.setAttribute("style", "margin-top: 0px !important; border: 1px solid #FFC425; padding: 0.1rem 0.8888rem; border-radius: 3px; background-color: #FFC425; text-align: center;");
			}
			
			var alertsCounterText = numAlerts;
			
			switch (numAlerts) {
				case 0:
					; (() => {
						if (this.#noAlertsText) {
							alertsCounterText = this.#noAlertsText;
						}
					})();
					
					break;
				case 1:
					; (() => {
						if (this.#alertCountSingularSuffixText) {
							alertsCounterText = `${numAlerts} ${this.#alertCountSingularSuffixText}`;
						}
					})();
					
					break;
				default:
					; (() => {
						if (this.#alertCountMultiplesSuffixText) {
							alertsCounterText = `${numAlerts} ${this.#alertCountMultiplesSuffixText}`;
						}
					})();
					
					break;
			}
			
			var alertsCounterElement = document.createElement("strong");
			alertsCounterElement.setAttribute("style", "font-size: 0.7778rem; white-space: pre;");
			alertsCounterElement.textContent = alertsCounterText;
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			
			this.append(alertsCounterElement);
		};
		
		constructor() {
			super();
		}
		
		connectedCallback() { }
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-timeframe":
					; (() => {
						curValue = curValue && curValue.toLowerCase && curValue.toLowerCase();
						
						switch (curValue) {
							case "today":
								; (() => {
									this.#showTodayAlertsOnly = true;
								})();
								
								break;
							case "all":
								; (() => {
									
								})();
								
								//break;  //NOTE: intentionally allow passthrough to default case
							default:
								; (() => {
									this.#showTodayAlertsOnly = false;
								})();
								
								break;
						}
						
						this.#gtfsModeNumber && this.#render();
					})();
					
					break;
				case "data-always-count-mode-alerts":
					; (() => {
						this.#alwaysCountModeAlerts = curValue === "true" ? true : false;
						
						this.#gtfsModeNumber && this.#render();
					})();
					
					break;
				case "data-alert-count-singular-suffix-text":
					; (() => {
						this.#alertCountSingularSuffixText = curValue;
						
						this.#gtfsModeNumber && this.#render();
					})();
					
					break;
				case "data-alert-count-multiples-suffix-text":
					; (() => {
						this.#alertCountMultiplesSuffixText = curValue;
						
						this.#gtfsModeNumber && this.#render();
					})();
					
					break;
				case "data-gtfs-mode-number":
					; (() => {
						this.#gtfsModeNumber = parseInt(curValue, 10);
						
						this.#gtfsModeNumber && this.#render();
					})();
					
					break;
				case "data-gtfs-routeline-number":
					; (() => {
						this.#gtfsRouteLineNumber = curValue;
						
						this.#gtfsModeNumber && this.#gtfsRouteLineNumber && this.#render();
					})();
					
					break;
				case "data-no-alerts-text":
					; (() => {
						this.#noAlertsText = curValue;
						
						this.#gtfsModeNumber && this.#render();
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="transitalerts">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { ifTruthyValue, mergeSimpleCollections } from "/js/functionalHelpers.mjs";
	import { fetchAllAlertsByMode } from "/js/transitAlerts.mjs";
	
	customElements.define("transit-alerts", class TransitAlerts extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-timeframe"
				, "data-show-alert-count-only"
				, "data-alert-count-singular-suffix-text"
				, "data-alert-count-multiples-suffix-text"
				, "data-gtfs-mode-number"
				, "data-gtfs-routeline-number"  //??? this is a typo?  should be 'data-gtfsrouteline-number'
				, "data-blocked-terms"
				, "data-no-alerts-text"
			];
		}
		
		static #renderAlert(targetAlert, renderOnlyTodayAlerts) {
			if (renderOnlyTodayAlerts === true) {
				var startTimeDate = new Date(targetAlert.startTime);
				
				if (startTimeDate >= window.NEXT_SERVICE_DAY_START_TIME) {
					return;
				}
			}
			
			var startTime;
			var endTime;
			var endDateTime;
			
			var isRecurring = false;
			
			var targetAlertActivePeriods = targetAlert.activePeriods;
			
			if (Array.isArray(targetAlertActivePeriods) === true) {
				//GUARD: do nothing if there are no active periods for the target TransitAlert
				if (targetAlertActivePeriods.length === 0) {
					return;
				}
				
				var allTargetAlertStartAndEndTimes = [];
				
				targetAlertActivePeriods
				.flatMap(curAlertActivePeriod => {
					var output = [];
					
					if (("startTime" in curAlertActivePeriod) === true && getType(curAlertActivePeriod.startTime) === getType.string) {
						output.push(curAlertActivePeriod.startTime);
					}
					
					if (("endTime" in curAlertActivePeriod) === true && getType(curAlertActivePeriod.endTime) === getType.string) {
						output.push(curAlertActivePeriod.endTime);
					}
					
					return output;
				})
				.filter(ifTruthyValue)
				.map(curActivePeriodDateTimeString => {
					var curActivePeriodDate = new Date(curActivePeriodDateTimeString);
					
					if (isValidDate(curActivePeriodDate) === true) {
						return curActivePeriodDate;
					} else {
						return null;
					}
				})
				.sort((lhs, rhs) => {
					return lhs - rhs;
				})
				.reduce(mergeSimpleCollections, allTargetAlertStartAndEndTimes);
				
				if (Array.isArray(allTargetAlertStartAndEndTimes) === false) {
					return;
				}
				
				if (allTargetAlertStartAndEndTimes.length === 0) {
					return;
				}
				
				if (targetAlertActivePeriods.length > 1) {
					isRecurring = true;
				}
				
				startTime = allTargetAlertStartAndEndTimes[0];
				
				if (isRecurring === true) {
					if (targetAlert.endStamp === 3) {
						var dateTime = new Date(allTargetAlertStartAndEndTimes[allTargetAlertStartAndEndTimes.length - 1]);
						
						endTime = window.buildTimeString(`${dateTime.getHours()}:${dateTime.getMinutes()}`);
                        endDateTime = new Date(targetAlert.endTime);
					} else {
						if (targetAlert.endStamp === 1) {
							var endOfServiceDate = new Date(targetAlert.endTime);
							endOfServiceDate.setUTCDate(endOfServiceDate.getUTCDate() - 1);

							endDateTime = endOfServiceDate;
						} else {
                        	endDateTime = new Date(targetAlert.endTime);
                        }
                        
						endTime = window.TRANSIT_ALERT_END_TIME_LABELS[targetAlert.endStamp];
					}
				} else {
					endTime = targetAlert.endStamp === 3 ? window.buildDateTimeString(allTargetAlertStartAndEndTimes[allTargetAlertStartAndEndTimes.length - 1]) : window.TRANSIT_ALERT_END_TIME_LABELS[targetAlert.endStamp];
				}
			} else {
				startTime = targetAlert.startTime;
				endTime = targetAlert.endStamp === 3 ? window.buildDateTimeString(targetAlert.endTime) : window.TRANSIT_ALERT_END_TIME_LABELS[targetAlert.endStamp];
			}
			
			var output = window.buildAlert(() => {
				var context = {};
				
				context.alertID = targetAlert.id;
				context.isClosedAlert = targetAlert.closed;
				context.isCriticalAlert = targetAlert.critical;
				context.isAdvisoryAlert = targetAlert.advisory;
				context.alertEffect = targetAlert.effect;
				context.affectedModes;
				context.headerText = targetAlert.header;
				context.descriptionText = targetAlert.description;
				context.url = targetAlert.url;
				context.lastModifiedDateTime = targetAlert.lastModified;
				context.startTime = startTime;
				context.endTime = endTime;
				context.endDateTime = endDateTime;
				context.isRecurring = isRecurring;
				
				return context;
			});
			
			return output;
		};
		
		#alertCountSingularSuffixText = "";
		#alertCountMultiplesSuffixText = "";
		#noAlertsText = "None";
		
		#showTodayAlertsOnly = true;
		#isOnlyShowingAlertCount;
		#gtfsModeNumber;
		#gtfsRouteLineNumber;
		
		#blockedTerms = [];
		
		async #displayAlerts() {
			try {
				var allAlertsByMode = fetchAllAlertsByMode && await fetchAllAlertsByMode;
				
				var curModeAlerts = allAlertsByMode && allAlertsByMode.get(this.#gtfsModeNumber) || {};  //NOTE: 'curModeAlerts' must be a valid and empty object so it can be parsed by the rendering code below so that the 'None' alerts counter can be rendered.  Otherwise, if the entire mode has no alerts, processing will stop immediately and 'None' alerts counter will not be rendered.
				
				//build alerts
				var allAlertElements = [];
				
				if (this.#gtfsRouteLineNumber) {
					var allAlertsForRouteLine = curModeAlerts[this.#gtfsRouteLineNumber];
					
					if (allAlertsForRouteLine && allAlertsForRouteLine.map) {
						//??? should save the output of map() into a variable before concating it?
						allAlertElements = allAlertsForRouteLine && allAlertsForRouteLine.map && allAlertElements.concat(allAlertsForRouteLine.map(curAlert => {
							return TransitAlerts.#renderAlert(curAlert, this.#showTodayAlertsOnly);
						}));
					}
				} else {
					if (curModeAlerts.modeWideAlerts && curModeAlerts.modeWideAlerts.map) {
						allAlertElements = allAlertElements.concat(curModeAlerts.modeWideAlerts.map(curAlert => {
							return TransitAlerts.#renderAlert(curAlert, this.#showTodayAlertsOnly);
						}));
					}
					
					if (this.#isOnlyShowingAlertCount === true) {
						switch (this.#gtfsModeNumber) {
							case 1:
							case 2:
							case 3:
							case 4:
							case 6:
							case 715:
								; (() => {
									curModeAlerts && Object.keys(curModeAlerts).forEach(curGTFSRouteLineNumber => {
										//GUARD: do nothing if the currey key is for mode-wide alerts
										if (curGTFSRouteLineNumber === "modeWideAlerts") {
											return;
										}
										
										var curGTFSRouteLineAlerts = curModeAlerts[curGTFSRouteLineNumber];
										
										curGTFSRouteLineAlerts && curGTFSRouteLineAlerts.forEach(curGTFSRouteLineAlert => {
											var curGTFSRouteLineAlertElement = TransitAlerts.#renderAlert(curGTFSRouteLineAlert, this.#showTodayAlertsOnly);
											
											allAlertElements.push(curGTFSRouteLineAlertElement);
										});
									});
								})();
								
								break;
							default:
								; (() => {
								
								})();
								
								break;
						}
					}
				}
				
				allAlertElements = allAlertElements.filter(x => x); //NOTE: "filter(x => x)" to remove empty strings and other falsey values
				
				if (this.#isOnlyShowingAlertCount === true) {
					var numAlerts = allAlertElements.length;
					
					//??? this is bad, we should never be overriding the style attribute like this
					if (numAlerts === 0) {
						this.setAttribute("style", "margin-top: 0px !important; border: 1px solid #C2D9D1; padding: 0.1rem 0.8888rem; border-radius: 3px; background-color: white; text-align: center;");
					} else {
						this.setAttribute("style", "margin-top: 0px !important; border: 1px solid #FFC425; padding: 0.1rem 0.8888rem; border-radius: 3px; background-color: #FFC425; text-align: center;");
					}
					
					var alertsCounterText = numAlerts;
					
					switch (numAlerts) {
						case 0:
							; (() => {
								if (this.#noAlertsText) {
									alertsCounterText = this.#noAlertsText;
								}
							})();
							
							break;
						case 1:
							; (() => {
								if (this.#alertCountSingularSuffixText) {
									alertsCounterText = `${numAlerts} ${this.#alertCountSingularSuffixText}`;
								}
							})();
							
							break;
						default:
							; (() => {
								if (this.#alertCountMultiplesSuffixText) {
									alertsCounterText = `${numAlerts} ${this.#alertCountMultiplesSuffixText}`;
								}
							})();
							
							break;
					}
					
					var alertsCounterElement = document.createElement("strong");
					alertsCounterElement.setAttribute("style", "font-size: 0.7778rem; white-space: pre;");
					alertsCounterElement.textContent = alertsCounterText;
					
					window.deleteAllChildNodes && window.deleteAllChildNodes(this);
					
					this.append(alertsCounterElement);
				} else {
					if (allAlertElements.length > 0) {
						window.deleteAllChildNodes && window.deleteAllChildNodes(this);
						
						//??? probably upgrade this renderer to a more async version
						allAlertElements.forEach(curAlertElement => {
							this.append(curAlertElement);
						});
					}
				}
			} catch (error) {
				console.error(error);
			}
		};
		
		constructor() {
			super();
		}
		
		connectedCallback() { }
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-timeframe":
					; (() => {
						curValue = curValue && curValue.toLowerCase && curValue.toLowerCase();
						
						switch (curValue) {
							case "today":
								; (() => {
									this.#showTodayAlertsOnly = true;
								})();
								
								break;
							case "all":
								; (() => {
									
								})();
								
								//break;  //NOTE: intentionally allow passthrough to default case
							default:
								; (() => {
									this.#showTodayAlertsOnly = false;
								})();
								
								break;
						}
						
						this.#gtfsModeNumber && this.#displayAlerts();
					})();
					
					break;
				case "data-show-alert-count-only":
					; (() => {
						this.#isOnlyShowingAlertCount = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-alert-count-singular-suffix-text":
					; (() => {
						this.#alertCountSingularSuffixText = curValue;
						
						this.#gtfsModeNumber && this.#displayAlerts();
					})();
					
					break;
				case "data-alert-count-multiples-suffix-text":
					; (() => {
						this.#alertCountMultiplesSuffixText = curValue;
						
						this.#gtfsModeNumber && this.#displayAlerts();
					})();
					
					break;
				case "data-gtfs-mode-number":
					; (() => {
						this.#gtfsModeNumber = parseInt(curValue, 10);
						
						this.#gtfsModeNumber && this.#displayAlerts();
					})();
					
					break;
				case "data-gtfs-routeline-number":
					; (() => {
						this.#gtfsRouteLineNumber = curValue;
						
						this.#gtfsModeNumber && this.#gtfsRouteLineNumber && this.#displayAlerts();
					})();
					
					break;
				case "data-no-alerts-text":
					; (() => {
						this.#noAlertsText = curValue;
						
						this.#gtfsModeNumber && this.#displayAlerts();
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="mytransitalerts">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { fetchIsAuthenticated } from "/js/authed.mjs";
	
	customElements.define("my-transit-alerts", class MyTransitAlerts extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		async #displayAlerts() {
			var isAuthenticated = fetchIsAuthenticated && await fetchIsAuthenticated;
			
			//GUARD: do nothing if the user is not authenticated
			if (isAuthenticated === false) {
				return;
			}
			
			try {
				const ALERT_SUBSCRIPTIONS_MODULE_URL_STRING = "/js/alertSubscriptions.mjs";
				
				var alertSubscriptionsModuleURL = ALERT_SUBSCRIPTIONS_MODULE_URL_STRING && new URL(ALERT_SUBSCRIPTIONS_MODULE_URL_STRING, document.location.origin);
				
				var { fetchValidAlertSubscriptionGTFSItemNumbers } = alertSubscriptionsModuleURL && await import(alertSubscriptionsModuleURL);
				
				var validAlertSubscriptionGTFSItemNumbers = fetchValidAlertSubscriptionGTFSItemNumbers && await fetchValidAlertSubscriptionGTFSItemNumbers;
				
				var numValidAlertSubscriptionNumbers = validAlertSubscriptionGTFSItemNumbers && validAlertSubscriptionGTFSItemNumbers.length;
				
				//GUARD: do nothing if the user does not have at least one subscription
				if (!numValidAlertSubscriptionNumbers || numValidAlertSubscriptionNumbers === 0) {
					try {
						const createTransitAlertSubscriptionPageLinkURLString = "/alert-subscriptions/create-alert";
						var createTransitAlertSubscriptionPageLinkURL = createTransitAlertSubscriptionPageLinkURLString && new URL(createTransitAlertSubscriptionPageLinkURLString, document.location.origin);
						
						if (createTransitAlertSubscriptionPageLinkURL) {
							var noSubscriptionsTextElement = document.createElement("p");
							
							var createTransitAlertSubscriptionPageLinkElement = document.createElement("a");
							createTransitAlertSubscriptionPageLinkElement.setAttribute("href", createTransitAlertSubscriptionPageLinkURL);
							createTransitAlertSubscriptionPageLinkElement.setAttribute("title", "Link to 'Create Alert' page");
							createTransitAlertSubscriptionPageLinkElement.textContent = "Create an alert";
							
							noSubscriptionsTextElement.append(createTransitAlertSubscriptionPageLinkElement);
							noSubscriptionsTextElement.append(document.createTextNode(" in your Transit Alerts account to see your alerts on this page. You can also see all of today's alerts in the Today's Alert tab."));
							
							window.deleteAllChildNodes && window.deleteAllChildNodes(this);
							
							this.append(noSubscriptionsTextElement);
						}
					} catch (error) {
						console.error(error);
					} finally {
						return;
					}
				}
				
				const TRANSIT_ALERTS_MODULE_URL_STRING = "/js/transitAlerts.mjs";
				
				var transitAlertsModuleURL = TRANSIT_ALERTS_MODULE_URL_STRING && new URL(TRANSIT_ALERTS_MODULE_URL_STRING, document.location.origin);
				
				var { fetchAllAlertsByMode } = transitAlertsModuleURL && await import(transitAlertsModuleURL);
				
				var allAlertsByMode = fetchAllAlertsByMode && await fetchAllAlertsByMode;
				
				var allFoundAlertsForValidAlertSubscriptionsByGTFSModeNumber = new Map();
				
				//??? do we show alerts in 'alerts page order' or in 'mode order'?
				allAlertsByMode.forEach(curModeAlerts => {
					//GUARD: do nothing if curModeAlerts is not an object
					if (!curModeAlerts || getType(curModeAlerts) !== getType.object) {
						return;
					}
					
					curModeAlerts && Object.keys(curModeAlerts).forEach(targetGTFSItemNumber => {  //??? this is a horrendous variable name, not even close
						var allCurAlerts = curModeAlerts[targetGTFSItemNumber];
						
						//GUARD: do nothing if there are no alerts found for the target GTFS Items
						if (!allCurAlerts || allCurAlerts.length === 0) {
							return;
						}
						
						var gtfsModeNumber = allCurAlerts[0].group;  //??? is this a number or a string
						
						//GUARD: do nothing if there is no mode number
						if (!gtfsModeNumber && gtfsModeNumber !== 0) {
							return;
						}
						
						var candidateGTFSStationNumber = window.GTFS_STATION_NAMES_TO_STATION_NUMBERS[targetGTFSItemNumber];
						var gtfsStationName = candidateGTFSStationNumber !== undefined ? targetGTFSItemNumber : undefined;
						
						targetGTFSItemNumber = candidateGTFSStationNumber ? candidateGTFSStationNumber : targetGTFSItemNumber;
						
						var isCurModeAlertForAValidAlertSubscription = targetGTFSItemNumber && validAlertSubscriptionGTFSItemNumbers.includes(targetGTFSItemNumber) === true;  //??? rename variable; completely wrong
						
						if (isCurModeAlertForAValidAlertSubscription === true) {
							//??? some terrible variables names that need to be replaced
							var allExistingFoundAlertsForValidAlertSubscriptionsForGTFSModeNumber = allFoundAlertsForValidAlertSubscriptionsByGTFSModeNumber.has(gtfsModeNumber) && allFoundAlertsForValidAlertSubscriptionsByGTFSModeNumber.get(gtfsModeNumber);
							
							if (!allExistingFoundAlertsForValidAlertSubscriptionsForGTFSModeNumber) {
								allExistingFoundAlertsForValidAlertSubscriptionsForGTFSModeNumber = [];
							}
							
							var foundAlerts = curModeAlerts[gtfsStationName || targetGTFSItemNumber];
							
							allExistingFoundAlertsForValidAlertSubscriptionsForGTFSModeNumber.push(foundAlerts[0]);
							
							allFoundAlertsForValidAlertSubscriptionsByGTFSModeNumber.set(gtfsModeNumber, allExistingFoundAlertsForValidAlertSubscriptionsForGTFSModeNumber);
						}
					});
				});
				
				if (allFoundAlertsForValidAlertSubscriptionsByGTFSModeNumber.size > 0) {
					var alertsHeading = document.createElement("h3");
					alertsHeading.textContent = "My Alert Subscriptions";
					
					window.deleteAllChildNodes && window.deleteAllChildNodes(this);
					
					this.append(alertsHeading);
					
					var MODE_NUMBERS_IN_ALERTS_ORDER = [3, 1, 2, 4, 715, 6];
					
					MODE_NUMBERS_IN_ALERTS_ORDER.forEach(curModeNumber => {
						var foundGTFSItemNumbers = new Set();
						
						var allAlertItems = [];
						
						var allFoundAlertsForValidAlertSubscriptionsForCurModeNumber = allFoundAlertsForValidAlertSubscriptionsByGTFSModeNumber.get(curModeNumber);
						
						allFoundAlertsForValidAlertSubscriptionsForCurModeNumber && allFoundAlertsForValidAlertSubscriptionsForCurModeNumber.forEach(curAlert => {
							//??? rename variable
							var curAlertAccordionElement = window.buildAlertAccordion(curAlert, false);
							
							//GUARD: do nothing if there is no alert accordion
							if (!curAlertAccordionElement) {
								return;
							}
							
							var gtfsItemNumber = curAlert.routeId || curAlert.stationName;
							
							//GUARD: do nothing if this GTFS item has already been rendered
							if (foundGTFSItemNumbers.has(gtfsItemNumber) === true) {
								return;
							}
							
							foundGTFSItemNumbers.add(gtfsItemNumber);
							
							var transitAlertsElement = document.createElement("transit-alerts");
							transitAlertsElement.setAttribute("data-timeframe", "all");
							transitAlertsElement.setAttribute("data-gtfs-mode-number", curModeNumber);
							transitAlertsElement.setAttribute("data-gtfs-routeline-number", gtfsItemNumber);
							
							curAlertAccordionElement.append(transitAlertsElement);
							
							allAlertItems.push(curAlertAccordionElement);
						});
						
						var isLexicalSortedAscending = (lhs, rhs) => {
							if (lhs === "" && rhs === "") {
								return 0;
							}
							
							var items = [lhs, rhs];
							
							var collator = new Intl.Collator(undefined, { numeric: true, sensitivity: "base"});
							
							items.sort(collator.compare);
							
							if (items[0] === rhs) {
								return 1;
							} else {
								return -1;
							}
						};
						
						allAlertItems.sort((lhs, rhs) => {
							var lhsGTFSIDElement = lhs.querySelector("[data-gtfs-routeline-number]");
							var lhsGTFSID = lhsGTFSIDElement && lhsGTFSIDElement.getAttribute("data-gtfs-routeline-number") || "";
							
							var rhsGTFSIDElement = rhs.querySelector("[data-gtfs-routeline-number]");
							var rhsGTFSID = rhsGTFSIDElement && rhsGTFSIDElement.getAttribute("data-gtfs-routeline-number") || "";
							
							var output = (lhsGTFSID === "" && rhsGTFSID === "") ? 0 : isLexicalSortedAscending(lhsGTFSID, rhsGTFSID);
							
							return output;
						});
						
						allAlertItems.forEach(curAlertItem => {
							curAlertItem && this.append(curAlertItem);
						});
					});
				} else {
					var noAlertsForSubscriptionsTextElement = document.createElement("p");
					noAlertsForSubscriptionsTextElement.textContent = "There are no alerts for your current alert subscriptions.";
					
					window.deleteAllChildNodes && window.deleteAllChildNodes(this);
					
					this.append(noAlertsForSubscriptionsTextElement);
				}
			} catch (error) {
				console.error(error);
			}
		};
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#displayAlerts();
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) { }
	});
</script><script class="infomapsTimetableLink">
	customElements.define("infomaps-timetable-link", class InfomapsTimetableLink extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-target-routeline-number"
				, "data-target-date"
			];
		}
		
		#targetRouteLineNumber = window.GTFS && (window.GTFS.lineNumber || window.GTFS.routeNumber);
		#targetDashDelimitedDateString = "";
		
		#noPDFFoundMessageElement;
		#noPDFFoundMessage = "This timetable is not available yet";
		
		#isRendering = false;
		
		async #render() {
			//GUARD: do nothing if rendering is already occuring
			if (this.#isRendering === true) {
				return;
			}
			
			this.#isRendering = true;
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			this.textContent = "";
			
			//GUARD: do nothing if there is no target GTFS route line number
			if (!this.#targetRouteLineNumber) {
				this.#isRendering = false;
				
				return;
			}
			
			if (!this.#noPDFFoundMessageElement) {
				this.#noPDFFoundMessageElement = document.createElement("p");
				this.#noPDFFoundMessageElement.setAttribute("style", "margin: 0px;");
				this.#noPDFFoundMessageElement.textContent = this.#noPDFFoundMessage;
			}
			
			try {
				//???? replace with:  var fileSizeInBytes = await fetchFilesizeForInfomapTimetableForGTFSRouteLineForDate(paddedGTFSRouteLineNumber, targetDashDelimitedDateString);  (import from GTFS Items)
				const GTFS_SHEET_MODULE_URL_STRING = "/js/gtfsSheet.mjs"; 
				
				var gtfsSheetModuleURL = GTFS_SHEET_MODULE_URL_STRING && new URL(GTFS_SHEET_MODULE_URL_STRING, document.location.origin);
				
				var { fetchCurSheetNumber, fetchCurSheetNumberForDate } = gtfsSheetModuleURL && await import(gtfsSheetModuleURL);
				
				var curSheetNumber;
				
				if (this.#targetDashDelimitedDateString) {
					curSheetNumber = fetchCurSheetNumberForDate && await fetchCurSheetNumberForDate(this.#targetDashDelimitedDateString);
				} else {
					curSheetNumber = fetchCurSheetNumber && await fetchCurSheetNumber;
				}
				
				//GUARD: do nothing if there is no target GTFS sheet number
				if (!curSheetNumber && curSheetNumber !== 0) {
					this.append(this.#noPDFFoundMessageElement);
					
					return;
				}
				
				var paddedGTFSRouteLineNumber = window.getPaddedGTFSRouteLineNumber(this.#targetRouteLineNumber);
				
				try {
					var downloadLinkURLString = `https://infomaps.translink.ca/Public_Timetables/${curSheetNumber}/tt${paddedGTFSRouteLineNumber}.pdf`;
					var downloadLinkURL = downloadLinkURLString && new URL(downloadLinkURLString);
					
					var response = downloadLinkURL && await fetch(downloadLinkURL, { method: "HEAD" });
					
					if (response && response.ok === true) {
						var fileSizeText = "";
						var fileSizeInBytesAsString = response.headers.get("content-length");
						
						if (fileSizeInBytesAsString) {
							var fileSizeInBytes = parseInt(fileSizeInBytesAsString, 10);
							var formattedFileSizeInKB;
							
							if (fileSizeInBytes) {
								const NUMBER_OF_BYTES_IN_KILOBYTE = 1024;
								const NUMBER_OF_KILOBYTES_IN_MEGABYTE = 1024;
								
								var fileSizeInKB = fileSizeInBytes / NUMBER_OF_BYTES_IN_KILOBYTE;
								
								if (fileSizeInKB > 100) {
									var fileSizeInMB = fileSizeInKB / NUMBER_OF_KILOBYTES_IN_MEGABYTE;
									fileSizeInMB = Math.ceil(fileSizeInMB * 10) / 10;
									
									fileSizeText = ` (${fileSizeInMB} MB)`;
								} else if (fileSizeInKB < 100 && fileSizeInKB > 1) {
									formattedFileSizeInKB = Math.ceil(fileSizeInKB);
									fileSizeText = ` (${Math.ceil(formattedFileSizeInKB)} KB)`;
								} else {
									formattedFileSizeInKB = Math.ceil(fileSizeInKB * 10) / 10;
									fileSizeText = ` (${Math.ceil(formattedFileSizeInKB)} KB)`;
								}
							}
						}
						
						var linkName = `Timetable PDF${fileSizeText}`;  //??? unhardcode? make a class constant?
						
						var infomapLinkElement = document.createElement("a");
						infomapLinkElement.setAttribute("href", downloadLinkURL);
						infomapLinkElement.setAttribute("target", "_blank");
						infomapLinkElement.textContent = linkName;
						
						this.append(infomapLinkElement);
					} else {
						this.append(this.#noPDFFoundMessageElement);
					}
				} catch (error) {
					console.error(error);
				}
			} catch (error) {
				console.error(error);
			} finally {
				this.#isRendering = false;
			}
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#render();
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-target-routeline-number":
					; (() => {
						this.#targetRouteLineNumber = curValue;
					})();
					
					break;
				case "data-target-date":
					; (() => {
						this.#targetDashDelimitedDateString = curValue;  //??? add validation?
						
						this.#targetRouteLineNumber && this.#render();  //??? add additional validation before rendering?
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="infomapsRouteLineMapLink">
	customElements.define("infomaps-routeline-map-link", class InfomapsRouteLineMapLink extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-target-routeline-number"
				, "data-target-date"
			];
		}
		
		#targetRouteLineNumber = window.GTFS && (window.GTFS.lineNumber || window.GTFS.routeNumber);
		#targetDashDelimitedDateString = "";
		
		#noPDFFoundMessageElement;
		#noPDFFoundMessage = "This map is not available yet";
		
		#isRendering = false;
		
		async #render() {
			//GUARD: do nothing if rendering is already occuring
			if (this.#isRendering === true) {
				return;
			}
			
			this.#isRendering = true;
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			this.textContent = "";
			
			//GUARD: do nothing if there is no target GTFS route line number
			if (!this.#targetRouteLineNumber) {
				this.#isRendering = false;
				
				return;
			}
			
			if (!this.#noPDFFoundMessageElement) {
				this.#noPDFFoundMessageElement = document.createElement("p");
				this.#noPDFFoundMessageElement.setAttribute("style", "margin: 0px;");
				this.#noPDFFoundMessageElement.textContent = this.#noPDFFoundMessage;
			}
			
			try {
				//???? replace with:  var fileSizeInBytes = await fetchFilesizeForInfomapMapForGTFSRouteLineForDate(paddedGTFSRouteLineNumber, targetDashDelimitedDateString);  (import from GTFS Items)
				const GTFS_SHEET_MODULE_URL_STRING = "/js/gtfsSheet.mjs"; 
				
				var gtfsSheetModuleURL = GTFS_SHEET_MODULE_URL_STRING && new URL(GTFS_SHEET_MODULE_URL_STRING, document.location.origin);
				
				var { fetchCurSheetNumber, fetchCurSheetNumberForDate } = gtfsSheetModuleURL && await import(gtfsSheetModuleURL);
				
				var curSheetNumber;
				
				if (this.#targetDashDelimitedDateString) {
					curSheetNumber = fetchCurSheetNumberForDate && await fetchCurSheetNumberForDate(this.#targetDashDelimitedDateString);
				} else {
					curSheetNumber = fetchCurSheetNumber && await fetchCurSheetNumber;
				}
				
				//GUARD: do nothing if there is no target GTFS sheet number
				if (!curSheetNumber && curSheetNumber !== 0) {
					this.append(this.#noPDFFoundMessageElement);
					
					return;
				}
				
				var paddedGTFSRouteLineNumber = window.getPaddedGTFSRouteLineNumber(this.#targetRouteLineNumber);
				
				try {
					var downloadLinkURLString = `https://infomaps.translink.ca/Route_Diagrams/${curSheetNumber}/r${paddedGTFSRouteLineNumber}.pdf`;
					var downloadLinkURL = downloadLinkURLString && new URL(downloadLinkURLString);
					
					var response = downloadLinkURL && await fetch(downloadLinkURL, { method: "HEAD" });
					
					if (response && response.ok === true) {
						var fileSizeText = "";
						var fileSizeInBytesAsString = response.headers.get("content-length");
						
						if (fileSizeInBytesAsString) {
							var fileSizeInBytes = parseInt(fileSizeInBytesAsString, 10);
							
							if (fileSizeInBytes) {
								const NUMBER_OF_BYTES_IN_KILOBYTE = 1024;
								const NUMBER_OF_KILOBYTES_IN_MEGABYTE = 1024;
								
								var fileSizeInKB = fileSizeInBytes / NUMBER_OF_BYTES_IN_KILOBYTE;
								var formattedFileSizeInKB;
								
								if (fileSizeInKB > 100) {
									var fileSizeInMB = fileSizeInKB / NUMBER_OF_KILOBYTES_IN_MEGABYTE;
									fileSizeInMB = Math.ceil(fileSizeInMB * 10) / 10;
									
									fileSizeText = ` (${fileSizeInMB} MB)`;
								} else if (fileSizeInKB < 100 && fileSizeInKB > 1) {
									formattedFileSizeInKB = Math.ceil(fileSizeInKB);
									fileSizeText = ` (${Math.ceil(formattedFileSizeInKB)} KB)`;
								} else {
									formattedFileSizeInKB = Math.ceil(fileSizeInKB * 10) / 10;
									fileSizeText = ` (${Math.ceil(formattedFileSizeInKB)} KB)`;
								}
							}
						}
						
						var linkName = window.GTFS_LINE_NUMBERS.includes(this.#targetRouteLineNumber) === true ? `Line Map PDF${fileSizeText}` : `Route Map PDF${fileSizeText}`;
						
						var infomapLinkElement = document.createElement("a");
						infomapLinkElement.setAttribute("href", downloadLinkURL);
						infomapLinkElement.setAttribute("target", "_blank");
						infomapLinkElement.textContent = linkName;
						
						this.append(infomapLinkElement);
					} else {
						this.append(this.#noPDFFoundMessageElement);
					}
				} catch (error) {
					console.error(error);
				}
			} catch (error) {
				console.error(error);
			} finally {
				this.#isRendering = false;
			}
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#render();
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-target-routeline-number":
					; (() => {
						this.#targetRouteLineNumber = curValue;
					})();
					
					break;
				case "data-target-date":
					; (() => {
						this.#targetDashDelimitedDateString = curValue;  //??? add validation?
						
						this.#targetRouteLineNumber && this.#render();  //??? add additional validation before rendering?
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="stationElevatorMapLink">
	customElements.define("station-elevator-map-link", class StationElevatorMapLink extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		#targetGTFSStationName = window.GTFS && window.GTFS.stationName;
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			//GUARD: do nothing if no station name was provided
			if (!this.#targetGTFSStationName) {
				return;
			}
			
			var STATION_NAMES_WITHOUT_MAP_PDFS = new Set([
				"Port Coquitlam Station"
				, "Pitt Meadows Station"
				, "Maple Meadows Station"
				, "Port Haney Station"
				, "Mission City Station"
				, "Lonsdale Quay Station"
			]);
			
			//GUARD: do nothing if the station is known to not have station map PDFs
			if (STATION_NAMES_WITHOUT_MAP_PDFS.has(this.#targetGTFSStationName) === true) {
				return;
			}
			
			var formattedStationName = this.#targetGTFSStationName.toLowerCase().replaceAll("-", "_").replaceAll(" ", "_");
			
			try {
				const downloadLinkURLString = `/-/media/translink/documents/schedules-and-maps/skytrain-accessible-entrance-maps/${formattedStationName}_elevator_map.pdf`;
				var downloadLinkURL = downloadLinkURLString && new URL(downloadLinkURLString, document.location.origin);
				
				var infomapLinkElement = document.createElement("a");
				infomapLinkElement.setAttribute("href", downloadLinkURL);
				infomapLinkElement.setAttribute("target", "_blank");
				infomapLinkElement.textContent = "Station Accessible Entrance Map PDF";  //??? unhardcode?
				
				this.append(infomapLinkElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) { }
	});
</script><script class="stationMapLink">
	customElements.define("station-map-link", class StationMapLink extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		#targetGTFSStationName = window.GTFS && window.GTFS.stationName;
		
		#noPDFFoundMessageElement;
		#noPDFFoundMessage = "This map is not available yet";
		
		#isRendering = false;
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			//GUARD: do nothing if rendering is already occuring
			if (this.#isRendering === true) {
				return;
			}
			
			this.#isRendering = true;
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			this.textContent = "";
			
			//GUARD: do nothing if no station name was provided
			if (!this.#targetGTFSStationName) {
				this.#isRendering = false;
				
				return;
			}
			
			if (!this.#noPDFFoundMessageElement) {
				this.#noPDFFoundMessageElement = document.createElement("p");
				this.#noPDFFoundMessageElement.setAttribute("style", "margin: 0px;");
				this.#noPDFFoundMessageElement.textContent = this.#noPDFFoundMessage;
			}
			
			var STATION_NAMES_WITHOUT_MAP_PDFS = new Set([
				"Port Coquitlam Station"
				, "Pitt Meadows Station"
				, "Maple Meadows Station"
				, "Port Haney Station"
				, "Mission City Station"
				, "Lonsdale Quay Station"
			]);
			
			//GUARD: do nothing if the station is known to not have station map PDFs
			if (STATION_NAMES_WITHOUT_MAP_PDFS.has(this.#targetGTFSStationName) === true) {
				return;
			}
			
			var formattedStationName = this.#targetGTFSStationName
									   .toLowerCase()
									   .replaceAll("-", "_")
									   .replaceAll(" ", "_");
			
			try {
				//??? this needs to be part of "GTFSItems.mjs"
				const downloadLinkURLString = `https://infomaps.translink.ca/system_maps/skytrain_station_maps/${formattedStationName}.pdf`;
				var downloadLinkURL = downloadLinkURLString && new URL(downloadLinkURLString);
				
				var response = downloadLinkURL && await fetch(downloadLinkURL, {
					method: "HEAD"
				});
				
				if (response && response.ok === true) {
					var fileSizeText = "";
					var fileSizeInBytesAsString = response.headers.get("content-length");
					
					if (fileSizeInBytesAsString) {
						var fileSizeInBytes = parseInt(fileSizeInBytesAsString, 10);
						
						if (fileSizeInBytes) {
							const NUMBER_OF_BYTES_IN_KILOBYTE = 1024;
							const NUMBER_OF_KILOBYTES_IN_MEGABYTE = 1024;
							
							var fileSizeInKB = fileSizeInBytes / NUMBER_OF_BYTES_IN_KILOBYTE;
							var formattedFileSizeInKB;
							
							if (fileSizeInKB > 100) {
								var fileSizeInMB = fileSizeInKB / NUMBER_OF_KILOBYTES_IN_MEGABYTE;
								fileSizeInMB = Math.ceil(fileSizeInMB * 10) / 10;
								
								fileSizeText = ` (${fileSizeInMB} MB)`;
							} else if (fileSizeInKB < 100 && fileSizeInKB > 1) {
								formattedFileSizeInKB = Math.ceil(fileSizeInKB);
								fileSizeText = ` (${Math.ceil(formattedFileSizeInKB)} KB)`;
							} else {
								formattedFileSizeInKB = Math.ceil(fileSizeInKB * 10) / 10;
								fileSizeText = ` (${Math.ceil(formattedFileSizeInKB)} KB)`;
							}
						}
					}
					
					var infomapLinkElement = document.createElement("a");
					infomapLinkElement.setAttribute("href", downloadLinkURL);
					infomapLinkElement.setAttribute("target", "_blank");
					infomapLinkElement.textContent = `Station Map PDF${fileSizeText}`;
					
					this.append(infomapLinkElement);
				} else {
					this.append(this.#noPDFFoundMessageElement);
				}
			} catch (error) {
				console.error(error);
				
				this.append(this.#noPDFFoundMessageElement);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) { }
	});
</script><script type="module" class="gtfsWheelchairAccessibilityIndicator">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { fetchGTFSStopsByNumber, fetchGTFSStopSchedulesForDate } from "/js/gtfsStops.mjs";
	import { GTFS_STATION_NUMBERS, fetchGTFSStationsByNumber, fetchGTFSStationSchedulesForDate  } from "/js/gtfsStations.mjs";
	
	customElements.define("gtfs-wheelchair-accessibility-indicator", class GTFSWheelchairAccessibilityIndicator extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-infowindow"
			];
		}
		
		#targetGTFSLocationNumber = window.GTFS.stopNumber || window.GTFS.stationId;
		#targetInfoWindowName;
		
		#render = async () => {
			var targetGTFSLocationNumber = this.#targetGTFSLocationNumber;
			
			//GUARD: do nothing if there is no target GTFS Location Number
			if (getType(this.#targetGTFSLocationNumber) !== getType.string) {
				return;
			}
			
			//GUARD: do nothing if there is no target InfoWindow
			if (getType(this.#targetInfoWindowName) !== getType.string) {
				return;
			}
			
			try {
				var isGTFSStation = GTFS_STATION_NUMBERS.has(targetGTFSLocationNumber) === true;
				
				var allGTFSLocations;
				
				if (isGTFSStation === true) {
					allGTFSLocations = await fetchGTFSStationsByNumber;  //??? since this is a station, can it be optimized because it doesn't need an actual real API call because of the GTFSStations.json file?
				} else {
					allGTFSLocations = await fetchGTFSStopsByNumber;
				}
				
				//GUARD: do nothing if there are no GTFS Locations
				if (getType(allGTFSLocations) !== getType.map) {
					return;
				}
				
				if (allGTFSLocations.size === 0) {
					return;
				}
				
				if (allGTFSLocations.has(targetGTFSLocationNumber) === true) {
					var curGTFSStopScheduleForToday;
					
					if (isGTFSStation === true) {
						curGTFSStopScheduleForToday = await fetchGTFSStationSchedulesForDate(targetGTFSLocationNumber, new Date());
					} else {
						curGTFSStopScheduleForToday = await fetchGTFSStopSchedulesForDate(targetGTFSLocationNumber, new Date());
					}
					
					if (getType(curGTFSStopScheduleForToday) === getType.array) {
						/*
						var wheelchairAccessibleInfowindowButton = document.createElement("button");
						wheelchairAccessibleInfowindowButton.setAttribute("data-infowindow", this.#targetInfoWindowName);
						wheelchairAccessibleInfowindowButton.setAttribute("data-no-infowindow-icon", "");
						wheelchairAccessibleInfowindowButton.setAttribute("style", "font-size: 0px !important;");
						wheelchairAccessibleInfowindowButton.textContent = "Stop Details";
						*/
						
						var gtfsWheelChairValue = curGTFSStopScheduleForToday[0].wc;  //??? need to document this [0]?
						
						switch (gtfsWheelChairValue) {
							case 1:  //NOTE: wheelchair accessible
								; (() => {
									try {
										const WHEELCHAIR_SUPPORTED_ICON_URL_STRING = "/-/media/translink/icons/transit-schedules/wheelchair_yes_24x24_v3.svg";
										var wheelchairSupportedIconURL = WHEELCHAIR_SUPPORTED_ICON_URL_STRING && new URL(WHEELCHAIR_SUPPORTED_ICON_URL_STRING, document.location.origin);
										
										//GUARD: do nothing if there is no wheelchair icon URL
										if (getType(wheelchairSupportedIconURL) !== getType.url) {
											return; //??? log this error?
										}
										
										var wheelchairAccessibleIconElement = document.createElement("img");
										wheelchairAccessibleIconElement.setAttribute("alt", "Wheelchair Access Icon");
										wheelchairAccessibleIconElement.setAttribute("src", wheelchairSupportedIconURL);
										wheelchairAccessibleIconElement.setAttribute("width", 24);
										wheelchairAccessibleIconElement.setAttribute("height", 24);
										wheelchairAccessibleIconElement.setAttribute("style", "width: 24px; height: 24px;");
										
										window.deleteAllChildNodes && window.deleteAllChildNodes(this);
										this.textContent = "";
										
										/*
										wheelchairAccessibleInfowindowButton.append(wheelchairAccessibleIconElement);
										
										this.append(wheelchairAccessibleInfowindowButton);
										*/
										
										this.append(wheelchairAccessibleIconElement);
									} catch (error) {
										console.error(error);
									}
								})();
								
								break;
							case 2:  //NOTE: no wheelchair access
								; (() => {
									try {
										const WHEELCHAIR_NOT_SUPPORTED_ICON_URL_STRING = "/-/media/translink/icons/transit-schedules/wheelchair_no_24x24_v3.svg";
										var wheelchairNotSupportedIconURL = WHEELCHAIR_NOT_SUPPORTED_ICON_URL_STRING && new URL(WHEELCHAIR_NOT_SUPPORTED_ICON_URL_STRING, document.location.origin);
											
										//GUARD: do nothing if there is no wheelchair-not-supported icon URL
										if (getType(wheelchairNotSupportedIconURL) !== getType.url) {
											return; //??? log this error?
										}
										
										var wheelchairInaccessibleIconElement = document.createElement("img");
										wheelchairInaccessibleIconElement.setAttribute("alt", "No Wheelchair Access Icon");
										wheelchairInaccessibleIconElement.setAttribute("src", wheelchairNotSupportedIconURL);
										wheelchairInaccessibleIconElement.setAttribute("width", 24);
										wheelchairInaccessibleIconElement.setAttribute("height", 24);
										wheelchairInaccessibleIconElement.setAttribute("style", "width: 24px; height: 24px;");
										
										window.deleteAllChildNodes && window.deleteAllChildNodes(this);
										this.textContent = "";
										
										/*
										wheelchairAccessibleInfowindowButton.append(wheelchairInaccessibleIconElement);
										
										this.append(wheelchairAccessibleInfowindowButton);
										*/
										
										this.append(wheelchairInaccessibleIconElement);
									} catch (error) {
										console.error(error);
									}
								})();
								
								break;
						}
					}
				}
			} catch (error) {
				console.error(error);
			}
		};
		
		#isInited = false;
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			window.createLazyLoader({
				lazyLoadTargets: this
				, onLoadFunction: () => {
					this.#render.bind(this)();
				}
			});
			
			this.#isInited = true;
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-infowindow":
					; (() => {
						if (getType(curValue) === getType.string) {
							this.#targetInfoWindowName = curValue;
						}
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="countdownTimer">
	customElements.define("countdown-timer", class countdownTimer extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-start-time-in-seconds"
				, "data-singular-suffix-text"
				, "data-multiples-suffix-text"
				, "data-do-not-display-zero-seconds"
			];
		}
		
		#startTimeInSeconds;
		#singularSuffixText = "second";
		#multiplesSuffixText = "seconds";
		#isDoNotDisplayZeroSeconds = true;
		
		#timeDisplayElement;
		
		#displayTime(elapsedSeconds) {
			//GUARD: do nothing if there is no start time
			if (this.#startTimeInSeconds === undefined) {
				return;
			}
			
			var startingTime = parseInt(this.#startTimeInSeconds, 10);
			
			var curRemainingTimeInSeconds = Math.max(startingTime - elapsedSeconds, 0);
			
			if (curRemainingTimeInSeconds === 0 && this.#isDoNotDisplayZeroSeconds === true) {
				curRemainingTimeInSeconds = 1;
			}
			
			var timeText = curRemainingTimeInSeconds;
			
			if (this.#singularSuffixText && this.#multiplesSuffixText) {
				if (curRemainingTimeInSeconds === 1) {
					timeText = `${curRemainingTimeInSeconds} ${this.#singularSuffixText}`;
				} else {
					timeText = `${curRemainingTimeInSeconds} ${this.#multiplesSuffixText}`;
				}
			}
			
			this.#timeDisplayElement.textContent = timeText;
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#timeDisplayElement = document.createElement("span");
			this.#timeDisplayElement.setAttribute("style", "display: contents;");
			this.#timeDisplayElement.textContent = this.#startTimeInSeconds;
			
			this.append(this.#timeDisplayElement);
			
			var start = document.timeline.currentTime;
			
			var frame = time => {
				var elapsed = time - start;
				var seconds = Math.round(elapsed / 1000);
				
				this.#displayTime(seconds);
				
				var targetNext = (seconds + 1) * 1000 + start;
				
				window.setTimeout(() => {
					window.requestAnimationFrame(frame);
				}, targetNext - performance.now());
			};
			
			frame(start);
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-start-time-in-seconds":
					; (() => {
						if (this.#startTimeInSeconds === undefined) {
							this.#startTimeInSeconds = curValue;
						}
					})();
					
					break;
				case "data-singular-suffix-text":
					; (() => {
						this.#singularSuffixText = curValue;
					})();
					
					break;
				case "data-multiples-suffix-text":
					; (() => {
						this.#multiplesSuffixText = curValue;
					})();
					
					break;
				case "data-do-not-display-zero-seconds":
					; (() => {
						this.#isDoNotDisplayZeroSeconds = curValue === "false" ? false : true;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="transitNearMeLink">
	customElements.define("transit-near-me-link", class TransitNearMeLink extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-icon-url"
				, "data-icon-width"
				, "data-icon-height"
			];
		}
		
		#iconURL;
		#iconWidthInPx;
		#iconHeightInPx;
		
		async #render() {
			const NEXT_BUS_SETTINGS_MODULE_URL_STRING = "/js/NextBusSettings.mjs";
			
			var nextBusSettingsModuleURL = NEXT_BUS_SETTINGS_MODULE_URL_STRING && new URL(NEXT_BUS_SETTINGS_MODULE_URL_STRING, document.location.origin);
			
			var { NextBusSettings } = nextBusSettingsModuleURL && await import(nextBusSettingsModuleURL);  //??? import needs to be inside try-catch
			
			var nextBusViewPreference = NextBusSettings && NextBusSettings.getSetting("viewPreference") || "text";  //??? remove hardcoding?  maybe put a const like 'NextBusSettings.getDefaultValueForSetting("viewPreference")'
			
			//GUARD: remove link if a preference cannot be found
			if (!nextBusViewPreference) {
				this.remove();
				
				return;
			}
			
			nextBusViewPreference = nextBusViewPreference && nextBusViewPreference.toLowerCase();
			
			var transitNearMePageURLString = "";
			
			switch (nextBusViewPreference) {
				case "text":
					; (() => {
						transitNearMePageURLString = "/next-bus/stops-and-stations-nearby";
					})();
					
					break;
				case "map":
					; (() => {
						transitNearMePageURLString = "/next-bus/stops-and-stations-nearby/map";
					})();
					
					break;
				default:
					; (() => {
						
					})();
					
					break;
			}
			
			try {
				var transitNearMePageURL = transitNearMePageURLString && new URL(transitNearMePageURLString, document.location.origin);
				
				var transitNearMePageLinkElement = document.createElement("a");
				transitNearMePageLinkElement.setAttribute("href", transitNearMePageURL);
				transitNearMePageLinkElement.setAttribute("class", "flexContainer");
				transitNearMePageLinkElement.setAttribute("style", "gap: 0.5rem;");
				
				var transitNearMePageLinkIconElement;
				
				if (this.#iconURL && this.#iconWidthInPx && this.#iconHeightInPx) {
					var transitNearMePageLinkIconURLString = this.#iconURL;
					var transitNearMePageLinkIconWidthInPx = this.#iconWidthInPx;
					var transitNearMePageLinkIconHeightInPx = this.#iconHeightInPx;
					
					var transitNearMePageLinkIconURL = transitNearMePageLinkIconURLString && new URL(transitNearMePageLinkIconURLString, document.location.origin);
					
					transitNearMePageLinkIconElement = document.createElement("img");
					transitNearMePageLinkIconElement.setAttribute("role", "presentation");
					transitNearMePageLinkIconElement.setAttribute("src", transitNearMePageLinkIconURL);
					transitNearMePageLinkIconElement.setAttribute("width", transitNearMePageLinkIconWidthInPx);
					transitNearMePageLinkIconElement.setAttribute("height", transitNearMePageLinkIconHeightInPx);
					transitNearMePageLinkIconElement.setAttribute("loading", "lazy");
					transitNearMePageLinkIconElement.setAttribute("decoding", "async");
					transitNearMePageLinkIconElement.setAttribute("style", `width: ${transitNearMePageLinkIconWidthInPx}px;`);
					transitNearMePageLinkIconElement.setAttribute("aria-hidden", true);
				}
				
				var transitNearMePageLinkTextElement = document.createElement("span");
				transitNearMePageLinkTextElement.textContent = this.textContent;
				
				transitNearMePageLinkIconElement && transitNearMePageLinkElement.append(transitNearMePageLinkIconElement);
				transitNearMePageLinkIconElement && transitNearMePageLinkElement.append(document.createTextNode(" "));
				transitNearMePageLinkElement.append(transitNearMePageLinkTextElement);
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(transitNearMePageLinkElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#render();
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-icon-url":
					; (() => {
						var iconURL = curValue && new URL(curValue, document.location.origin);
						
						//GUARD: do nothing if there is no valid icon URL
						if (!iconURL) {
							return;
						}
						
						this.#iconURL = iconURL;
						
						this.#iconURL && this.#iconWidthInPx && this.#iconHeightInPx && this.#render();
					})();
					
					break;
				case "data-icon-width":
					; (() => {
						this.#iconWidthInPx = parseInt(curValue, 10);
						
						this.#iconURL && this.#iconWidthInPx && this.#iconHeightInPx && this.#render();
					})();
					
					break;
				case "data-icon-height":
					; (() => {
						this.#iconHeightInPx = parseInt(curValue, 10);
						
						this.#iconURL && this.#iconWidthInPx && this.#iconHeightInPx && this.#render();
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="gtfsLocationName">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { fetchGTFSStationNamesByNumber } from "/js/gtfsStations.mjs";
	import { fetchGTFSStopNamesByNumber } from "/js/gtfsStops.mjs";
	
	customElements.define("gtfs-location-name", class GTFSLocationName extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-target-gtfs-location-number"
			];
		}
		
		#targetGTFSLocationNumber;
		
		#render = async () => {
			//GUARD: do nothing if there is no target GTFS Location Number
			if (!this.#targetGTFSLocationNumber) {
				return;
			}
			
			try {
				var [allGTFSStopNamesByNumber, allGTFSStationNamesByNumber] = await Promise.all([
					fetchGTFSStopNamesByNumber
					, fetchGTFSStationNamesByNumber
				]);
				
				var allGTFSLocationNamesByNumber = new Map([...allGTFSStopNamesByNumber, ...allGTFSStationNamesByNumber]);
				
				var curGTFSLocationName = allGTFSLocationNamesByNumber && allGTFSLocationNamesByNumber.get(this.#targetGTFSLocationNumber);
				
				//GUARD: do nothing if there is no GTFS Location name
				if (getType(curGTFSLocationName) !== getType.string) {
					return;
				}
				
				//??? should these direction string replacements be hardcoded somewhere?
				curGTFSLocationName = curGTFSLocationName
				.replaceAll("Northbound ", "")
				.replaceAll("Eastbound ", "")
				.replaceAll("Southbound ", "")
				.replaceAll("Westbound ", "")
				.trim();
				
				var curGTFSLocationNameTextElement = document.createElement("span");
				curGTFSLocationNameTextElement.setAttribute("style", "font: inherit;");
				curGTFSLocationNameTextElement.textContent = curGTFSLocationName;
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(curGTFSLocationNameTextElement);
			} catch (error) {
				console.error(error);
			}
		};
		
		#isInited = false;
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#render();
			
			this.#isInited = true;
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-target-gtfs-location-number":
					; (() => {
						this.#targetGTFSLocationNumber = curValue;  //??? validate?
						
						if (this.#isInited === true) {
							this.#render();
						}
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="gtfsStopDirection">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { fetchGTFSStopNamesByNumber } from "/js/gtfsStops.mjs";
	
	customElements.define("gtfs-stop-direction", class GTFSStopDirection extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-target-gtfs-stop-number"
				, "data-prefix-text"
				, "data-suffix-text"
			];
		}
		
		#targetGTFSStopNumber;
		
		#prefixText = "";
		#suffixText = "";
		
		#render = async () => {
			//GUARD: do nothing if there is no target GTFS Stop Number
			if (!this.#targetGTFSStopNumber) {
				return;
			}
			
			try {
				var allGTFSStopNamesByNumber = await fetchGTFSStopNamesByNumber;
				
				var curGTFSStopName = allGTFSStopNamesByNumber && allGTFSStopNamesByNumber.get(this.#targetGTFSStopNumber);
				
				//GUARD: do nothing if there is no GTFS Stop name
				if (getType(curGTFSStopName) !== getType.string) {
					return;
				}
				
				var curGTFSStopBoundDirection = "";
				
				//??? need to wrap this into a 'getBoundDirectionFromGTFSStopName'; should be part of "GTFSItems.mjs"
				if (curGTFSStopName.toLowerCase().includes("northbound ") === true) {
					curGTFSStopBoundDirection = "Northbound";
				} else if (curGTFSStopName.toLowerCase().includes("eastbound ") === true) {
					curGTFSStopBoundDirection = "Eastbound";
				} else if (curGTFSStopName.toLowerCase().includes("southbound ") === true) {
					curGTFSStopBoundDirection = "Southbound";
				} else if (curGTFSStopName.toLowerCase().includes("westbound ") === true) {
					curGTFSStopBoundDirection = "Westbound";
				}
				
				var curGTFSStopBoundDirectionTextElement = document.createElement("span");
				curGTFSStopBoundDirectionTextElement.setAttribute("style", "font: inherit;");
				
				if (curGTFSStopBoundDirection.length > 0) {
					curGTFSStopBoundDirectionTextElement.textContent = `${this.#prefixText}${curGTFSStopBoundDirection}${this.#suffixText}`;
				} else {
					curGTFSStopBoundDirectionTextElement.textContent = `${this.#prefixText}`;
				}
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(curGTFSStopBoundDirectionTextElement);
				
			} catch (error) {
				console.error(error);
			}
		};
		
		#isInited = false;
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#render();
			
			this.#isInited = true;
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-target-gtfs-stop-number":
					; (() => {
						this.#targetGTFSStopNumber = curValue;
						
						if (this.#isInited === true) {
							this.#render();
						}
					})();
					
					break;
				case "data-prefix-text":
					; (() => {
						this.#prefixText = curValue;
						
						if (this.#isInited === true) {
							this.#render();
						}
					})();
					
					break;
				case "data-suffix-text":
					; (() => {
						this.#suffixText = curValue;
						
						if (this.#isInited === true) {
							this.#render();
						}
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script> <script type="module" class="next-times">
	import { getType, isValidNumber, isValidDate } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { buildDashDelimitedDateStringFromDateString, buildDashDelimitedShortMonthDateStringFromDateString, build12HourTimeStringFromDateTimeString } from "https://tlweblibs.translink.ca/DateTimeStringHelpers-1.1.0.mjs";
	import { ifTruthyValue, mergeSimpleCollections } from "/js/functionalHelpers.mjs";
	import { formatGTFSItemName, parseGTFSRouteLineScheduleTrips, parseGTFSLocationScheduleRouteLines, parseGTFSRouteLineDirection, ifLikeGTFSLocationNumber, ifLikeGTFSLocationName, ifLikeGTFSPlatformName, ifLikeGTFSRouteLineNumber, ifGTFSDirectionNumber, ifLikeGTFSDestinationName, ifPickupGTFSTrip } from "/js/gtfsHelpers.mjs";
	import { GTFS_LINE_NUMBERS } from "/js/gtfsLines.mjs";
	import { GTFS_STATION_NUMBERS, GTFS_PLATFORM_NUMBERS, GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER, GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER } from "/js/gtfsStations.mjs";
	import { buildFetchGTFSLocationAndGTFSRouteLineRealtimeSchedulesAPIURL } from "/js/GTFSRealtimeHelper.mjs";
	import { NextBusSettings } from "/js/NextBusSettings.mjs";
	
	customElements.define("next-times", class NextTimes extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-show-heading"
				, "data-gtfsrouteline"
				, "data-gtfslocation"
				, "data-gtfs-platform-name"
				, "data-direction"
				, "data-destination"
				, "data-api-query-count"
				, "data-api-query-interval-in-milliseconds"
				, "data-times-display-count"
				, "data-ui-refresh-interval-in-milliseconds"
				, "data-all-times"
				, "data-leading-times-label"
				, "data-trailing-times-label"
				, "data-enable-time-updates"
				, "data-enable-api-updates"
				, "data-remove-when-no-departures"
				, "data-remove-container-when-no-departures"
			];
		}
		
		static #PRIMARY_TIME_LABEL_STRING = "Departing:";
		static #SECONDARY_TIME_LABEL_STRING = "";
		
		#showHeading = false;
		#heading;
		
		#leadingTimesLabelString;
		#trailingTimesLabelString;
		
		#refreshUITimerID;
		#refreshTimesTimerID;
		
		#targetGTFSRouteLineNumber;
		#targetGTFSLocationNumber;
		#targetGTFSPlatformName;
		#targetGTFSDirection;
		#targetGTFSDestination;
		
		#allTimes;
		
		#numTimesDisplayCount;
		#apiQueryCount;
		
		#refreshUIIntervalInMilliseconds;
		#apiFetchIntervalInMilliseconds;
		
		#isAPIUpdatingEnabled = true;
		#isTimeUpdatingEnabled = true;
		
		#stopTimesLabelElement;
		#stopTimesElement;
		#noStopTimesElement;
		#noStopTimesRemainingElement;
		
		#isPendingLazyLoad = false;
		#isLoaded = false;
		
		#removeWhenNoDepartures = false;
		#removeContainerWhenNoDepartures = false;
		
		#isDebugging;
		#allStopTimesDebugElement;
		#lastUIUpdateTimeDebugElement;
		#startAPIUpdatesDebugElement;
		#stopAPIUpdatesDebugElement;
		
		static #API_CALLS_REGISTRY = new Map();
		static #IS_STOP_API_CALLS_ON_VISIBILITY_CHANGE_INITED = false;
		
		#renderHeading() {
			//GUARD: do nothing if the header has not been requested
			if (this.#showHeading !== true) {
				return;
			}
			
			var targetGTFSRouteLineNumber = this.#targetGTFSRouteLineNumber;
			
			//GUARD: do nothing if there is no target GTFSRouteLineNumber
			//??? should this typecheck actually be "GTFSRouteLines.ifGTFSRouteLineNumber()"?
			if (ifLikeGTFSRouteLineNumber(targetGTFSRouteLineNumber) === false) {
				return;
			}
			
			var targetGTFSDestinationName = this.#targetGTFSDestination;
			
			//GUARD: do nothing if there is no target GTFSDestination
			if (ifLikeGTFSDestinationName(targetGTFSDestinationName) === false) {
				return;
			}
			
			var targetHeadingContainerElement = this.#heading;
			
			if (!targetHeadingContainerElement) {
				targetHeadingContainerElement = document.createElement("div");
				targetHeadingContainerElement.setAttribute("style", "margin-bottom: 0.5rem; flex-basis: 100%;");
				
				this.#heading = targetHeadingContainerElement;
				this.prepend(targetHeadingContainerElement);
			} else {
				window.deleteAllChildNodes && window.deleteAllChildNodes(targetHeadingContainerElement);
			}
			
			var targetHeadingElement = document.createElement("h3");
				
			var formattedTargetGTFSDestinationName = formatGTFSItemName(targetGTFSDestinationName);
			
			if (GTFS_LINE_NUMBERS.has(targetGTFSRouteLineNumber) === true) {
				targetHeadingElement.textContent = formattedTargetGTFSDestinationName;
			} else {
				targetHeadingElement.textContent = `${targetGTFSRouteLineNumber} ${formattedTargetGTFSDestinationName}`;
			}
			
			var targetSubHeadingElement;
			
			var targetPlatformName = this.#targetGTFSPlatformName;
			
			if (ifLikeGTFSPlatformName(targetPlatformName) === true) {
				targetSubHeadingElement = document.createElement("em");
				targetSubHeadingElement.textContent = targetPlatformName;
			}
			
			targetHeadingContainerElement.append(targetHeadingElement);
			targetSubHeadingElement && targetHeadingContainerElement.append(targetSubHeadingElement);
			
			!targetHeadingContainerElement.parentElement && this.prepend(targetHeadingContainerElement);
		};
		
		async #fetchNextTimes() {
			var targetGTFSRouteLineNumber = this.#targetGTFSRouteLineNumber;
			var targetGTFSLocationNumber = this.#targetGTFSLocationNumber;
			
			//GUARD: do nothing if there is no target GTFSRouteLineNumber
			//??? should this typecheck actually be "GTFSRouteLines.ifGTFSRouteLineNumber()"?
			if (ifLikeGTFSRouteLineNumber(targetGTFSRouteLineNumber) === false) {
				return;
			}
			
			//GUARD: do nothing if there is no target GTFSLocationNumber
			//??? should this typecheck actually be "ifGTFSLocationNumber()"?
			if (ifLikeGTFSLocationNumber(targetGTFSLocationNumber) === false) {
				return;
			}
			
			if (this.#isLoaded === false) {
				if (this.#isPendingLazyLoad === false) { 
					if (window.createLazyLoader) {
						window.createLazyLoader({
							lazyLoadTargets: this
							, onLoadFunction: curTarget => {
								this.#isLoaded = true;
								
								this.#fetchNextTimes && this.#fetchNextTimes.bind(this)();
							}
						});
					} else {
						this.#isLoaded = true;
						
						this.#fetchNextTimes && this.#fetchNextTimes.bind(this)();
					}
				}
				
				this.#isPendingLazyLoad = true;
				
				return;
			};
			
			//??? the entire pipeline from this point on is hardcoded to only make one API call, we do not have a way to have one widget make 2 calls (one for each direction), so we are explicitly only using the first direction from "this.#targetGTFSDirection"
			var gtfsRouteLineNumber = targetGTFSRouteLineNumber;
			var gtfsLocationNumber = GTFS_LINE_NUMBERS.has(gtfsRouteLineNumber) === false ? targetGTFSLocationNumber : (() => {
				var output = targetGTFSLocationNumber;
				
				var targetGTFSDirectionNumber = Array.isArray(this.#targetGTFSDirection) === true ? this.#targetGTFSDirection[0] : this.#targetGTFSDirection;
				
				if (ifGTFSDirectionNumber(targetGTFSDirectionNumber) === false) {
					targetGTFSDirectionNumber = 0; //??? is the 'targetGTFSDirection' only used for platforms/stations?  //??? should we throw an error if direction wasn't set and we had to use the default value?  //??? direction-0 shouldn't be hardcoded?
				}
				
				var allGTFSPlatformNumbersForCurGTFSRouteLine = GTFS_LINE_NUMBER_AND_STATION_NUMBER_TO_PLATFORM_NUMBER.get(gtfsRouteLineNumber);
				var allGTFSPlatformNumbersForCurGTFSRouteLineByGTFSDirectionNumber = allGTFSPlatformNumbersForCurGTFSRouteLine && allGTFSPlatformNumbersForCurGTFSRouteLine.get(targetGTFSLocationNumber);
				var gtfsPlatformNumberForCurDirection = allGTFSPlatformNumbersForCurGTFSRouteLineByGTFSDirectionNumber && allGTFSPlatformNumbersForCurGTFSRouteLineByGTFSDirectionNumber[targetGTFSDirectionNumber];
				
				output = gtfsPlatformNumberForCurDirection || output;
				
				return output;
			})();
			
			var queryCount = this.#apiQueryCount;
			
			try {
				//??? much of the below should be in a MJS file?
				var apiURL = await buildFetchGTFSLocationAndGTFSRouteLineRealtimeSchedulesAPIURL(gtfsLocationNumber, gtfsRouteLineNumber, queryCount);
				//??? need to put in validation for "apiURL === getType.url", but that would require refactoring the logic
				var apiURLAsString = apiURL && apiURL.toString();
				
				var foundAPIFetch = apiURLAsString && NextTimes.#API_CALLS_REGISTRY.get(apiURLAsString);
				
				var apiFetch = foundAPIFetch || this.#isAPIUpdatingEnabled === true && apiURL && fetch(apiURL);  //??? how to handle if there is no API URL?  //??? is it legal to have a real fetch() call here?
				
				if (getType(foundAPIFetch) !== getType.promise && getType(apiURLAsString) === getType.string && apiURLAsString.length > 0 && getType(apiFetch) === getType.promise) {
					NextTimes.#API_CALLS_REGISTRY.set(apiURLAsString, apiFetch);
					
					try {
						var isNextTimesWidgetOnscreenObserver = new IntersectionObserver(entries => {
							//GUARD: do nothing if there is no refresh timer running
							if (isValidNumber(this.#refreshTimesTimerID) === false) {
								return;
							}
							
							entries.forEach(entry => {
								var target = entry.target;
								
								this.#refreshTimesTimerID && window.clearInterval(this.#refreshTimesTimerID);
								
								if (entry.intersectionRatio > 0) {
									this.#refreshTimesTimerID = window.setInterval(this.#fetchNextTimes.bind(this), this.#apiFetchIntervalInMilliseconds);
								}
							});
						});
						
						isNextTimesWidgetOnscreenObserver.observe(this);
					} catch (error) {
						console.error(error);
						
						this.#stopTimesLabelElement.setAttribute("hidden", "");
						this.#stopTimesElement.setAttribute("hidden", "");
						this.#noStopTimesElement.removeAttribute("hidden");
						this.#noStopTimesRemainingElement.setAttribute("hidden", "");
					}
				}
				
				try {
					var response = apiFetch && await apiFetch;
					var result = response && response.ok === true && response.json && await response.clone().json();
					
					//GUARD: do nothing if there is no result
					//??? need "getType.response"....or just use "functionalHelpers.parseAsJSON()" for the above?
					if (!result) {
						return;
					}
					
					this.#parseNextTimes.bind(this)(result);
				} catch (error) {
					console.error(error);
				} finally {
					NextTimes.#API_CALLS_REGISTRY.delete(apiURLAsString);
					
					this.#initLoopingForFetchNextTimes.bind(this)();
				}
			} catch (error) {
				console.error(error);
			}
		};
		
		#parseNextTimes(targetGTFSLocationSchedule) {
			var memoizedDates = new Map();  //??? why is this not in a class static or an MJS? (eg "DateTimeStringHelpers.getDateObject()" if that ever becomes an export)
			
			const MAX_EXPIRY_TIME_FOR_GTFS_TRIP_STOPTIMES_IN_MINUTES = 2;  //??? make this a class static?
			const MILLISECONDS_IN_ONE_DAY = 86400000;
			
			//remove stoptimes more than 2 minutes in the past
			var cutoffForGTFSTripStoptimes = new Date();
			cutoffForGTFSTripStoptimes.setMinutes(cutoffForGTFSTripStoptimes.getMinutes() - MAX_EXPIRY_TIME_FOR_GTFS_TRIP_STOPTIMES_IN_MINUTES);
			
			var todayDate = new Date();
			todayDate.setHours(0, 0, 0);
			
			var allGTFSTripStoptimes = [];
			var allGTFSTripStoptimeEstimationIndexes = [];
			var allGTFSTripStoptimeCancellationIndexes = [];
			
			var targetGTFSDirectionNumbers = this.#targetGTFSDirection;
			var targetGTFSDestinationName = this.#targetGTFSDestination;
			
			targetGTFSLocationSchedule
			.flat()
			.map(parseGTFSLocationScheduleRouteLines)
			.flat()
			.filter(ifTruthyValue)
			.filter(curGTFSLocationScheduleRouteLine => {
				if (Array.isArray(targetGTFSDirectionNumbers) === true && targetGTFSDirectionNumbers.length > 0) {
					var curGTFSLocationScheduleRouteLineDirection = parseGTFSRouteLineDirection(curGTFSLocationScheduleRouteLine);
					
					var isCurDirectionATargetDirection = targetGTFSDirectionNumbers.includes(curGTFSLocationScheduleRouteLineDirection); //??? "isCurDirectionATargetDirection" is a terrible name
					
					return isCurDirectionATargetDirection;
				} else {
					return true;
				}
			})
			.filter(curGTFSLocationScheduleRouteLine => {
				//??? what is going on here?  are we filtering out trips that don't go to the target destination?  if there is no target destination, then include everything?
				if (ifLikeGTFSDestinationName(targetGTFSDestinationName) === false) {
					return true;
				}
				
				var formattedGTFSDestinationName = formatGTFSItemName(curGTFSLocationScheduleRouteLine.hs);
				formattedGTFSDestinationName = formattedGTFSDestinationName && formattedGTFSDestinationName.toLowerCase();
				
				if (targetGTFSDestinationName.toLowerCase() === formattedGTFSDestinationName) {
					return true;
				} else {
					return false;
				}
			})
			.flatMap(parseGTFSRouteLineScheduleTrips)
			.filter(ifTruthyValue)
			.filter(ifPickupGTFSTrip)
			.filter(curPickupGTFSTrip => {
				var curPickupGTFSTripStoptimeAsUnixTimeStamp = curPickupGTFSTrip.ut;
				curPickupGTFSTripStoptimeAsUnixTimeStamp = curPickupGTFSTripStoptimeAsUnixTimeStamp && parseInt(curPickupGTFSTripStoptimeAsUnixTimeStamp, 10);
				
				//GUARD: do nothing if there is no unix-time stoptime for current trip
				if (isValidNumber(curPickupGTFSTripStoptimeAsUnixTimeStamp) === false) {
					return false;
				}
				
				curPickupGTFSTripStoptimeAsUnixTimeStamp = curPickupGTFSTripStoptimeAsUnixTimeStamp * 1000;
				
				var curPickupGTFSTripStoptimeAsDate = memoizedDates.get(curPickupGTFSTripStoptimeAsUnixTimeStamp) || memoizedDates.set(curPickupGTFSTripStoptimeAsUnixTimeStamp, new Date(curPickupGTFSTripStoptimeAsUnixTimeStamp)) && memoizedDates.get(curPickupGTFSTripStoptimeAsUnixTimeStamp); //??? surely there is a more elegant syntax/helper method?
				
				//GUARD: do nothing if there is there is no valid date for the current stoptime
				if (isValidDate(curPickupGTFSTripStoptimeAsDate) === false) {
					return false;
				}
				
				if (curPickupGTFSTripStoptimeAsDate < cutoffForGTFSTripStoptimes) {
					return false;
				}
				
				return true;
			})
			.sort((lhs, rhs) => {
				var lhsDateAsUnixTimestamp = lhs.ut * 1000;
				var rhsDateAsUnixTimestamp = rhs.ut * 1000;
				
				if (!lhsDateAsUnixTimestamp && !rhsDateAsUnixTimestamp) {
					return 0;
				} else if (!lhsDateAsUnixTimestamp) {
					return -1;
				} else if (!rhsDateAsUnixTimestamp) {
					return 1;
				}
				
				var lhsDate = memoizedDates.get(lhsDateAsUnixTimestamp) || memoizedDates.set(lhsDateAsUnixTimestamp, new Date(lhsDateAsUnixTimestamp)) && memoizedDates.get(lhsDateAsUnixTimestamp); //??? surely there is a more elegant syntax/helper method?
				var rhsDate = memoizedDates.get(rhsDateAsUnixTimestamp) || memoizedDates.set(rhsDateAsUnixTimestamp, new Date(rhsDateAsUnixTimestamp)) && memoizedDates.get(rhsDateAsUnixTimestamp); //??? surely there is a more elegant syntax/helper method?
				
				if (isValidDate(lhsDate) === false || isValidDate(rhsDate) === false) {
					return 0;
				}
				
				if (lhsDate === rhsDate) {
					return 0;
				} else if (lhsDate < rhsDate) {
					return -1;
				} else if (lhsDate > rhsDate) {
					return 1;
				}
				
				return 0; //NOTE: this should never run, but returning a 'default value' for safety
			})
			.map((curPickupGTFSTrip, idx) => {
				var curPickupGTFSTripAsUnixTimestamp = curPickupGTFSTrip.ut * 1000;
				var curGTFSTripStoptimeAsDateTime = memoizedDates.get(curPickupGTFSTripAsUnixTimestamp) || memoizedDates.set(curPickupGTFSTripAsUnixTimestamp, new Date(curPickupGTFSTripAsUnixTimestamp)) && memoizedDates.get(curPickupGTFSTripAsUnixTimestamp); //??? surely there is a more elegant syntax/helper method?
				
				//GUARD: do nothing if there is there is no valid date for the current stoptime
				if (isValidDate(curGTFSTripStoptimeAsDateTime) === false) {
					return;
				}
				
				if (curPickupGTFSTrip.tc === false && curPickupGTFSTrip.cs === false) {
					if (curPickupGTFSTrip.rt === true) {
						allGTFSTripStoptimeEstimationIndexes.push(idx);
					}
				} else {
					allGTFSTripStoptimeCancellationIndexes.push(idx);
				}
				
				//??? shouldn't calculating "numDaysFromToday" be in a helper MJS?
				var curGTFSTripStoptimeAsDate = new Date(curGTFSTripStoptimeAsDateTime); //??? can we not memoize the Date?
				curGTFSTripStoptimeAsDate.setHours(0, 0, 0);
				
				var numDaysFromToday = Math.ceil((curGTFSTripStoptimeAsDate.getTime() - todayDate.getTime()) / MILLISECONDS_IN_ONE_DAY);
				
				var curGTFSTripStoptimeHours = (numDaysFromToday * 24) + curGTFSTripStoptimeAsDateTime.getHours();
				var curGTFSTripStoptimeMinutes = curGTFSTripStoptimeAsDateTime.getMinutes();
				
				var formattedCurGTFSTripStoptime = `${curGTFSTripStoptimeHours.toString().padStart(2, "0")}:${curGTFSTripStoptimeMinutes.toString().padStart(2, "0")}`;  //??? this should be in "DateTimeStringHelpers.mjs"
				
				return formattedCurGTFSTripStoptime;
			})
			.filter(ifTruthyValue)
			.reduce(mergeSimpleCollections, allGTFSTripStoptimes);
			
			if (allGTFSTripStoptimes.length === 0) {
				this.#refreshTimesTimerID && window.clearInterval(this.#refreshTimesTimerID);
				
				this.#stopTimesLabelElement.setAttribute("hidden", "");
				this.#stopTimesElement.setAttribute("hidden", "");
				this.#noStopTimesElement.setAttribute("hidden", "");
				this.#noStopTimesRemainingElement.removeAttribute("hidden");
				
				this.#removeWhenNoDepartures === true && this.remove();
				
				if (this.#removeContainerWhenNoDepartures === true) {
					var parentRowElement = this.closest("li");
					parentRowElement && parentRowElement.remove();
				}
				
				return;
			}
			
			//??? this whole section below needs to be heavily documented
			this.#stopTimesLabelElement.textContent = this.#leadingTimesLabelString;
			
			allGTFSTripStoptimeEstimationIndexes.length > 0 && this.setAttribute("data-real-time-index", allGTFSTripStoptimeEstimationIndexes);
			allGTFSTripStoptimes.length === 0 && allGTFSTripStoptimeEstimationIndexes.length === 0 && this.#noStopTimesElement.removeAttribute("hidden");
			allGTFSTripStoptimeEstimationIndexes === 0 && this.removeAttribute("data-real-time-index");
			allGTFSTripStoptimeCancellationIndexes.length > 0 && this.setAttribute("data-cancelled-times-index", allGTFSTripStoptimeCancellationIndexes);
			allGTFSTripStoptimeCancellationIndexes === 0 && this.removeAttribute("data-cancelled-times-index");
			this.setAttribute("data-all-times", allGTFSTripStoptimes); //NOTE: 'data-all-times' must be set last because setting the value triggers the display to be rendered
		};
		
		#displayNextTimes() {
			window.runAfterDOMContentLoaded(document, async () => {
				const MILLISECONDS_IN_TWENTY_FOUR_HOURS = 86400000;
				const MILLISECONDS_IN_TWO_HOURS = 7200000;
				const MILLISECONDS_IN_TWO_MINUTES = 120000;
				
				const IMMEDIATE_TIME_CUTOFF_IN_MILLISECONDS = MILLISECONDS_IN_TWO_MINUTES; //??? temporary hack - needs to be a setting
				
				var curTimeSinceEpoch = (new Date()).getTime();
				
				var indexOfLastTimeWithinTwoHours = -1;  //NOTE: if there is a single time within 2 hours, then we don't show any times after 2 hours
				var isLeadingTimeImmediate = false;  //NOTE: this is a performance optimization so we don't have to rebuild date objects
				
				var allCountdownFormattedValidTimes = [];
				
				var allValidTimes = this.#allTimes
				.filter((nextTime, idx) => {
					var nextTimeParts = nextTime.split(":");
					var nextTimeHours = parseInt(nextTimeParts[0], 10);
					var nextTimeMinutes = parseInt(nextTimeParts[1], 10);
					
					var formattedTime = new Date();
					formattedTime.setHours(nextTimeHours);
					formattedTime.setMinutes(nextTimeMinutes);
					
					var formattedTimeSinceEpoch = formattedTime.getTime();  //??? is this the right name? don't think epoch is a datatype
					
					if (formattedTimeSinceEpoch >= curTimeSinceEpoch) {
						var differenceBetweenCurTimeAndTargetTimeInMilliseconds = formattedTimeSinceEpoch - curTimeSinceEpoch;
						
						//GUARD: do not accept times that are 24 hours or later
						if (differenceBetweenCurTimeAndTargetTimeInMilliseconds > MILLISECONDS_IN_TWENTY_FOUR_HOURS) {  //??? removed hardcoded number; make a config
							return false;
						}
						
						if (differenceBetweenCurTimeAndTargetTimeInMilliseconds <= MILLISECONDS_IN_TWO_HOURS) {  //??? removed hardcoded number; make a config
							indexOfLastTimeWithinTwoHours = idx;
						}
						
						if (differenceBetweenCurTimeAndTargetTimeInMilliseconds <= IMMEDIATE_TIME_CUTOFF_IN_MILLISECONDS) { 
							isLeadingTimeImmediate = true;
						}
						
						if (indexOfLastTimeWithinTwoHours > -1) {
							//if we found at least one time within 2 hours, then we must ignore the current time if it is after 2 hours
							if (indexOfLastTimeWithinTwoHours === idx) {
								allCountdownFormattedValidTimes.push(Math.floor(differenceBetweenCurTimeAndTargetTimeInMilliseconds / 60000));  //NOTE: 60,000 ms in 1 minute
								
								return true;
							} else {
								return false;
							}
						} else {
							//if no times are within 2 hours, then we will accept the time
							allCountdownFormattedValidTimes.push(Math.floor(differenceBetweenCurTimeAndTargetTimeInMilliseconds / 60000));  //NOTE: 60,000 ms in 1 minute
							
							return true;
						}
					} else {
						return false;
					}
				})
				.slice(0, this.#numTimesDisplayCount);
				
				var allFormattedValidTimes = allValidTimes.map((nextTime, idx) => {
					try {
						var timeDisplaySetting = window.nextTimesTimeFormat || NextBusSettings.getSetting("timeDisplay");
						var isShowingCountdown = timeDisplaySetting === "clockTime" ? false : true;
						
						//GUARD: do nothing if all times are after 2 hours and this is not the first time after 2 hours
						//NOTE: this is a highly aggressive and specific shortcircuit - if business rules change, this should be revisited because it is not an always-useful short circuit
						if (isShowingCountdown === true && indexOfLastTimeWithinTwoHours === -1 && idx !== 0) {
							return;
						}
						
						var output;
						
						var formattedAMPMTimeString;
						
						var nextTimeParts = nextTime.split(":");
						var nextTimeHours = parseInt(nextTimeParts[0], 10) % 24 || 12; //NOTE: when "% 24" returns 0, we replace it with "12" to represent midnight as 12:00 am (eg 12:01 am not 0:01 am)
						var nextTimeMinutes = parseInt(nextTimeParts[1], 10);
						
						//NOTE: "Math.floor(nextTimeParts[0] / 12) % 2 !== 0" is needed to handle 24:00 or later times (eg 25:00); odd numbers after dividing by 12 mean that we are in "PM"
						if (nextTimeHours >= 12 && Math.floor(nextTimeParts[0] / 12) % 2 !== 0) {
							formattedAMPMTimeString = `${(nextTimeHours - 12) || 12}:${nextTimeMinutes.toString().padStart(2, "0")} pm`;
						} else {
							formattedAMPMTimeString = `${nextTimeHours}:${nextTimeMinutes.toString().padStart(2, "0")} am`;
						}
						
						if (isLeadingTimeImmediate === true && idx === 0) {
							output = "Now"; //??? remove hardcoding?  //??? duplicate string; should put into variable
						} else {
							if (isShowingCountdown === true) {
								var countdownInMins = allCountdownFormattedValidTimes[idx];  //??? need to show this array and how it was made as part of the debug info
								
								//NOTE: even if the user prefers countdowns, show a datetime string instead of a countdown if all times are after 2 hours
								if (indexOfLastTimeWithinTwoHours === -1) {
									if (idx === 0) {
										var scheduledDateTime = new Date();
										scheduledDateTime.setMinutes(scheduledDateTime.getMinutes() + countdownInMins);
										
										var scheduledDateTimeAsString = `${buildDashDelimitedShortMonthDateStringFromDateString(scheduledDateTime.toString())} ${build12HourTimeStringFromDateTimeString(scheduledDateTime.toString())}`;
										scheduledDateTimeAsString = scheduledDateTimeAsString && scheduledDateTimeAsString.trim();
										
										output = `Scheduled at ${scheduledDateTimeAsString}`;
									}
								} else {
									if (countdownInMins === 0) {
										output = "Now";  //??? duplicate string; should put into variable
									} else if (countdownInMins > 0 && countdownInMins < 60) {
										output = `${countdownInMins} min`;
									} else if (countdownInMins === 60){
										output = `1 hr`;
									} else if (countdownInMins > 60 && countdownInMins < 120){
										output = `1 hr ${countdownInMins % 60} min`;
									} else {
										output = "";  //"Now"; //??? this is a hack to prevent "23 hrs 58 min" from showing
									}
								}
							} else {
								output = formattedAMPMTimeString;
							}
						}
					} catch (error) {
						console.error(error);
					}
					
					return output;
				});
				
				if (allFormattedValidTimes && allFormattedValidTimes.length > 0) {
					try {
						const realTimeIconURLString = "/-/media/translink/icons/transit-schedules/realtime_icon.svg";
						var realTimeIconURL = realTimeIconURLString && new URL(realTimeIconURLString, document.location.origin);
						
						var realTimeElement = document.createElement("img");
						realTimeElement.setAttribute("alt", "Real-time symbol");
						realTimeIconURL && realTimeElement.setAttribute("src", realTimeIconURL);
						realTimeElement.setAttribute("width", 10);
						realTimeElement.setAttribute("height", 10);
						realTimeElement.setAttribute("style", "position: relative; top: -0.5rem; width: 0.5556rem; height: 0.5556rem;");
						
						var allRealTimesAttributeValue = this.hasAttribute("data-real-time-index") && this.getAttribute("data-real-time-index");
						
						var allRealTimes = allRealTimesAttributeValue && allRealTimesAttributeValue
						.split(",")
						.map(realTimeIndexString => {
							return parseInt(realTimeIndexString, 10);
						});
						
						var allCancelledTimesAttributeValue = this.hasAttribute("data-cancelled-times-index") && this.getAttribute("data-cancelled-times-index");
						
						var allCancelledTimes = allCancelledTimesAttributeValue && allCancelledTimesAttributeValue
						.split(",")
						.map(realTimeIndexString => {
							return parseInt(realTimeIndexString, 10);
						});
						
						var prevStopTimeElement;
						var allTimeElements = this.#stopTimesElement && this.#stopTimesElement.querySelectorAll("time");
						
						allTimeElements.forEach((curStopTimeElement, idx) => {
							var curStopTimeElementParent = curStopTimeElement && curStopTimeElement.closest("li");
							
							//GUARD: do nothing if there is no parent element
							//??? is it correct to just do nothing?  should we actually hide the <time> element or something similar
							if (!curStopTimeElementParent) {
								return;
							}
							
							var targetValidTime = allValidTimes[idx];
							var targetFormattedValidTime = allFormattedValidTimes[idx];
							
							if (targetValidTime && targetFormattedValidTime) {
								var formattedValidDateTimeString = targetValidTime;
								
								var targetValidTimeParts = targetValidTime.split(":");
								var targetValidTimeHours = parseInt(targetValidTimeParts[0], 10);
								var targetValidTimeMinutes = parseInt(targetValidTimeParts[1], 10);
								
								//convert the time string into a datetime string if it references a time from tomorrow
								if (targetValidTimeHours >= 24) {
									formattedValidDateTimeString = `${buildDashDelimitedDateStringFromDateString((new Date()).toString())} ${(targetValidTimeHours % 24 || 12).toString().padStart(2, "0")}:${targetValidTimeMinutes}`;  //NOTE: convert any 0s from "% 24" into "12" so that 24:00 (midnight) accurately prints as 12:00
								}
								
								curStopTimeElementParent && curStopTimeElementParent.removeAttribute("hidden");
								formattedValidDateTimeString && curStopTimeElement.setAttribute("datetime", formattedValidDateTimeString);
								curStopTimeElement.textContent = targetFormattedValidTime;
								
								if (allRealTimes && allRealTimes.includes(idx) === true) {
									curStopTimeElement.append(realTimeElement.cloneNode(true));
								}
								
								if (allCancelledTimes && allCancelledTimes.includes(idx) === true) {
									var cancelledTimeWrapperElement = document.createElement("s");
									cancelledTimeWrapperElement.setAttribute("style", "color: red;");
									cancelledTimeWrapperElement.textContent = curStopTimeElement.textContent;
									
									window.deleteAllChildNodes && window.deleteAllChildNodes(curStopTimeElement);
									curStopTimeElement.textContent = "";
									
									curStopTimeElement.append(cancelledTimeWrapperElement);
								}
								
								//NOTE: if this current time is renderable, then we need to add a comma to the previous time
								prevStopTimeElement && prevStopTimeElement.append(document.createTextNode(","));
								
								prevStopTimeElement = curStopTimeElement;
							} else {
								curStopTimeElementParent && curStopTimeElementParent.setAttribute("hidden", "");
								curStopTimeElement.removeAttribute("datetime");
								curStopTimeElement.textContent = "";
							}
						});
						
						this.#stopTimesLabelElement && this.#stopTimesLabelElement.removeAttribute("hidden");
						this.#stopTimesElement && this.#stopTimesElement.removeAttribute("hidden");
						this.#noStopTimesElement && this.#noStopTimesElement.setAttribute("hidden", "");
						this.#noStopTimesRemainingElement && this.#noStopTimesRemainingElement.setAttribute("hidden", "");
					} catch (error) {
						console.error(error);
					}
				} else {
					this.#stopTimesLabelElement && this.#stopTimesLabelElement.setAttribute("hidden", "");
					this.#stopTimesElement && this.#stopTimesElement.setAttribute("hidden", "");
					this.#noStopTimesElement && this.#noStopTimesElement.setAttribute("hidden", "");
					this.#noStopTimesRemainingElement && this.#noStopTimesRemainingElement.removeAttribute("hidden");
				}
				
				if (this.#lastUIUpdateTimeDebugElement) {
					this.#lastUIUpdateTimeDebugElement.textContent = `Last updated at ${(new Date()).getHours()}:${(new Date()).getMinutes().toString().padStart(2, "0")}`;
				}
			});
		};
		
		#initLoopingForFetchNextTimes() {
			//NOTE: we can only set the 'No service at this stop' message after we have tried at least one API fetch
			if (this.#noStopTimesElement) {
				var gtfsLocationNumber = this.#targetGTFSLocationNumber;
				gtfsLocationNumber = GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER.get(gtfsLocationNumber) || gtfsLocationNumber;
				
				//??? this 'search both global station numbers and platform numbers' is a hack...?
				if (GTFS_STATION_NUMBERS.has(gtfsLocationNumber) === true) {
					this.#noStopTimesElement.textContent = "There is currently no service scheduled at this station.";  //??? remove hardcoding?
				} else {
					this.#noStopTimesElement.textContent = "There is currently no service scheduled at this stop.";  //??? remove hardcoding?
				}
			}
			
			//??? need to setup error handling, so it doesn't keep pinging too many times when the API is offline.  We do need to accept SOME amount of error handling though in case of poor (but still existent) connectivity.
			if (this.#refreshTimesTimerID === undefined) {
				this.#refreshTimesTimerID = window.setInterval(this.#fetchNextTimes.bind(this), this.#apiFetchIntervalInMilliseconds);
			}
			
			NextTimes.#IS_STOP_API_CALLS_ON_VISIBILITY_CHANGE_INITED === false && document.addEventListener("visibilitychange", e => {
				if (this.#refreshTimesTimerID) {
					window.clearInterval(this.#refreshTimesTimerID);
					
					if (document.hidden === false) {
						this.#fetchNextTimes.bind(this)();
						
						this.#refreshTimesTimerID = window.setInterval(this.#fetchNextTimes.bind(this), this.#apiFetchIntervalInMilliseconds);
					}
				}
				
				NextTimes.#IS_STOP_API_CALLS_ON_VISIBILITY_CHANGE_INITED = true;
			});
		};
		
		constructor() {
			super();
			
			this.#numTimesDisplayCount = 6;
			this.#apiQueryCount = 6;
			
			this.#refreshUIIntervalInMilliseconds = 5000;
			this.#apiFetchIntervalInMilliseconds = 30000;
			
			this.#isDebugging = window.IS_DBG && window.IS_DBG();
		}
		
		connectedCallback() {
			window.runAfterDOMContentLoaded(document, () => {
				//??? this whole starter block is arguably not very great
				this.textContent = ""; //clear out any placeholder text
				this.classList.add("flexContainer");
				this.classList.add("flexWrapper");
				this.classList.add("useFontColor");
				this.style.gap = "0.5rem";
				
				this.#renderHeading();
				
				if (this.#leadingTimesLabelString === undefined) {
					this.#leadingTimesLabelString = NextTimes.#PRIMARY_TIME_LABEL_STRING.trim();
				}
				
				if (this.#trailingTimesLabelString === undefined) {
					this.#trailingTimesLabelString = NextTimes.#SECONDARY_TIME_LABEL_STRING.trim();
				}
				
				this.#stopTimesLabelElement = document.createElement("span");
				this.#stopTimesLabelElement.setAttribute("style", "display: contents;");
				
				this.#stopTimesElement = document.createElement("ul");
				this.#stopTimesElement.setAttribute("class", "menu flexContainer flexWrapper");
				this.#stopTimesElement.setAttribute("style", "display: contents;");
				this.#trailingTimesLabelString && this.#stopTimesElement.append(document.createTextNode(this.#trailingTimesLabelString));
				
				try {
					var timeDisplaySetting = window.nextTimesTimeFormat || NextBusSettings.getSetting("timeDisplay");
					var isShowingCountdown = timeDisplaySetting === "clockTime" ? false : true;
					
					var numTimesToDisplay = parseInt(this.#numTimesDisplayCount, 10);
					
					for (var i = 0; i < numTimesToDisplay; i++) {
						var timeElementWrapper = document.createElement("li");
						timeElementWrapper.setAttribute("hidden", "");
						
						var timeElement = document.createElement("time");
						
						if (i === 0) {
							var firstTimeElementWrapper = document.createElement("strong");  //??? horrible name
							firstTimeElementWrapper.setAttribute("style", "position: relative; top: -1px;");
							
							timeElement.setAttribute("style", "font: inherit;");  //??? since we are setting this at page-load/widget-init time, layout will likely be wrong if the user changes preferences, then comes back to the page without refreshing
							
							firstTimeElementWrapper.append(timeElement)
							timeElementWrapper.append(firstTimeElementWrapper);
							this.#stopTimesElement.append(timeElementWrapper);
						} else {
							isShowingCountdown === false && timeElement.setAttribute("style", "display: inline-block; margin-left: 0.1rem; white-space: nowrap;");  //??? since we are setting this at page-load/widget-init time, layout will likely be wrong if the user changes preferences, then comes back to the page without refreshing
							
							timeElementWrapper.append(timeElement);
							this.#stopTimesElement.append(timeElementWrapper);
						}
					}
					
					this.#noStopTimesElement = document.createElement("p");  //??? this needs to be a config
					this.#noStopTimesElement.setAttribute("style", "margin: 0px;");
					this.#noStopTimesElement.textContent = "Loading...";  //??? make this a <loading-message>
					
					this.#noStopTimesRemainingElement = document.createElement("p");
					this.#noStopTimesRemainingElement.setAttribute("style", "margin: 0px;");
					this.#noStopTimesRemainingElement.setAttribute("hidden", "");
					
					var gtfsLocationNumber = GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER.get(this.#targetGTFSLocationNumber) || this.#targetGTFSLocationNumber;
					
					//??? this 'search both global station numbers and platform numbers' is a hack...?
					if (GTFS_STATION_NUMBERS.has(gtfsLocationNumber) === true || GTFS_PLATFORM_NUMBERS.has(gtfsLocationNumber) === true) {
						this.#noStopTimesRemainingElement.textContent = "There are no more trips scheduled at this station today.";  //??? need to unhardcode
					} else {
						this.#noStopTimesRemainingElement.textContent = "There are no more trips scheduled at this stop today.";  //??? need to unhardcode
					}
					
					this.append(this.#stopTimesLabelElement);
					this.append(this.#stopTimesElement);
					this.append(this.#noStopTimesElement);
					this.append(this.#noStopTimesRemainingElement);
					
					if (this.#isDebugging === true) {
						this.#allStopTimesDebugElement = document.createElement("small");
						this.#allStopTimesDebugElement.setAttribute("class", "maxWidth");
						this.#allStopTimesDebugElement.setAttribute("style", "word-break: break-word;");  //NOTE: because this debug information is a string of comma-separated times without any spaces, we need to break-word so that the text can wrap on commas
						
						var apiUpdatesWrapperElement = document.createElement("div");
						apiUpdatesWrapperElement.setAttribute("class", "flexContainer flexWrapper verticallyCenteredContent");
						apiUpdatesWrapperElement.setAttribute("style", "margin-top: 0px; gap: 0.5rem;");
						
						this.#lastUIUpdateTimeDebugElement = document.createElement("small");
						this.#lastUIUpdateTimeDebugElement.setAttribute("style", "margin-top: 0.5rem;");
						
						this.#startAPIUpdatesDebugElement = document.createElement("button");
						this.#startAPIUpdatesDebugElement.setAttribute("type", "button");
						this.#startAPIUpdatesDebugElement.setAttribute("style", "margin-top: 0px;");
						this.#startAPIUpdatesDebugElement.textContent = "Start";
						
						this.#stopAPIUpdatesDebugElement = document.createElement("button");
						this.#stopAPIUpdatesDebugElement.setAttribute("type", "button");
						this.#stopAPIUpdatesDebugElement.setAttribute("style", "margin-top: 0px;");
						this.#stopAPIUpdatesDebugElement.textContent = "Stop";
						
						apiUpdatesWrapperElement.append(this.#lastUIUpdateTimeDebugElement);
						apiUpdatesWrapperElement.append(this.#startAPIUpdatesDebugElement);
						apiUpdatesWrapperElement.append(this.#stopAPIUpdatesDebugElement);
						
						this.append(this.#allStopTimesDebugElement);
						this.append(apiUpdatesWrapperElement);
						
						this.#startAPIUpdatesDebugElement.addEventListener("click", e => {
							this.setAttribute("data-enable-api-updates", true);
							
							e.preventDefault();
							return false;
						});
						
						this.#stopAPIUpdatesDebugElement.addEventListener("click", e => {
							this.setAttribute("data-enable-api-updates", false);
							
							e.preventDefault();
							return false;
						});
					}
				} catch (error) {
					console.error(error);
				}
			});
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-show-heading":
					; (() => {
						this.#showHeading = curValue === "true" ? true : false;
						
						this.#renderHeading && this.#renderHeading();
					})();
					
					break;
				case "data-gtfsrouteline":
					; (() => {
						this.#targetGTFSRouteLineNumber = curValue;
						
						this.#renderHeading && this.#renderHeading();
						
						this.#fetchNextTimes && this.#fetchNextTimes.bind(this)();
					})();
					
					break;
				case "data-gtfslocation":
					; (() => {
						this.#targetGTFSLocationNumber = curValue;
						
						this.#fetchNextTimes && this.#fetchNextTimes.bind(this)();
					})();
					
					break;
				case "data-gtfs-platform-name":
					; (() => {
						this.#targetGTFSPlatformName = curValue;
						
						this.#fetchNextTimes && this.#fetchNextTimes.bind(this)();
					})();
					
					break;
				case "data-direction":
					; (() => {
						this.#targetGTFSDirection = curValue && curValue
						.split(",")
						.map(curGTFSDirection => {
							var foundGTFSDirectionNumber = parseInt(curGTFSDirection, 10);  //??? handle failing parses?
							
							return foundGTFSDirectionNumber;
						});
						
						this.#fetchNextTimes && this.#fetchNextTimes.bind(this)();
					})();
					
					break;
				case "data-destination":
					; (() => {
						this.#targetGTFSDestination = curValue;
						
						this.#renderHeading && this.#renderHeading();
						
						this.#fetchNextTimes && this.#fetchNextTimes.bind(this)();
					})();
					
					break;
				case "data-api-query-count":
					; (() => {
						this.#apiQueryCount = parseInt(curValue, 10);  //??? handle failing parses?
					})();
					
					break;
				case "data-api-query-interval-in-milliseconds":
					; (() => {
						this.#apiFetchIntervalInMilliseconds = curValue;
					})();
					
					break;  //??? why does this not passthrough to 'data-all-time'??
				case "data-ui-refresh-interval-in-milliseconds":
					; (() => {
						if (attributeName === "data-ui-refresh-interval-in-milliseconds") {
							this.#refreshUIIntervalInMilliseconds = curValue;
						}
					})();
					
					//break;  //NOTE: intentionally allow passthrough to "data-all-time" 
				case "data-times-display-count":
					; (() => {
						if (attributeName === "data-times-display-count") {
							this.#numTimesDisplayCount = parseInt(curValue, 10);  //??? handle failing parses?
						}
					})();
					
					//break;  //NOTE: intentionally allow passthrough to "data-all-time"
				case "data-leading-times-label":
					; (() => {
						if (attributeName === "data-leading-times-label") {
							this.#leadingTimesLabelString = curValue.trim();
						}
					})();
					
					//break;  //NOTE: intentionally allow passthrough to "data-all-time"
				case "data-trailing-times-label":
					; (() => {
						if (attributeName === "data-trailing-times-label") {
							this.#trailingTimesLabelString = curValue.trim();
						}
					})();
					
					//break;  //NOTE: intentionally allow passthrough to "data-all-time"
				case "data-enable-api-updates":
					; (() => {
						if (attributeName === "data-enable-api-updates") {
							this.#isAPIUpdatingEnabled = curValue === "false" ? false : true;
						}
					})();
					
					//break;  //NOTE: intentionally allow passthrough to "data-all-time"
				case "data-enable-time-updates":
					; (() => {
						if (attributeName === "data-enable-time-updates") {
							this.#isTimeUpdatingEnabled = curValue === "false" ? false : true;
						}
					})();
					
					//break;  //NOTE: intentionally allow passthrough to "data-all-time"
				case "data-all-times":
					; (() => {
						if (attributeName === "data-all-times") {
							//??? definitely need to validate if these time values are formatted properly
							this.#allTimes = curValue
							.split(",")
							.map(curTimeValue => {
								return curTimeValue.trim();
							});
						}
						
						//GUARD: do nothing if there are no times
						if (Array.isArray(this.#allTimes) === false || this.#allTimes.length === 0) {
							this.#stopTimesLabelElement && this.#stopTimesLabelElement.setAttribute("hidden", "");
							this.#stopTimesElement && this.#stopTimesElement.setAttribute("hidden", "");
							this.#noStopTimesElement && this.#noStopTimesElement.removeAttribute("hidden");
							this.#noStopTimesRemainingElement && this.#noStopTimesRemainingElement.setAttribute("hidden", "");
							
							return;
						}
						
						if (this.#allStopTimesDebugElement) {
							this.#allStopTimesDebugElement.textContent = curValue;  //??? is this correct or should it be equal to this.#allTimes
						}
						
						//??? put in a guard clause for these functions that do the real work?
						this.#displayNextTimes && this.#displayNextTimes.bind(this)();
						
						if (this.#isTimeUpdatingEnabled === true) {
							this.#refreshUITimerID = window.setInterval(this.#displayNextTimes.bind(this), this.#refreshUIIntervalInMilliseconds);
						} else if (this.#isTimeUpdatingEnabled === false) {
							if (isValidNumber(this.#refreshUITimerID) === true) {
								window.clearInterval(this.#refreshUITimerID);
							}
						}
					})();
					
					break;
				case "data-remove-when-no-departures":
					; (() => {
						this.#removeWhenNoDepartures = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-remove-container-when-no-departures":
					; (() => {
						this.#removeContainerWhenNoDepartures = curValue === "true" ? true : false;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="next-times-list">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { ifTruthyValue, mergeSimpleCollections } from "/js/functionalHelpers.mjs";
	import { formatGTFSItemName, parseGTFSLocationScheduleRouteLines, ifLikeGTFSLocationNumber, ifLikeGTFSLocationName, ifGTFSDirectionNumber, ifGTFSRouteLineScheduleWithPickupGTFSTrips } from "/js/gtfsHelpers.mjs";
	import { GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME, GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE } from "/js/gtfsLines.mjs";
	import { fetchGTFSStationSchedulesForDate } from "/js/gtfsStations.mjs";
	import { fetchGTFSStopSchedulesForDate } from "/js/gtfsStops.mjs";
	
	customElements.define("next-times-list", class NextTimesList extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-gtfs-location-number"
				, "data-show-gtfs-destinations"
				, "data-leading-times-label" 
				, "data-trailing-times-label"
				, "data-api-query-count"
				, "data-times-display-count"
				, "data-includes-headway-list"
				, "data-no-data-message"
				, "data-show-heading-as-link"
			];
		}
		
		#gtfsLocationNumber;
		#showGTFSDestinations;
		#leadingTimesLabelString;
		#trailingTimesLabelString;
		#apiQueryCount;
		#numTimesDisplayCount;
		#includesHeadwayList;
		#showHeadingAsLink;
		#noDataMessage = "There are no scheduled trips.";
		
		#nextTimesContainerContentObserver;
		
		async #render() {
			var targetGTFSLocationNumber = this.#gtfsLocationNumber;
			
			//GUARD: do nothing if there is no target GTFS location
			if (ifLikeGTFSLocationNumber(targetGTFSLocationNumber) === false) {
				return;
			}
			
			var noScheduledTripsTextElement = document.createElement("p");
			noScheduledTripsTextElement.textContent = this.#noDataMessage;
			
			try {
				var tomorrowDate = new Date();
				tomorrowDate && tomorrowDate.setDate(tomorrowDate.getDate() + 1);
				
				//??? why do I have to make this API call to get the list of GTFSRouteLines for this GTFSLocation; shouldn't the server know this already?  there should be an endpoint or JSON file that has this all mapped
				//??? the API should also handle all of the parsing/handling I am doing below?
				var allGTFSLocationSchedulesForTodayAndTomorrow = await Promise.all([
					fetchGTFSStationSchedulesForDate(targetGTFSLocationNumber, new Date())
					, fetchGTFSStationSchedulesForDate(targetGTFSLocationNumber, tomorrowDate)
					, fetchGTFSStopSchedulesForDate(targetGTFSLocationNumber, new Date())
					, fetchGTFSStopSchedulesForDate(targetGTFSLocationNumber, tomorrowDate)
				]);
				
				//GUARD: do nothing if there are no GTFSLocationSchedules
				if (Array.isArray(allGTFSLocationSchedulesForTodayAndTomorrow) === false) {
					return;
				}
				
				allGTFSLocationSchedulesForTodayAndTomorrow = allGTFSLocationSchedulesForTodayAndTomorrow.flat();
				
				//GUARD: do nothing if there is no first result
				if (allGTFSLocationSchedulesForTodayAndTomorrow.length === 0) {
					window.deleteAllChildNodes && window.deleteAllChildNodes(this);
					
					this.removeAttribute("hidden");
					
					noScheduledTripsTextElement && this.append(noScheduledTripsTextElement);
					
					return;
				}
				
				var allGTFSPlatformNamesByIndex = [];
				
				allGTFSLocationSchedulesForTodayAndTomorrow
				.flatMap(curGTFSLocationSchedule => {
					var curGTFSLocationName = curGTFSLocationSchedule.sn;
					
					//GUARD: do nothing if the GTFS Platform Name is not a string
					if (ifLikeGTFSLocationName(curGTFSLocationName) === false) {
						return [];
					}
					
					var gtfsPlatformName = null;
					
					//only output a platform name if the word "platform" exists
					var indexOfGTFSPlatformName = curGTFSLocationName.toLowerCase().indexOf("platform");
					
					if (indexOfGTFSPlatformName > -1) {
						var gtfsPlatformNumber = curGTFSLocationSchedule.sc;
						
						switch (gtfsPlatformNumber) {
							case "60800":  // Sapperton Station
							case "60802":  // Braid Station
								; (() => {
									gtfsPlatformName = "Platforms 1 & 2";
								})();
								
								break;
							case "60801":  // Sapperton Station
							case "60803":  // Braid Station
								; (() => {
									gtfsPlatformName = "Platform 1";
								})();
								
								break;
							default:
								; (() => {
									gtfsPlatformName = curGTFSLocationName
									.substring(indexOfGTFSPlatformName)
									.trim();
								})();
								
								break;
						}
					}
					
					var allGTFSRouteLineSchedules = parseGTFSLocationScheduleRouteLines(curGTFSLocationSchedule);
					
					if (Array.isArray(allGTFSRouteLineSchedules) === true) {
						return allGTFSRouteLineSchedules
						.map(curGTFSRouteLineSchedule => {
							return ifGTFSRouteLineScheduleWithPickupGTFSTrips(curGTFSRouteLineSchedule) === true ? gtfsPlatformName : undefined;
						})
						.filter(ifTruthyValue);
					} else {
						return [];
					}
				})
				.reduce(mergeSimpleCollections, allGTFSPlatformNamesByIndex);
				
				//??? these don't feel like very good names...
				var allGTFSRouteLineNumbersAtCurGTFSLocation = [];
				var allGTFSDirectionNamesAtCurGTFSLocation = [];
				var allGTFSDirectionNumbersAtCurGTFSLocation = [];
				var allGTFSDestinationsAtCurGTFSLocation = [];
				
				allGTFSLocationSchedulesForTodayAndTomorrow
				.flatMap(parseGTFSLocationScheduleRouteLines)
				.filter(ifGTFSRouteLineScheduleWithPickupGTFSTrips)
				.forEach(curGTFSLocationScheduleRouteLine => {
					//??? do we actually need to "formatGTFSItemName()"?
					var curGTFSRouteLineNumberAtCurGTFSLocation = curGTFSLocationScheduleRouteLine.rs;
					var curDirectionNameAtCurGTFSLocation = formatGTFSItemName(curGTFSLocationScheduleRouteLine.dn) || "";
					var curDirectionNumberAtCurGTFSLocation = ifGTFSDirectionNumber(curGTFSLocationScheduleRouteLine.di) ? curGTFSLocationScheduleRouteLine.di : "";  //??? why is the valid type a Number and the default type a String?
					var curGTFSDestination = formatGTFSItemName(curGTFSLocationScheduleRouteLine.hs);
					
					//??? do some validation?
					
					allGTFSRouteLineNumbersAtCurGTFSLocation.push(curGTFSRouteLineNumberAtCurGTFSLocation);
					allGTFSDirectionNamesAtCurGTFSLocation.push(curDirectionNameAtCurGTFSLocation);
					allGTFSDirectionNumbersAtCurGTFSLocation.push(curDirectionNumberAtCurGTFSLocation);
					this.#showGTFSDestinations === true && allGTFSDestinationsAtCurGTFSLocation.push(curGTFSDestination);
				});
				
				//stop processing and delete the element if there is no data
				if (allGTFSRouteLineNumbersAtCurGTFSLocation.length === 0) {
					window.deleteAllChildNodes && window.deleteAllChildNodes(this);
					
					this.removeAttribute("hidden");
					
					noScheduledTripsTextElement && this.append(noScheduledTripsTextElement);
					
					return;
				}
				
				var nextTimesContainerElement = document.createElement("ul");
				nextTimesContainerElement.setAttribute("class", "listing");
				
				var renderedGTFSRouteLinesPerDirection = new Set();
				
				allGTFSRouteLineNumbersAtCurGTFSLocation.forEach((curGTFSRouteLineNumberAtCurGTFSLocation, idx) => {
					var curGTFSDirectionName = allGTFSDirectionNamesAtCurGTFSLocation[idx];
					var curGTFSDirectionNumber = allGTFSDirectionNumbersAtCurGTFSLocation[idx];
					var curGTFSPlatformName = allGTFSPlatformNamesByIndex[idx];
					
					var curGTFSDestination;
					var curGTFSRouteLineAndDirectionName; //??? rename to reference gtfsdestination in some way or make it more obvious it's just a key?
					
					if (this.#showGTFSDestinations === true) {
						curGTFSDestination = allGTFSDestinationsAtCurGTFSLocation[idx];
						
						curGTFSRouteLineAndDirectionName = `${curGTFSRouteLineNumberAtCurGTFSLocation}_${curGTFSDirectionNumber}_${curGTFSDestination}`;
					} else {
						curGTFSRouteLineAndDirectionName = `${curGTFSRouteLineNumberAtCurGTFSLocation}_${curGTFSDirectionNumber}`;
					}
					
					//GUARD: do nothing if the current GTFS RouteLine and GTFS Direction combination has already been rendered
					if (renderedGTFSRouteLinesPerDirection.has(curGTFSRouteLineAndDirectionName) === true) {
						return;
					}
					
					renderedGTFSRouteLinesPerDirection.add(curGTFSRouteLineAndDirectionName);
					
					var curGTFSRouteLineNumberRowElement = document.createElement("li");  //??? is there a better element name?
					curGTFSRouteLineNumberRowElement.setAttribute("style", "width: 100%;");
					
					var curGTFSRouteLineNumberTextColumnElement;  //??? this is a terrible name
					
					if (this.#showHeadingAsLink === true) {
						var isGTFSStop = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE.has(curGTFSRouteLineNumberAtCurGTFSLocation) === true ? false : true;
						
						var curGTFSRouteLineMapPageURL;
						
						try {
							var curGTFSRouteLineMapPageURLString = "";
							
							if (isGTFSStop === true) {
								curGTFSRouteLineMapPageURLString = `/schedules-and-maps/route/${curGTFSRouteLineNumberAtCurGTFSLocation}/direction/${curGTFSDirectionNumber}/map`;
							} else {
								var gtfsLineNameAsURLSafeString = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE.get(curGTFSRouteLineNumberAtCurGTFSLocation);
								
								curGTFSRouteLineMapPageURLString = `/schedules-and-maps/line/${gtfsLineNameAsURLSafeString}/direction/${curGTFSDirectionNumber}/map`;
							}
							
							curGTFSRouteLineMapPageURL = curGTFSRouteLineMapPageURLString && new URL(curGTFSRouteLineMapPageURLString, window.parentRootURLString || document.location.origin);
						} catch (error) {
							console.error(error);
						}
						
						if (curGTFSRouteLineMapPageURL) {
							curGTFSRouteLineNumberTextColumnElement = document.createElement("a");
							curGTFSRouteLineNumberTextColumnElement.setAttribute("href", curGTFSRouteLineMapPageURL);
							curGTFSRouteLineNumberTextColumnElement.setAttribute("target", "_top");
						} else {
							curGTFSRouteLineNumberTextColumnElement = document.createElement("span");
						}
						
						var curGTFSRouteLineNumberTextElement = document.createElement("strong");
						curGTFSRouteLineNumberTextElement.textContent = isGTFSStop === true ? `${curGTFSRouteLineNumberAtCurGTFSLocation} ${curGTFSDirectionName}` : `${GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME.get(curGTFSRouteLineNumberAtCurGTFSLocation)} ${curGTFSDirectionName}`;
						
						curGTFSRouteLineNumberTextColumnElement.append(curGTFSRouteLineNumberTextElement);
					}
					
					var curGTFSRouteLineNumberNextTimeElement = document.createElement("next-times");
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-direction", curGTFSDirectionNumber);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-gtfsrouteline", curGTFSRouteLineNumberAtCurGTFSLocation);
					this.#showGTFSDestinations === true && curGTFSRouteLineNumberNextTimeElement.setAttribute("data-destination", curGTFSDestination);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-gtfslocation", targetGTFSLocationNumber);
					curGTFSPlatformName && curGTFSRouteLineNumberNextTimeElement.setAttribute("data-gtfs-platform-name", curGTFSPlatformName);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-leading-times-label", this.#leadingTimesLabelString);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-trailing-times-label", this.#trailingTimesLabelString);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-api-query-count", this.#apiQueryCount);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-times-display-count", this.#numTimesDisplayCount);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-show-heading", true);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-remove-when-no-departures", false);
					curGTFSRouteLineNumberNextTimeElement.setAttribute("data-remove-container-when-no-departures", false);
					
					var curGTFSRouteLineNumberNextTimeLoadingElement = document.createElement("p");
					curGTFSRouteLineNumberNextTimeLoadingElement.textContent = "Loading...";  //??? replace with <loading-message>?
					
					curGTFSRouteLineNumberNextTimeElement.append(curGTFSRouteLineNumberNextTimeLoadingElement);
					
					var headwayListElement;
					
					if (this.#includesHeadwayList === true) {
						headwayListElement = document.createElement("headway-list");
						headwayListElement.setAttribute("data-gtfsrouteline", curGTFSRouteLineNumberAtCurGTFSLocation);  
						headwayListElement.setAttribute("data-gtfsdirection", curGTFSDirectionNumber);
						this.#showGTFSDestinations === true && headwayListElement.setAttribute("data-gtfsdestination", curGTFSDestination);
						headwayListElement.setAttribute("data-gtfslocation", targetGTFSLocationNumber);
						headwayListElement.setAttribute("data-only-show-remaining-stop-times", true);
						headwayListElement.setAttribute("class", "contentItem");
						headwayListElement.setAttribute("style", "display: block;");
					}
					
					this.#showHeadingAsLink === true && curGTFSRouteLineNumberRowElement.append(curGTFSRouteLineNumberTextColumnElement);
					curGTFSRouteLineNumberRowElement.append(curGTFSRouteLineNumberNextTimeElement);
					this.#includesHeadwayList === true && curGTFSRouteLineNumberRowElement.append(headwayListElement);
					
					nextTimesContainerElement.append(curGTFSRouteLineNumberRowElement);
				});
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(nextTimesContainerElement);
				
				if ("requestAnimationFrame" in window) {
					window.requestAnimationFrame(() => {
						window.requestAnimationFrame(() => {
							this.removeAttribute("hidden");
						});
					});
				}
				
				//hide the entire element if there are no next-times to display
				this.#nextTimesContainerContentObserver = new MutationObserver(allMutations => {
					var allDataContentElements = nextTimesContainerElement.querySelectorAll("li > *");
					
					if (allDataContentElements.length === 0) {
						window.deleteAllChildNodes && window.deleteAllChildNodes(this);
						
						noScheduledTripsTextElement && this.append(noScheduledTripsTextElement);
						
						this.#nextTimesContainerContentObserver.disconnect();
					}
				});
				
				this.#nextTimesContainerContentObserver.observe(nextTimesContainerElement, { childList: true, subtree: true });
			} catch (error) {
				console.error(error);
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				noScheduledTripsTextElement && this.append(noScheduledTripsTextElement); //??? this error message is probably a lie....there may or may not be trips, but the true cause of this error message is an unknown error....
			}
		};
		
		constructor() {
			super();
		}
		
		disconnectedCallback() {
			this.#nextTimesContainerContentObserver && this.#nextTimesContainerContentObserver.disconnect();
		}
		
		connectedCallback() {
			this.#render();
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-gtfs-location-number":
					; (() => {
						this.#gtfsLocationNumber = curValue;  //??? sanitize?
						
						this.#render();
					})();
					
					break;
				case "data-show-gtfs-destinations":
					; (() => {
						this.#showGTFSDestinations = curValue === "true" ? true : false;
						
						this.#render();
					})();
					
					break;
				case "data-leading-times-label":
					; (() => {
						this.#leadingTimesLabelString = curValue;  //??? sanitize?
						
						this.#render();
					})();
					
					break;
				case "data-trailing-times-label":
					; (() => {
						this.#trailingTimesLabelString = curValue;  //??? sanitize?
						
						this.#render();
					})();
					
					break;
				case "data-api-query-count":
					; (() => {
						this.#apiQueryCount = parseInt(curValue, 10);  //??? sanitize?
						
						this.#render();
					})();
					
					break;
				case "data-times-display-count":
					; (() => {
						this.#numTimesDisplayCount = curValue;  //??? sanitize?
						
						this.#render();
					})();
					
					break;
				case "data-includes-headway-list":
					; (() => {
						this.#includesHeadwayList = curValue === "true" ? true : false;
						
						this.#render();
					})();
					
					break;
				case "data-show-heading-as-link":
					; (() => {
						this.#showHeadingAsLink = curValue === "true" ? true : false;
						
						this.#render();
					})();
					
					break;
				case "data-no-data-message":
					; (() => {
						this.#noDataMessage = curValue;  //??? sanitize?
						
						this.#render();
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="nextTrip">
	customElements.define("next-trip", class NextTrip extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-routeline"
				, "data-gtfs-direction"
				, "data-prefix-text"
				, "data-suffix-text"
			];
		}
		
		#targetGTFSRouteLineNumber;
		#targetGTFSDirectionNumber;
		#prefixText;
		#suffixText;
		
		#isInited = false;
		
		//??? I think we need to make this widget rerender whenever its data-gtfs-direction attribute changes; we also have to make that attribute in the first place....
		async #render() {
			this.#isInited = true;
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			this.textContent = "";
			
			try {
				const BUILD_ENVIRONMENT_SPECIFIC_URL_MODULE_URL_STRING = "https://tlweblibs.translink.ca/buildEnvironmentSpecificURL-1.0.1.mjs";
				
				var targetGTFSRouteLineNumber = this.#targetGTFSRouteLineNumber || window.GTFS.routeNumber || window.GTFS.lineNumber;  //??? this should be able to pull from the window.GTFS variables
				var targetGTFSDirection = this.#targetGTFSDirectionNumber || parseInt(window.GTFS.direction, 10);
				
				//GUARD: do nothing if there is no GTFSRouteLineNumber
				if (!targetGTFSRouteLineNumber) {
					return;
				}
				
				//GUARD: do nothing if there is no valid GTFSDirection
				if (targetGTFSDirection !== 0 && targetGTFSDirection !== 1) {
					return;
				}
				
				var buildEnvironmentSpecificURLModuleURL = BUILD_ENVIRONMENT_SPECIFIC_URL_MODULE_URL_STRING && new URL(BUILD_ENVIRONMENT_SPECIFIC_URL_MODULE_URL_STRING);
				
				var { buildEnvironmentSpecificURL } = buildEnvironmentSpecificURLModuleURL && await import(buildEnvironmentSpecificURLModuleURL);
				
				var apiURLString = buildEnvironmentSpecificURL && await buildEnvironmentSpecificURL(`https://getaway.translink.ca/api/gtfs/route/${targetGTFSRouteLineNumber}/direction/${targetGTFSDirection}/nexttrip`);
				var apiURL = apiURLString && new URL(apiURLString);
				
				var response = apiURL && await fetch(apiURL);
				var result = response && response.ok === true && response.json && await response.json();
				
				//??? add a guard clause for if result exists?
				if (!result) {
					return;
				}
				
				var nextTripUnixDateTimeString = result && result.nextTripDateTimeInUnix;
				var nextTripDateTime = nextTripUnixDateTimeString && new Date(nextTripUnixDateTimeString * 1000);
				
				//GUARD: do nothing if the next trip datetime is not valid
				if (!nextTripDateTime || window.isValidDate(nextTripDateTime) === false) {
					return;
				}
				
				var nextTripDateTimeString = window.buildDateTimeString(nextTripDateTime);  //??? convert to use datetime helpers
				
				var nextTripDateTimeElement = document.createElement("time");
				nextTripDateTimeElement.setAttribute("datetime", nextTripDateTimeString); //??? this looks something like "yyyy-mm-dd h:mm apm", but shouldn't it be 24hr time instead of apm?
				nextTripDateTimeElement.textContent = nextTripDateTimeString;
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				this.textContent = "";
				
				this.#prefixText && this.append(document.createTextNode(this.#prefixText));
				this.append(nextTripDateTimeElement);
				this.#suffixText && this.append(document.createTextNode(this.#suffixText));
			} catch (error) {
				console.error(error);
			}
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			window.runAfterDOMContentLoaded(document, () => {
				this.#render && this.#render();
			});
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-routeline":
					; (() => {
						this.#targetGTFSRouteLineNumber = curValue;
						
						this.#isInited === true && this.#render && this.#render();
					})();
					
					break;
				case "data-gtfs-direction":
					; (() => {
						this.#targetGTFSDirectionNumber = parseInt(curValue, 10);  //??? add error handling?
						
						this.#isInited === true && this.#render && this.#render();
					})();
					
					break;
				case "data-prefix-text":
					; (() => {
						this.#prefixText = curValue;
						
						this.#isInited === true && this.#render && this.#render();
					})();
					
					break;
				case "data-suffix-text":
					; (() => {
						this.#suffixText = curValue;
						
						this.#isInited === true && this.#render && this.#render();
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="pam-map">
	import { getType, isValidNumber } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { getHTMLIDString } from "https://tlweblibs.translink.ca/URLHelpers-1.0.0.mjs";
	import { ifTruthyValue } from "/js/functionalHelpers.mjs";
	import { ifLatLng, ifLatLngWithinGVTA, convertLatAndLngToLatLng, convertLatLngStringToLatLng } from "/js/geographyHelpers.mjs";
	import { convertGTFSRouteLineNumberAndGTFSDestinationNameToGTFSDestinationFullName, formatGTFSItemName, parseGTFSStationNumber, parseGTFSStationLatLng, parseGTFSStopLatLng, parseGTFSLocationScheduleRouteLines, ifLikeGTFSLocationNumber, ifLikeGTFSStationNumber, ifLikeGTFSStopNumber, ifLikeGTFSRouteLineNumber, ifLikeGTFSRouteLineName, ifLikeGTFSItemNumber, ifGTFSDirectionNumber, ifLikeGTFSDirectionName, ifLikeGTFSDestinationName} from "/js/gtfsHelpers.mjs";
	import { GTFS_CANADA_LINE_NUMBER, GTFS_MILLENNIUM_LINE_NUMBER, GTFS_EXPO_LINE_NUMBER, GTFS_WEST_COAST_EXPRESS_LINE_NUMBER, GTFS_SEABUS_LINE_NUMBER, GTFS_LINE_NUMBERS, GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME, GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE } from "/js/gtfsLines.mjs";
	import { GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER, GTFS_CANADA_LINE_STATIONS_FROM_USAGE, GTFS_MILLENNIUM_LINE_STATIONS_FROM_USAGE, GTFS_EXPO_LINE_STATIONS_FROM_USAGE, GTFS_WEST_COAST_EXPRESS_STATIONS_FROM_USAGE, GTFS_SEABUS_STATIONS_FROM_USAGE, fetchGTFSStationsByNumber, fetchGTFSStationSchedulesForDate } from "/js/gtfsStations.mjs";
	import { fetchGTFSStopsByNumber, fetchGTFSStopSchedulesForDate } from "/js/gtfsStops.mjs";
	import { fetchGTFSPathsForGTFSRouteLineNumberAndGTFSDirectionNumber } from "/js/gtfsRouteLines.mjs";
	import { NextBusSettings } from "/js/NextBusSettings.mjs";
	
	customElements.define("pam-map", class PamMap extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-key"
				, "data-google-maps-version"
				, "data-map-id"
				, "data-title"
				, "data-gtfsroutelines"
				, "data-gtfsdestination"
				, "data-gtfslocations"
				, "data-show-all-nearby-gtfslocations"
				, "data-show-vehicles-for-direction"
				, "data-show-vehicles-for-gtfslocations"
				, "data-only-show-vehicle-numbers"
				, "data-center-to"
				, "data-heading-in-degrees"
				, "data-focus-on"
				, "data-view-all-of"
				, "data-zoom-level"
				, "data-hide-path-direction"
				, "data-customized-gtfsroutelines"
				, "data-customized-gtfsroutelines-colors"
				, "data-custom-markers"
				, "data-custom-paths"
				, "data-reindeer-vehicles"
				, "data-show-reindeer-gtfsroutelines"
			];
		}
		
		#isConnected = false;
		
		#googleMapIFrame;
		#messageChannelPortWithGoogleMapIFrame;
		
		#isPauseVehiclePositionUpdatesOnVisibilityChangedInited = false;
		
		#key;
		#googleMapsVersion = "3.59.1";
		#mapID;
		#title;
		#gtfsRouteLines;
		#gtfsDestination;
		#gtfsLocations;
		#showAllNearbyGTFSLocations;
		#showVehiclesForDirection;
		#showVehiclesForGTFSLocations;
		#onlyShowVehicleNumbers;
		#centerTo;
		#focusOn;
		#viewAllTarget;
		#zoomLevel;
		#isHidingPathDirection;
		
		#customizedGTFSRouteLines;
		#customizedGTFSRouteLineColors;
		
		#customMarkerIDs;
		#customPathIDs;
		
		#reindeerVehicleNumbers;
		#showReindeerGTFSRouteLines;
		
		#initCenterTo;
		#initZoomLevel;
		
		#isDebugging;
		
		//??? should be in GTFS MJS file
		//??? the first part of this could be replaced by "GTFSHelpers.ifPickupStop" and the 2nd part should be refactored to something more specifically about "create GTFS Schedule"
		#getGTFSScheduleRouteLine = curGTFSScheduleRouteLine => {
			//GUARD: do nothing if there is no target GTFSScheduleRouteLine
			if (getType(curGTFSScheduleRouteLine) !== getType.object) {
				return;
			}
			
			var curGTFSScheduleRouteLineStopTimes = curGTFSScheduleRouteLine.t;
			
			//GUARD: do nothing if there are no stoptimes
			if (Array.isArray(curGTFSScheduleRouteLineStopTimes) === false) {
				return;
			}
			
			if (curGTFSScheduleRouteLineStopTimes.length === 0) {
				return;
			}
			
			var hasAtLeastOnePickupStoptime = curGTFSScheduleRouteLineStopTimes.some(curGTFSRouteLineScheduleStoptime => {
				var isDropoffOnly = curGTFSRouteLineScheduleStoptime.do === true;
				var isNodeStop = curGTFSRouteLineScheduleStoptime.no === true;
				
				var isCurStoptimePickingUp = isNodeStop === false && isDropoffOnly === false;
				
				return isCurStoptimePickingUp;
			});
			
			//GUARD: do nothing if all stoptimes dropoff only
			if (hasAtLeastOnePickupStoptime === false) {
				return;
			}
			
			var curGTFSRouteLineNumber = curGTFSScheduleRouteLine.rs;
			
			//GUARD: do nothing if the GTFS RouteLine Number is not a string
			if (ifLikeGTFSRouteLineNumber(curGTFSRouteLineNumber) === false) {
				return;
			}
			
			var curGTFSRouteLineName = curGTFSScheduleRouteLine.rl;
			
			//GUARD: do nothing if the GTFS RouteLine Name is not a string
			if (ifLikeGTFSRouteLineName(curGTFSRouteLineName) === false) {
				return;
			}
			
			var curGTFSRouteLineNameURLSafe = getHTMLIDString(curGTFSRouteLineName);  //??? this should be done inside GTFS MJS files, not on the client
			
			//GUARD: do nothing if the GTFS RouteLine URLSafe Name is not a string
			//??? should we enhance this check by passing "curGTFSRouteLineNameURLSafe" into a sanitizer
			if (ifLikeGTFSRouteLineName(curGTFSRouteLineNameURLSafe) === false) {
				return;
			}
			
			var curGTFSDirectionNumber = curGTFSScheduleRouteLine.di;
			
			//GUARD: do nothing if the GTFS Direction Number is not a number
			if (ifGTFSDirectionNumber(curGTFSDirectionNumber) === false) {
				return;
			}
			
			var curGTFSRouteLineDirectionName = curGTFSScheduleRouteLine.dn;
			
			//GUARD: do nothing if the GTFS Direction Name is not a string
			if (ifLikeGTFSDirectionName(curGTFSRouteLineDirectionName) === false) {
				return;
			}
			
			var curGTFSRouteLineDestinationName = formatGTFSItemName(curGTFSScheduleRouteLine.hs);  //??? this should be done inside GTFS MJS files, not on the client
			
			//GUARD: do nothing if the GTFS Destination Name is not a string
			if (ifLikeGTFSDestinationName(curGTFSRouteLineDestinationName) === false) {
				return;
			}
			
			var curGTFSRouteLineNumberAndDestinationName = convertGTFSRouteLineNumberAndGTFSDestinationNameToGTFSDestinationFullName(curGTFSRouteLineNumber, curGTFSRouteLineDestinationName);  //??? this should be done inside GTFS MJS files, not on the client
			
			//GUARD: do nothing if the GTFS RouteLine Number and Destination Name is not a string
			//NOTE: We cannot check for a GTFSRouteLineFullName because GTFSLines will not include a GTFSLineNumber in this case
			if (ifLikeGTFSRouteLineName(curGTFSRouteLineNumberAndDestinationName) === false) {
				return;
			}
			
			var output = {
				gtfsRouteLineNumber: curGTFSRouteLineNumber
				, gtfsRouteLineName: curGTFSRouteLineName
				, gtfsRouteLineNameURLSafe: curGTFSRouteLineNameURLSafe
				, gtfsDirectionNumber: curGTFSDirectionNumber
				, gtfsDirectionName: curGTFSRouteLineDirectionName
				, gtfsDestinationName: curGTFSRouteLineDestinationName
				, gtfsFormattedDestinationName: curGTFSRouteLineNumberAndDestinationName
				, gtfsScheduleStoptimes: curGTFSScheduleRouteLineStopTimes
			}
			
			return output;
		};
		
		#handleMessagesFromGoogleMapIFrame(e) {
			var command;
			
			try {
				var data = e.data || e;
				
				command = JSON.parse(data);
			} catch (error) {
				console.error(error);
				
				return;
			}
			
			var filterKey = command.message || command.commandType;
			
			switch (filterKey) {
				case "map is inited":  //??? this should really be a const synced between this file and the map itself
					; (() => {
						this.setAttribute("data-is-loaded", true);
					})();
					
					break;
				case "url":
					; (() => {
						try {
							var targetURLString = command.href;
							var targetURL = targetURLString && new URL(targetURLString);
							
							//GUARD: do nothing if there is no URL
							if (getType(targetURL) !== getType.url) {
								return;
							}
							
							var linkTarget = command.target;
							
							if (linkTarget === "_blank") {
								window.open(targetURL, linkTarget);
							} else {
								window.location.href = targetURL;
							}
						} catch (error) {
							console.error(error);
						}
					})();
					
					break;
				case "userSetZoomLevel":
					; (() => {
						this.setAttribute("data-user-zoomed-to", command.zoom);
					})();
					
					break;
				case "userPannedTo":
					; (() => {
						this.setAttribute("data-user-panned-to", `${command.lat},${command.lng}`);  //??? use "convertLatAndLngToLatLng()"?
					})();
					
					break;
				case "selectPlace":
				case "panToPlace":
					; (() => {
						var pamMapMarkerName = command.name;
						
						//GUARD: do nothing if there is target stop ID
						if (getType(pamMapMarkerName) !== getType.string) {
							return;
						}
						
						var clickedPamMapMarkerEvent = new CustomEvent("click-pam-map-marker", {
							detail: pamMapMarkerName
							, bubbles: true
							, cancelable: true
						});
						
						this.dispatchEvent(clickedPamMapMarkerEvent);
					})();
					
					break;
				default:
					; (() => {
						
					})();
					
					break;
			}
		};
		
		constructor() {
			super();
			
			this.#isDebugging = window.IS_DBG && window.IS_DBG();
		}
		
		async connectedCallback() {
			var customPathColorPalette = (() => {
				var output = [];
				
				var allCustomizedGTFSRouteLineNumbers = this.#customizedGTFSRouteLines && this.#customizedGTFSRouteLines.split(",");
				var allCustomizedPathColors = this.#customizedGTFSRouteLineColors && this.#customizedGTFSRouteLineColors.split(","); //??? validate that these are all hex codes before counting them
				
				var numCustomizedGTFSRouteLines = allCustomizedGTFSRouteLineNumbers && allCustomizedGTFSRouteLineNumbers.length;
				var numCustomizedPathColors = allCustomizedPathColors && allCustomizedPathColors.length; 
				
				//GUARD: do nothing if there are no customized routes or colors
				if (Array.isArray(numCustomizedGTFSRouteLines) === false || Array.isArray(numCustomizedPathColors) === false) {
					return;
				}
				
				var numCustomizations = Math.min(numCustomizedGTFSRouteLines, numCustomizedPathColors);
				
				for (var i = 0; i < numCustomizations; i++) {
					output.push(allCustomizedGTFSRouteLineNumbers[i]);
					output.push(allCustomizedPathColors[i]);
				}
				
				return output;
			})();
			
			try {
				var timeFormat = NextBusSettings && NextBusSettings.getSetting("timeDisplay") || "countDown";  //??? remove hardcoding?  maybe put a const like 'NextBusSettings.getDefaultValueForSetting("timeDisplay")'
				timeFormat = timeFormat && timeFormat.toLowerCase();
				
				const googleMapIFrameURLString = "https://maps.translink.ca/map";
				var googleMapIFrameURL = googleMapIFrameURLString && new URL(googleMapIFrameURLString);
				
				//GUARD: do nothing if we don't have a Google Maps URL
				if (getType(googleMapIFrameURL) !== getType.url) {
					//??? should we remove or display some sort of error message?
					//??? should log to NOWAY
					
					return;
				}
				
				this.#key && googleMapIFrameURL.searchParams.append("key", this.#key);
				googleMapIFrameURL.searchParams.append("v", this.#googleMapsVersion);
				this.#mapID && googleMapIFrameURL.searchParams.append("mapID", this.#mapID);
				this.#gtfsRouteLines && googleMapIFrameURL.searchParams.append("routes", this.#gtfsRouteLines);
				this.#gtfsLocations && googleMapIFrameURL.searchParams.append("places", this.#gtfsLocations);
				this.#showVehiclesForDirection && googleMapIFrameURL.searchParams.append("showvehiclesfordirection", this.#showVehiclesForDirection);
				this.#centerTo && googleMapIFrameURL.searchParams.append("centerto", this.#centerTo);
				this.#showAllNearbyGTFSLocations && googleMapIFrameURL.searchParams.append("showallnearbygtfslocations", this.#showAllNearbyGTFSLocations);
				timeFormat && googleMapIFrameURL.searchParams.append("timeformat", timeFormat);
				this.#zoomLevel && googleMapIFrameURL.searchParams.append("zoom", this.#zoomLevel);
				this.#isHidingPathDirection && googleMapIFrameURL.searchParams.append("hidepathdirection", this.#isHidingPathDirection);
				customPathColorPalette && customPathColorPalette.length > 0 && googleMapIFrameURL.searchParams.append("palette", customPathColorPalette.join(","));
				this.#onlyShowVehicleNumbers && googleMapIFrameURL.searchParams.append("onlyvehiclenumbers", this.#onlyShowVehicleNumbers);
				
				if (getType(this.#reindeerVehicleNumbers) !== getType.undefined) {
					if (this.#showReindeerGTFSRouteLines === false) {
						googleMapIFrameURL.searchParams.append("reindeerswithoutgtfsroutelines", this.#reindeerVehicleNumbers);
					} else {
						googleMapIFrameURL.searchParams.append("reindeers", this.#reindeerVehicleNumbers);
					}
				}
				
				this.#isDebugging === true && googleMapIFrameURL.searchParams.append("isdbg", true);
				
				this.#googleMapIFrame = document.createElement("iframe");
				this.#googleMapIFrame.setAttribute("title", this.#title);
				this.#googleMapIFrame.setAttribute("src", googleMapIFrameURL);
				this.#googleMapIFrame.setAttribute("width", 560);
				this.#googleMapIFrame.setAttribute("height", 315);
				this.#googleMapIFrame.setAttribute("credentialless", "");
				this.#googleMapIFrame.setAttribute("sandbox", "allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation");
				this.#googleMapIFrame.setAttribute("allow", "fullscreen");  //NOTE: needed to prevent console errors in iOS
				this.#googleMapIFrame.setAttribute("style", "display: block; width: 100%; height: 100%;");  //??? can't this just be replaced with a class?  something like maxSize?  Are we keeping it for safety reasons?
				
				this.#googleMapIFrame.addEventListener("load", () => {
					var googleMapIFrameMessagingChannel = new MessageChannel();
					
					this.#messageChannelPortWithGoogleMapIFrame = googleMapIFrameMessagingChannel.port1;
					
					this.#messageChannelPortWithGoogleMapIFrame.addEventListener("message", this.#handleMessagesFromGoogleMapIFrame.bind(this));
					
					this.#messageChannelPortWithGoogleMapIFrame.start();
					
					var messageChannelPortForGoogleMapIFrame = googleMapIFrameMessagingChannel.port2;
					
					this.#googleMapIFrame.contentWindow.postMessage(window.location.origin, "*", [messageChannelPortForGoogleMapIFrame]);
				});
				
				this.append(this.#googleMapIFrame);
				
				this.#isConnected = true;
				
				document.addEventListener("click-pam-map-marker", e => {
					var target = e.target;
					
					//GUARD: do nothing if the target was a pam map marker
					//??? should "PAM-MAP-MARKER" be a constant/static?
					if (target.tagName === "PAM-MAP-MARKER") {
						return;
					}
					
					var targetCustomMarkerID = e.detail;
					
					var targetCustomMarker = targetCustomMarkerID && document.querySelector(`pam-map-marker[data-custom-marker-id="${targetCustomMarkerID}"]`);
					
					if (targetCustomMarker) {
						var clickedPamMapMarkerEvent = new CustomEvent("click-pam-map-marker", {
							detail: targetCustomMarkerID
							, bubbles: true
							, cancelable: true
						});
						
						targetCustomMarker.dispatchEvent(clickedPamMapMarkerEvent);
					}
				});
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-key":
					; (() => {
						this.#key = curValue;
					})();
					
					break;
				case "data-google-maps-version":
					; (() => {
						this.#googleMapsVersion = curValue;
					})();
					
					break;
				case "data-map-id":
					; (() => {
						this.#mapID = curValue;
					})();
					
					break;
				case "data-title":
					; (() => {
						this.#title = curValue;
					})();
					
					break;
				case "data-gtfsroutelines":
					; (() => {
						//GUARD: do nothing if the value hasn't changed
						if (this.#gtfsRouteLines === curValue) {
							return;
						}
						
						this.#gtfsRouteLines = curValue;
						
						switch (curValue) {
							case "000":
								; (() => {
									this.setAttribute("data-gtfsroutelines", curValue.replace("000", "992,991,980"));
								})();
								
								return;
								
								break;
							default:
								; (() => {
									//???  intentionally blank for now  //??? maybe show "unexpected input" error?
								})();
								
								break;
						}
						
						this.#isConnected === true && window.runAfterPamMapLoad(this, () => {
							var REMOVE_ALL_LINES_PAM_MAP_COMMAND = `{
								"commandType": "removeAllLines"
							}`;
							
							this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(REMOVE_ALL_LINES_PAM_MAP_COMMAND);
							
							//??? stop using "this.#gtfsRouteLines"
							if (getType(this.#gtfsRouteLines) === getType.string && this.#gtfsRouteLines.length > 0) {
								//??? update code so the section below does not run on initial connect.  The maps iFrame itself will handle the initial data download
								this.#gtfsRouteLines
								.split(",")
								.forEach(curGTFSItemNumber => {
									//??? hack for summer campaign; need to do further work to understand why 'all' is being passed here
									if (curGTFSItemNumber === "all") {
										return;
									}
									
									//GUARD: do nothing if the target GTFSItemNumber is not valid
									//??? this is complex and inlined because we have a custom data structure that we do not know if we will need in the future:
									//??? [GTFSRouteLineNumber]_[GTFSDirectionNumber]
									var formattedCurGTFSItemNumber = curGTFSItemNumber;
									
									if (formattedCurGTFSItemNumber.includes("_") === true) {
										var curGTFSItemNumberParts = formattedCurGTFSItemNumber.split("_");
										
										if (curGTFSItemNumberParts.length > 2) {
											return;
										} else {
											var targetGTFSRouteLineNumber = curGTFSItemNumberParts[0];
											var targetGTFSDirectionNumber = parseInt(curGTFSItemNumberParts[1], 10);
											
											if (ifLikeGTFSRouteLineNumber(targetGTFSRouteLineNumber) === false) {
												return;
											}
											
											if (ifGTFSDirectionNumber(targetGTFSDirectionNumber) === false) {
												return;
											}
											
											formattedCurGTFSItemNumber = targetGTFSRouteLineNumber;
										}
									} else if (ifLikeGTFSItemNumber(formattedCurGTFSItemNumber) === false) {
										return;
									}
									
									//??? stop using "this.#showVehiclesForDirection" directly
									var allGTFSDirectionNumbersAsString = getType(this.#showVehiclesForDirection) === getType.string && this.#showVehiclesForDirection.length > 0 && this.#showVehiclesForDirection !== "undefined" ? this.#showVehiclesForDirection : "0,1";  //??? "0,1" is a risky hardcoding here?  otherwise, at least make it a CONST?
									
									allGTFSDirectionNumbersAsString
									.split(",")
									.map(targetBase10Int => {
										return parseInt(targetBase10Int, 10);
									})
									.filter(ifGTFSDirectionNumber)
									.forEach(curGTFSDirectionNumber => {
										switch (formattedCurGTFSItemNumber.length) {
											case 1:
											case 2:
											case 3:  //NOTE: is a GTFSRouteLine
												; (() => {
													try {
														const gtfsRouteLinePageURLStringTemplate = `/schedules-and-maps/{type}/{gtfsRouteLineNumber}/direction/{direction}/{view}`;
														
														var gtfsRouteLineMapPageURLString;
														var gtfsRouteLineSchedulePageURLString;
														
														var popupHTMLTitle;
														
														if (GTFS_LINE_NUMBERS.has(formattedCurGTFSItemNumber) === true) {
															var formattedGTFSLineName = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE.get(formattedCurGTFSItemNumber);
															
															popupHTMLTitle = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME.get(formattedCurGTFSItemNumber);
															
															gtfsRouteLineMapPageURLString = gtfsRouteLinePageURLStringTemplate
															.replaceAll("{type}", "line")
															.replaceAll("{gtfsRouteLineNumber}", formattedGTFSLineName)
															.replaceAll("{direction}", curGTFSDirectionNumber)
															.replaceAll("{view}", "map");
															
															gtfsRouteLineSchedulePageURLString = gtfsRouteLinePageURLStringTemplate
															.replaceAll("{type}", "line")
															.replaceAll("{gtfsRouteLineNumber}", formattedGTFSLineName)
															.replaceAll("{direction}", curGTFSDirectionNumber)
															.replaceAll("{view}", "schedule");
														} else {
															var isGTFSItemNumberStartingWithNumber = /^\d/.test(formattedCurGTFSItemNumber);
															
															if (isGTFSItemNumberStartingWithNumber === true) {
																popupHTMLTitle = `Route # ${formattedCurGTFSItemNumber.toUpperCase()}`;
															} else {
																popupHTMLTitle = `Route ${formattedCurGTFSItemNumber.toUpperCase()}`;
															}
															
															gtfsRouteLineMapPageURLString = gtfsRouteLinePageURLStringTemplate
															.replaceAll("{type}", "route")
															.replaceAll("{gtfsRouteLineNumber}", formattedCurGTFSItemNumber)
															.replaceAll("{direction}", curGTFSDirectionNumber)
															.replaceAll("{view}", "map");
															
															gtfsRouteLineSchedulePageURLString = gtfsRouteLinePageURLStringTemplate
															.replaceAll("{type}", "route")
															.replaceAll("{gtfsRouteLineNumber}", formattedCurGTFSItemNumber)
															.replaceAll("{direction}", curGTFSDirectionNumber)
															.replaceAll("{view}", "schedule");
														}
														
														var gtfsRouteLineMapPageURL;
														var gtfsRouteLineSchedulePageURL;
														
														try {
															gtfsRouteLineMapPageURL = gtfsRouteLineMapPageURLString && new URL(gtfsRouteLineMapPageURLString, document.location.origin);
															gtfsRouteLineSchedulePageURL = gtfsRouteLineSchedulePageURLString && new URL(gtfsRouteLineSchedulePageURLString, document.location.origin);
														} catch (error) {
															console.error(error);
														}
														
														var popupHTML;
														
														if (getType(gtfsRouteLineMapPageURL) === getType.url && getType(gtfsRouteLineSchedulePageURL) === getType.url) {
															if (GTFS_LINE_NUMBERS.has(formattedCurGTFSItemNumber) === true) {
																popupHTML = `<h3 style='margin: 0px;'>${popupHTMLTitle}</h3><div style='display: flex; justify-content: space-between; gap: 1rem; margin-top: 0.5rem;'><a href='${gtfsRouteLineMapPageURL}' target='_top'>Display all stations</a><a href='${gtfsRouteLineSchedulePageURL}' target='_top' style='margin-left: auto;'>View full schedule</a></div>`;
															} else {
																popupHTML = `<h3 style='margin: 0px;'>${popupHTMLTitle}</h3><div style='display: flex; justify-content: space-between; gap: 1rem; margin-top: 0.5rem;'><a href='${gtfsRouteLineMapPageURL}' target='_top'>Display all stops</a><a href='${gtfsRouteLineSchedulePageURL}' target='_top' style='margin-left: auto;'>View full schedule</a></div>`;
															}
														} else {
															popupHTML = `<h3 style='margin: 0px;'>${popupHTMLTitle}</h3>`;
														}
														
														var targetGTFSItemNumber = formattedCurGTFSItemNumber;
														var targetGTFSDirectionNumber;
														
														if (curGTFSItemNumber.includes("_") === true) {
															targetGTFSDirectionNumber = curGTFSItemNumberParts[1]; //??? need to validate if this is actually a GTFSDirectionNumber
														} else {
															targetGTFSDirectionNumber = curGTFSDirectionNumber;
														}
														
														var addPathCommand = "";
														
														if (this.#gtfsDestination) {
															addPathCommand = `{
																"commandType": "addPathForGTFSRouteLine"
																, "name": "${formattedCurGTFSItemNumber}_${targetGTFSDirectionNumber}"
																, "gtfsRouteLineNumber": "${formattedCurGTFSItemNumber}"
																, "gtfsDirections": ${targetGTFSDirectionNumber}
																, "gtfsDestination": "${this.#gtfsDestination}"
																, "onClickCommand": "selectPath"
																, "popupHTML": "${popupHTML}"
															}`;
														} else {
															addPathCommand = `{
																"commandType": "addPathForGTFSRouteLine"
																, "name": "${formattedCurGTFSItemNumber}_${targetGTFSDirectionNumber}"
																, "gtfsRouteLineNumber": "${formattedCurGTFSItemNumber}"
																, "gtfsDirections": ${targetGTFSDirectionNumber}
																, "onClickCommand": "selectPath"
																, "popupHTML": "${popupHTML}"
															}`;
														}
														
														this.#messageChannelPortWithGoogleMapIFrame && addPathCommand && this.#messageChannelPortWithGoogleMapIFrame.postMessage(addPathCommand);
													} catch (error) {
														console.error(error);
													}
												})();
												
												break;
											case 5:  //NOTE: is a GTFSLocation //??? replace with enum in gtfs helper?
												; (async () => {
													try {
														//GUARD: do nothing if there is no target GTFSLocationNumber
														if (ifLikeGTFSLocationNumber(curGTFSItemNumber) === false) {
															return;
														}
														
														//GUARD: do nothing if the widget is no longer trying to render this GTFSRouteLine
														if (this.#gtfsRouteLines.split(",").includes(curGTFSItemNumber) === false) {
															return;
														}
														
														var targetGTFSLocationSchedulesForToday = await Promise.all([
															fetchGTFSStationSchedulesForDate(curGTFSItemNumber, new Date())
															, fetchGTFSStopSchedulesForDate(curGTFSItemNumber, new Date())
														]);
														
														//GUARD: do nothing if there are no GTFSSchedules
														if (Array.isArray(targetGTFSLocationSchedulesForToday) === false) {
															return;
														}
														
														targetGTFSLocationSchedulesForToday
														.flat()
														.flatMap(parseGTFSLocationScheduleRouteLines)
														.map(this.#getGTFSScheduleRouteLine)
														.filter(ifTruthyValue)
														.forEach(async curGTFSDestination => {  //??? pretty sure that "curGTFSDestination" is just a completely wrong name
															try {
																var curGTFSRouteLineNumber = curGTFSDestination.gtfsRouteLineNumber;
																
																//GUARD: do nothing if the target GTFSRouteLineNumber is not valid
																if (ifLikeGTFSRouteLineNumber(curGTFSRouteLineNumber) === false) {
																	return;
																}
																
																//GUARD: do nothing if the target GTFSDirectionNumber is not valid
																if (ifGTFSDirectionNumber(curGTFSDirectionNumber) === false) {
																	return;
																}
																
																//??? I think that by doing the command creation here, we run the risk of sending duplicate "commandType": "addPathForGTFSRouteLine" commands.  I think we need to make a Set of command objects and run them at the very end.  Possibility for pipelining exists....
																//??? the difficulty is that this is inside a "forEach(async)", we need to convert "curGTFSLocation.r.forEach" into an awaitable loop first....
																var gtfsPathForGTFSRouteLineNumberAndGTFSDirectionNumber = await fetchGTFSPathsForGTFSRouteLineNumberAndGTFSDirectionNumber(curGTFSRouteLineNumber, curGTFSDirectionNumber);
																
																//GUARD: do nothing if there is no GTFS Path
																if (Array.isArray(gtfsPathForGTFSRouteLineNumberAndGTFSDirectionNumber) === false) {
																	return;
																}
																
																const gtfsRouteLinePageURLStringTemplate = "/schedules-and-maps/{type}/{curGTFSRouteLineNumber}/direction/{direction}/{view}";
																
																var gtfsRouteLineMapPageURLString;
																var gtfsRouteLineSchedulePageURLString;
																
																var popupHTMLTitle;
																
																if (GTFS_LINE_NUMBERS.has(curGTFSRouteLineNumber) === true) {
																	var formattedGTFSLineName = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE.get(curGTFSRouteLineNumber);
																	
																	popupHTMLTitle = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME.get(curGTFSRouteLineNumber);
																	
																	gtfsRouteLineMapPageURLString = gtfsRouteLinePageURLStringTemplate
																	.replaceAll("{type}", "line")
																	.replaceAll("{curGTFSRouteLineNumber}", formattedGTFSLineName)
																	.replaceAll("{direction}", curGTFSDirectionNumber)
																	.replaceAll("{view}", "map");
																	
																	gtfsRouteLineSchedulePageURLString = gtfsRouteLinePageURLStringTemplate
																	.replaceAll("{type}", "line")
																	.replaceAll("{curGTFSRouteLineNumber}", formattedGTFSLineName)
																	.replaceAll("{direction}", curGTFSDirectionNumber)
																	.replaceAll("{view}", "schedule");
																} else {
																	var isGTFSRouteLineNumberStartingWithNumber = /^\d/.test(curGTFSRouteLineNumber);
																	
																	if (isGTFSRouteLineNumberStartingWithNumber === true) {
																		popupHTMLTitle = `Route # ${curGTFSRouteLineNumber.toUpperCase()}`;
																	} else {
																		popupHTMLTitle = `Route ${curGTFSRouteLineNumber.toUpperCase()}`;
																	}
																	
																	gtfsRouteLineMapPageURLString = gtfsRouteLinePageURLStringTemplate
																	.replaceAll("{type}", "route")
																	.replaceAll("{curGTFSRouteLineNumber}", curGTFSRouteLineNumber)
																	.replaceAll("{direction}", curGTFSDirectionNumber)
																	.replaceAll("{view}", "map");
																	
																	gtfsRouteLineSchedulePageURLString = gtfsRouteLinePageURLStringTemplate
																	.replaceAll("{type}", "route")
																	.replaceAll("{curGTFSRouteLineNumber}", curGTFSRouteLineNumber)
																	.replaceAll("{direction}", curGTFSDirectionNumber)
																	.replaceAll("{view}", "schedule");
																}
																
																var gtfsRouteLineMapPageURL;
																var gtfsRouteLineSchedulePageURL;
																
																try {
																	gtfsRouteLineMapPageURL = gtfsRouteLineMapPageURLString && new URL(gtfsRouteLineMapPageURLString, document.location.origin);
																	gtfsRouteLineSchedulePageURL = gtfsRouteLineSchedulePageURLString && new URL(gtfsRouteLineSchedulePageURLString, document.location.origin);
																} catch (error) {
																	console.error(error);
																}
																
																var popupHTML;
																
																if (getType(gtfsRouteLineMapPageURL) === getType.url && getType(gtfsRouteLineSchedulePageURL) === getType.url) {
																	if (GTFS_LINE_NUMBERS.has(curGTFSRouteLineNumber) === true) {
																		popupHTML = `<h3 style='margin: 0px;'>${popupHTMLTitle}</h3><div style='display: flex; justify-content: space-between; gap: 1rem; margin-top: 0.5rem;'><a href='${gtfsRouteLineMapPageURL}' target='_top'>Display all stations</a><a href='${gtfsRouteLineSchedulePageURL}' target='_top' style='margin-left: auto;'>View full schedule</a></div>`;
																	} else {
																		popupHTML = `<h3 style='margin: 0px;'>${popupHTMLTitle}</h3><div style='display: flex; justify-content: space-between; gap: 1rem; margin-top: 0.5rem;'><a href='${gtfsRouteLineMapPageURL}' target='_top'>Display all stops</a><a href='${gtfsRouteLineSchedulePageURL}' target='_top' style='margin-left: auto;'>View full schedule</a></div>`;
																	}
																} else {
																	popupHTML = `<h3 style='margin: 0px;'>${popupHTMLTitle}</h3>`;
																}
																
																gtfsPathForGTFSRouteLineNumberAndGTFSDirectionNumber
																.forEach(() => {
																	var addPathCommand = "";
																	
																	//??? why are we sending "curGTFSRouteLineNumber" for GTFS Lines?
																	if (this.#gtfsDestination) {
																		addPathCommand = `{
																			"commandType": "addPathForGTFSRouteLine"
																			, "name": "${curGTFSRouteLineNumber}_${curGTFSDirectionNumber}"
																			, "gtfsRouteLineNumber": "${curGTFSRouteLineNumber}"
																			, "gtfsDirections": ${curGTFSDirectionNumber}
																			, "gtfsDestination": "${this.#gtfsDestination}"
																			, "onClickCommand": "selectPath"
																			, "popupHTML": "${popupHTML}"
																		}`;  //??? factor "curGTFSRouteLineName" out
																	} else {
																		addPathCommand = `{
																			"commandType": "addPathForGTFSRouteLine"
																			, "name": "${curGTFSRouteLineNumber}_${curGTFSDirectionNumber}"
																			, "gtfsRouteLineNumber": "${curGTFSRouteLineNumber}"
																			, "gtfsDirections": ${curGTFSDirectionNumber}
																			, "onClickCommand": "selectPath"
																			, "popupHTML": "${popupHTML}"
																		}`;  //??? factor "curGTFSRouteLineName" out
																	}
																	
																	this.#messageChannelPortWithGoogleMapIFrame && addPathCommand && this.#messageChannelPortWithGoogleMapIFrame.postMessage(addPathCommand);
																});
															} catch (error) {
																console.error(error);
															}
														});
													} catch (error) {
														console.error(error);
													}
												})();
												
												break;
											default:
												; (() => {
													//??? error logging???
												})();
												
												break;
										}
									});
								});
							}
						});
					})();
					
					break;
				case "data-gtfsdestination":
					; (() => {
						//GUARD: do nothing if the value hasn't changed
						if (this.#gtfsDestination === curValue) {
							return;
						}
						
						this.#gtfsDestination = curValue;
					})();
					
					break;
				case "data-gtfslocations":
					; (() => {
						//GUARD: do nothing if the value hasn't changed
						if (this.#gtfsLocations === curValue) {
							return;
						}
						
						this.#gtfsLocations = curValue;  //??? probably need to do some validation here
						
						this.#isConnected === true && window.runAfterPamMapLoad(this, () => {
							const REMOVE_ALL_GTFSLOCATIONS_COMMAND = `{
								"commandType": "removeAllNamedMarkers"
							}`;
							
							this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(REMOVE_ALL_GTFSLOCATIONS_COMMAND);
							
							//re-add any custom markers that were removed by 'removeAllNamedMarkers'
							var existingCustomMarkers = this.hasAttribute("data-custom-markers") && this.getAttribute("data-custom-markers");
							
							if (getType(existingCustomMarkers) === getType.string && existingCustomMarkers.length > 0) {
								this.setAttribute("data-custom-markers", existingCustomMarkers);
							}
							
							//add target GTFS Locations
							if (getType(this.#gtfsLocations) === getType.string && this.#gtfsLocations.length > 0) {
								this.#gtfsLocations
								.split(",")
								.forEach(async curGTFSItemNumber => {
									//GUARD: do nothing if curGTFSItemNumber is not valid
									if (ifLikeGTFSItemNumber(curGTFSItemNumber) === false) {
										return;
									}
									
									//??? update code so the section below does not run on initial connect.  The maps iframe itself will handle the initial data download  //??? what does this mean?  I don't understand
									var curGTFSItemNumberLength = curGTFSItemNumber.length;
									
									switch (curGTFSItemNumberLength) {
										case 1:
										case 2:
										case 3:  //NOTE: is a GTFSRouteLine //??? replace with enum in gtfs helper?
											; (async () => {
												if (GTFS_LINE_NUMBERS.has(curGTFSItemNumber) === true) {
													var allGTFSStationsForCurGTFSLine;
													
													switch (curGTFSItemNumber) {
														case GTFS_CANADA_LINE_NUMBER:
															; (() => {
																allGTFSStationsForCurGTFSLine = GTFS_CANADA_LINE_STATIONS_FROM_USAGE;
															})();
															
															break;
														case GTFS_MILLENNIUM_LINE_NUMBER:
															; (() => {
																allGTFSStationsForCurGTFSLine = GTFS_MILLENNIUM_LINE_STATIONS_FROM_USAGE;
															})();
															
															break;
														case GTFS_EXPO_LINE_NUMBER:
															; (() => {
																allGTFSStationsForCurGTFSLine = GTFS_EXPO_LINE_STATIONS_FROM_USAGE;
															})();
															
															break;
														case GTFS_WEST_COAST_EXPRESS_LINE_NUMBER:
															; (() => {
																allGTFSStationsForCurGTFSLine = GTFS_WEST_COAST_EXPRESS_STATIONS_FROM_USAGE;
															})();
															
															break;
														case GTFS_SEABUS_LINE_NUMBER:
															; (() => {
																allGTFSStationsForCurGTFSLine = GTFS_SEABUS_STATIONS_FROM_USAGE;
															})();
															
															break;
														default:
															; (() => {
																//??? show error? log custom error
															})();
															
															break;
													}
													
													allGTFSStationsForCurGTFSLine && Array.from(allGTFSStationsForCurGTFSLine)
													.forEach(curGTFSStation => {
														var gtfsStationNumber = parseGTFSStationNumber(curGTFSStation);
														
														//GUARD: do nothing if the GTFSStationNumber is not valid
														if (ifLikeGTFSStationNumber(gtfsStationNumber) === false) {
															return;
														}
														
														var gtfsStationLatLng = parseGTFSStationLatLng(curGTFSStation);
														
														//GUARD: do nothing if the LatLng is not valid
														if (ifLatLng(gtfsStationLatLng) === false) {
															return;
														}
														
														//GUARD: do nothing if the target LatLng is not within the GVTA
														if (ifLatLngWithinGVTA(gtfsStationLatLng) === false) {
															return;
														}
														
														var gtfsStationLat = gtfsStationLatLng[0];
														var gtfsStationLng = gtfsStationLatLng[1];
														
														var addGTFSLocationMarkerCommand = `
															{
																"commandType": "addMarker"
																, "name": "${gtfsStationNumber}"
																, "placeID": "${gtfsStationNumber}"
																, "position": {
																	"lat": ${gtfsStationLat}
																	, "lng": ${gtfsStationLng}
																}
																, "zIndex": 8888
																, "onClickCommand": "selectPlace"
															}
														`;  //NOTE: no need to set an icon because we want to use the defaults which are based on the place ID
														
														this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(addGTFSLocationMarkerCommand);
													});
												} else {
													try {
														var allGTFSStopsByNumber = await fetchGTFSStopsByNumber;
														
														var curGTFSStop = allGTFSStopsByNumber.get(curGTFSItemNumber);
														
														//GUARD: do nothing if there is no data
														if (getType(curGTFSStop) !== getType.object) {
															return;
														}
														
														var curGTFSStopNumber = parseGTFSStopNumber(curGTFSStop);
														
														//GUARD: do nothing if the GTFSStation number is not valid
														if (ifLikeGTFSStopNumber(curGTFSStopNumber) === false) {
															return;
														}
														
														var curGTFSStopLatLng = parseGTFSStopLatLng(curGTFSStop);
														
														//GUARD: do nothing if the LatLng is not valid
														if (ifLatLng(curGTFSStopLatLng) === false) {
															return;
														}
														
														//GUARD: do nothing if the target GTFSLocation is not within the GVTA
														if (ifLatLngWithinGVTA(curGTFSStopLatLng) === false) {
															return;
														}
														
														var curGTFSStopLat = curGTFSStopLatLng[0];
														var curGTFSStopLng = curGTFSStopLatLng[1];
														
														var addGTFSLocationMarkerCommand = `
															{
																"commandType": "addMarker"
																, "name": "${curGTFSStopNumber}"
																, "placeID": "${curGTFSStopNumber}"
																, "position": {
																	"lat": ${curGTFSStopLat}
																	, "lng": ${curGTFSStopLng}
																}
																, "zIndex": 8888
																, "onClickCommand": "selectPlace"
															}
														`;  //NOTE: no need to set an icon because we want to use the defaults which are based on the place ID
														
														this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(addGTFSLocationMarkerCommand);
													} catch (error) {
														console.error(error);
													}
												}
											})();
											
											break;
										case 5:  //NOTE: is a GTFSLocation //??? replace with enum in gtfs helper?
											; (async () => {
												try {
													var targetGTFSItemNumber = GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER.get(curGTFSItemNumber) || curGTFSItemNumber;
													
													var allGTFSStationsByNumber = await fetchGTFSStationsByNumber;
													
													var gtfsLocationLatLng;
													
													if (allGTFSStationsByNumber.has(targetGTFSItemNumber) === true) {
														var curGTFSStation = allGTFSStationsByNumber.get(targetGTFSItemNumber);
														
														//GUARD: do nothing if there is no data
														if (getType(curGTFSStation) !== getType.object) {
															return;
														}
														
														gtfsLocationLatLng = parseGTFSStationLatLng(curGTFSStation);
													} else {
														var allGTFSStopsByNumber = await fetchGTFSStopsByNumber;
														
														var curGTFSStop = allGTFSStopsByNumber.get(targetGTFSItemNumber);
														
														//GUARD: do nothing if there is no data
														if (getType(curGTFSStop) !== getType.object) {
															return;
														}
														
														gtfsLocationLatLng = parseGTFSStopLatLng(curGTFSStop);
													}
													
													//GUARD: do nothing if the LatLng is not valid
													if (ifLatLng(gtfsLocationLatLng) === false) {
														return;
													}
													
													//GUARD: do nothing if the target GTFSLocation is not within the GVTA
													if (ifLatLngWithinGVTA(gtfsLocationLatLng) === false) {
														return;
													}
													
													var gtfsLocationLat = gtfsLocationLatLng[0];
													var gtfsLocationLng = gtfsLocationLatLng[1];
													
													var addGTFSLocationMarkerCommand = `
														{
															"commandType": "addMarker"
															, "name": "${targetGTFSItemNumber}"
															, "placeID": "${targetGTFSItemNumber}"
															, "position": {
																"lat": ${gtfsLocationLat}
																, "lng": ${gtfsLocationLng}
															}
															, "zIndex": 8888
															, "onClickCommand": "selectPlace"
														}
													`; //NOTE: no need to set an icon because we want to use the defaults which are based on the place ID
													
													this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(addGTFSLocationMarkerCommand);
												} catch (error) {
													console.error(error);
												}
											})();
											
											break;
										default:
											; (() => {
												
											})();
											
											break;
									}
								});
							}
						});
					})();
					
					break;
				case "data-show-all-nearby-gtfslocations":
					; (() => {
						this.#showAllNearbyGTFSLocations = curValue;
						
						this.#isConnected === true && window.runAfterPamMapLoad(this, () => {
							if (curValue === "true") {
								var showAllNearbyGTFSLocationsCommand = `{
									"commandType": "showAllZoomMarkers"
								}`;
								
								this.#messageChannelPortWithGoogleMapIFrame.postMessage(showAllNearbyGTFSLocationsCommand);
							} else {
								var removeAllNearbyGTFSLocationsCommand = `{
									"commandType": "removeAllZoomMarkers"
								}`;
								
								this.#messageChannelPortWithGoogleMapIFrame.postMessage(removeAllNearbyGTFSLocationsCommand);
							}
						});
					})();
					
					break;
				case "data-show-vehicles-for-direction":
					; (() => {
						const REMOVE_VEHICLES_PAM_MAP_COMMAND = `{
							"commandType": "removeAllVehicles"
						}`;
						
						//GUARD: do nothing if there is no attribute or it has no value
						//NOTE: we always remove vehicles even if there is no new value
						if (getType(curValue) !== getType.string || curValue.length === 0) {
							window.runAfterPamMapLoad(this, () => {
								this.#messageChannelPortWithGoogleMapIFrame.postMessage(REMOVE_VEHICLES_PAM_MAP_COMMAND);
							});
							
							return;
						}
						
						//??? put in validation?
						var gtfsDirectionNumbers;
						
						switch (curValue.toLowerCase()) {
							case "0":
							case "outbound":
								; (() => {
									gtfsDirectionNumbers = [0];
								})();
								
								break;
							case "1":
							case "inbound":
								; (() => {
									gtfsDirectionNumbers = [1];
								})();
								
								break;
							case "0,1":
							case "1,0":
							case "all":
								; (() => {
									gtfsDirectionNumbers = [0, 1];
								})();
								
								break;
							default:
								; (() => {
									
								})();
								
								break;
						}
						
						var gtfsDirectionNumbersAsString = gtfsDirectionNumbers
						.filter(ifGTFSDirectionNumber)
						.map(curGTFSDirectionNumber => {
							return curGTFSDirectionNumber.toString();
						})
						.toString();
						
						//??? do we need to do anything if the array of GTFSDirectionNumbers is empty?
						
						//GUARD: do nothing if the value hasn't changed
						if (this.#showVehiclesForDirection === gtfsDirectionNumbersAsString) {
							return;
						}
						
						this.#showVehiclesForDirection = gtfsDirectionNumbersAsString;
						
						//??? why is the command sometimes set with "gtfsDirectionNumbers" and other times with "this.#showVehiclesForDirection"?  it seems like it should always be the latter.
						//??? also, "this.#showVehiclesForDirection" needs to be validated with "GTFSHelpers.ifGTFSDirectionNumber()"
						this.#isConnected === true && window.runAfterPamMapLoad(this, () => {
							if (Array.isArray(gtfsDirectionNumbers) === true && this.#messageChannelPortWithGoogleMapIFrame) {
								//NOTE: we need to remove all lines and re-add so they will be updated with the proper direction
								var curGTFSRouteLines = this.getAttribute("data-gtfsroutelines");
								
								this.setAttribute("data-gtfsroutelines", ""); //NOTE: we are intentionally clearing
								this.setAttribute("data-gtfsroutelines", curGTFSRouteLines);
								
								var showVehiclesCommand = `{
									"commandType": "showVehiclesForDirection"
									, "directions": [${gtfsDirectionNumbers}]
								}`;
								
								this.#messageChannelPortWithGoogleMapIFrame.postMessage(showVehiclesCommand);
								
							}
						});
						
						if (this.#isPauseVehiclePositionUpdatesOnVisibilityChangedInited === false) {
							this.#isPauseVehiclePositionUpdatesOnVisibilityChangedInited = true;
							
							document.addEventListener("visibilitychange", e => {
								if (document.hidden === true) {
									this.#messageChannelPortWithGoogleMapIFrame.postMessage(REMOVE_VEHICLES_PAM_MAP_COMMAND);
								} else {
									if (getType(this.#showVehiclesForDirection) === getType.string && this.#showVehiclesForDirection.length > 0 && this.#messageChannelPortWithGoogleMapIFrame) {  //NOTE: we need to remove all lines and re-add so they will be updated with the proper direction
										if (this.hasAttribute("data-gtfsroutelines") === true) {
											var curGTFSRouteLineNumbers = this.getAttribute("data-gtfsroutelines");
											
											this.setAttribute("data-gtfsroutelines", "");
											this.setAttribute("data-gtfsroutelines", curGTFSRouteLineNumbers);
										}
										
										var showVehiclesCommand = `{
											"commandType": "showVehiclesForDirection"
											, "directions": [${this.#showVehiclesForDirection}]
										}`;
										
										this.#messageChannelPortWithGoogleMapIFrame.postMessage(showVehiclesCommand);
									}
								}
							});
						}
					})();
					
					break;
				case "data-show-vehicles-for-gtfslocations":
					; (() => {
						this.#showVehiclesForGTFSLocations = curValue && curValue
						.split(",")
						.filter(curCandidateGTFSLocation => {
							var isMatchingGTFSLocationFormat = parseInt(curCandidateGTFSLocation, 10).length === 5;
							
							return isMatchingGTFSLocationFormat === true;
						});
					})();
					
					break;
				case "data-only-show-vehicle-numbers":
					; (() => {
						; (() => {
							//GUARD: do nothing if the value hasn't changed
							if (this.#onlyShowVehicleNumbers === curValue) {
								return;
							}
							
							this.#onlyShowVehicleNumbers = curValue.split(",");
						})();
					})();
					
					break;
				case "data-center-to":
					; (() => {
						this.#centerTo = curValue;  //??? probably need to do some validation here
						
						this.#initCenterTo = this.#initCenterTo || this.#centerTo;
						
						window.runAfterPamMapLoad(this, () => {
							var gtfsItemNumberLength = this.#centerTo && this.#centerTo.length;
							
							//GUARD: do nothing if there is no GTFS item length
							if (isValidNumber(gtfsItemNumberLength) === false) {
								return;
							}
							
							switch (gtfsItemNumberLength) {
								case 1:
								case 2:
								case 3:  //NOTE: is a GTFSRouteLine //??? replace with enum in gtfs helper?
									; (() => {
										//??? update code so the section below does not run on initial connect.  the maps iframe itself will handle the initial data download
										
										var panToLineCommand = `{
											"commandType": "panToLine"
											, "name": "${this.#centerTo}"
										}`;
										
										this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(panToLineCommand);
									})();
									
									break;
								case 5:  //NOTE: is a GTFSLocation //??? replace with enum in gtfs helper?
								case 7:  //NOTE: is a custom marker
									; (() => {
										//??? update code so the section below does not run on initial connect.  the maps iframe itself will handle the initial data download
										
										var panToMarkerCommand = `{
											"commandType": "panToMarker"
											, "name": "${this.#centerTo}"
										}`;
										
										this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(panToMarkerCommand);
									})();
									
									break;
								default:  //NOTE: is likely a lat/lng
									; (() => {
										var lat = this.#centerTo.split(",")[0];
										var lng = this.#centerTo.split(",")[1];
										
										//??? update code so the section below does not run on initial connect.  the maps iframe itself will handle the initial data download
										
										var panCommand = `{
											"commandType": "panTo"
											, "lat": ${lat}
											, "lng": ${lng}
										}`;
										
										lat && lng && this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(panCommand);
									})();
									
									break;
							}
						});
					})();
					
					break;
				case "data-heading-in-degrees":
					; (() => {
						var newHeadingInDegrees = parseFloat(curValue);
						
						this.#isConnected === true && window.runAfterPamMapLoad(this, () => {
							//GUARD: do nothing if the heading is not a valid number
							if (isValidNumber(newHeadingInDegrees) === false) {
								return;
							}
							
							var setHeadingInDegreesCommand = `{
								"commandType": "setHeadingInDegrees"
								, "headingInDegrees": ${newHeadingInDegrees}
							}`;
							
							this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(setHeadingInDegreesCommand);
						});
					})();
					
					break;
				case "data-focus-on":
					; (() => {
						this.#focusOn = curValue;  //??? probably need to do some validation here
						
						window.runAfterPamMapLoad(this, () => {
							var gtfsItemNumberLength = this.#focusOn.length;
							
							switch (gtfsItemNumberLength) {
								case 1:
								case 2:
								case 3:  //NOTE: is a GTFSRouteLine //??? replace with enum in gtfs helper?
									; (() => {
										//??? this is WRONG; this is just panning, not clicking on.  do we even have a way to click on a line?
										var panToLineCommand = `{
											"commandType": "panToLine"
											, "name": "${this.#focusOn}"
										}`;
										
										this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(panToLineCommand);
									})();
									
									break;
								case 5:  //NOTE: is a GTFSLocation //??? replace with enum in gtfs helper?
								case 7:  //NOTE: is a custom marker
									; (() => {
										var clickOnMarkerCommand = `{
											"commandType": "clickOnMarker"
											, "name": "${this.#focusOn}"
										}`;
										
										this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(clickOnMarkerCommand);
									})();
									
									break;
							}
						});
					})();
					
					break;
				case "data-view-all-of":
					; (() => {
						this.#viewAllTarget = curValue;  //??? probably need to do some validation here
						
						//GUARD: do nothing if curValue is not valid
						if (!curValue) {
							return;
						}
						
						switch (curValue.toLowerCase()) {
							case "":
							case "hd":
								; (() => {
									const SET_DEFAULT_ZOOM_LEVEL_COMMAND = `{
										"commandType": "setZoom"
										, "zoom": 10
									}`;
									
									this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(SET_DEFAULT_ZOOM_LEVEL_COMMAND);
								})();
								
								return;

								break;
							case "all":
								; (() => {
									var setZoomLevelCommand = `{
										"commandType": "setZoom"
										, "zoom": ${this.#initZoomLevel || 10}
									}`;
									
									this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(setZoomLevelCommand);
									
									this.removeAttribute("data-center-to");
									this.setAttribute("data-center-to", this.#initCenterTo);
								})();
								
								return;
								
								break;
							case "000":
								; (() => {
									this.setAttribute("data-view-all-of", curValue.replace("000", "992,991,980"));
								})();
								
								return;
								
								break;
							default:
								; (() => {
									
								})();
								
								break;
						}
						
						window.runAfterPamMapLoad(this, () => {
							var targetGTFSItemNumber = this.#viewAllTarget; //??? this can be multiple items, so we should add pluralization
							
							var gtfsItemNumberLength;
							
							if (targetGTFSItemNumber.includes("_") === true) {
								var targetGTFSItemNumberParts = targetGTFSItemNumber.split("_");
								
								var targetGTFSRouteLineNumber = targetGTFSItemNumberParts[0];
								
								gtfsItemNumberLength = targetGTFSRouteLineNumber.length;
							} else {
								gtfsItemNumberLength = targetGTFSItemNumber.length
							}
							
							//GUARD: do nothing if there is no GTFS item length
							if (isValidNumber(gtfsItemNumberLength) === false) {
								return;
							}
							
							switch (gtfsItemNumberLength) {
								case 5:  //NOTE: is a GTFSLocation //??? replace with enum in gtfs helper?
								case 7:  //NOTE: is a custom marker
									; (() => {
										//??? will we ever have a 5 digit GTFS item made of multiple markers?
									})();
									
									break;
								case 1:
								case 2:
								case 3:  //NOTE: is a GTFSRouteLine //??? replace with enum in gtfs helper?
								default:
									; (() => {
										var viewAllOfTargetsCommand = `{
											"commandType": "setZoomToLine"
											, "name": "${targetGTFSItemNumber}"
										}`;
										
										this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(viewAllOfTargetsCommand);
									})();
									
									break;
							}
						});
					})();
					
					break;
				case "data-zoom-level":
					; (() => {
						//GUARD: do nothing if zoom level is not set
						if (curValue === undefined || curValue === null || curValue === "") {
							return;
						}
						
						this.#zoomLevel = parseInt(curValue, 10);  //??? probably need to do some validation here
						
						this.#initZoomLevel = this.#initZoomLevel || this.#zoomLevel;
						
						window.runAfterPamMapLoad(this, () => {
							var setZoomLevelCommand = `{
								"commandType": "setZoom"
								, "zoom": ${this.#zoomLevel}
							}`;
							
							this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(setZoomLevelCommand);
						});
					})();
					
					break;
				case "data-hide-path-direction":
					; (() => {
						this.#isHidingPathDirection = curValue === "true" ? true : false;
						
						window.runAfterPamMapLoad(this, () => {
							var setZoomLevelCommand = `{
								"commandType": "updatePathDirectionArrows"
								, "showDirectionArrows": ${!this.#isHidingPathDirection}
							}`; //??? refactor out "!this.#isHidingPathDirection"
							
							this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(setZoomLevelCommand);
						});
					})();
					
					break;
				case "data-customized-gtfsroutelines":
					; (() => {
						this.#customizedGTFSRouteLines = curValue;
					})();
					
					break;
				case "data-customized-gtfsroutelines-colors":
					; (() => {
						this.#customizedGTFSRouteLineColors = curValue;
					})();
					
					break;
				case "data-custom-markers":
					; (() => {
						//GUARD: do nothing if the value hasn't changed
						if (this.#customMarkerIDs === curValue) {
							return;
						}
						
						this.#customMarkerIDs = curValue;
						
						window.runAfterPamMapLoad(this, () => {
							var allPrevCustomMarkerIDs = prevValue && prevValue.split(",").filter(ifTruthyValue);
							
							var allCustomMarkerIDs = this.#customMarkerIDs && this.#customMarkerIDs.split(",").filter(ifTruthyValue) || [];
							
							var allCustomMarkerIDsToRemove = allPrevCustomMarkerIDs && allPrevCustomMarkerIDs.filter(curPrevCustomMarkerID => {
								var isRemovingCustomMarkerID = true;
								
								if (allCustomMarkerIDs && allCustomMarkerIDs.includes) {
									if (allCustomMarkerIDs.includes(curPrevCustomMarkerID) === true) {
										//do not remove the custom marker because it still exists
										isRemovingCustomMarkerID = false;
									}	
								}
								
								return isRemovingCustomMarkerID;
							});
							
							allCustomMarkerIDsToRemove && allCustomMarkerIDsToRemove.forEach(curCustomMarkerID => {
								var removeCustomMarkerCommand = `
									{
										"commandType": "removeMarkerByName"
										, "name": "${curCustomMarkerID}"
									}
								`;
								
								removeCustomMarkerCommand && this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(removeCustomMarkerCommand);
							});
							
							var allCustomMarkerIDsToAdd = allCustomMarkerIDs.filter(curCustomMarkerID => {
								var isAddingCustomMarkerID = true;
								
								if (allPrevCustomMarkerIDs && allPrevCustomMarkerIDs.includes) {
									if (allPrevCustomMarkerIDs.includes(curCustomMarkerID) === true) {
										//do not add the custom marker because it already exists
										isAddingCustomMarkerID = false;
									}
								}
								
								return isAddingCustomMarkerID;
							});
							
							allCustomMarkerIDsToAdd && allCustomMarkerIDsToAdd.forEach(curCustomMarkerID => {
								var curCustomMarker = document.querySelector(`pam-map-marker[data-custom-marker-id="${curCustomMarkerID}"]`);
								
								if (curCustomMarker) {
									//add custom marker to map
									var customMarkerID = curCustomMarker.hasAttribute("data-custom-marker-id") && curCustomMarker.getAttribute("data-custom-marker-id");
									
									//??? validate "customMarkerID"
									//GUARD: do nothing if the custom markerID is not valid
									//??? need a better validation...
									if (getType(customMarkerID) !== getType.string) {
										return;
									}
									
									var customMarkerLatLngString = curCustomMarker.hasAttribute("data-latlng") && curCustomMarker.getAttribute("data-latlng");
									
									var customMarkerLatLng = convertLatLngStringToLatLng(customMarkerLatLngString);
									
									//GUARD: do nothing if there is no valid latlng
									if (ifLatLng(customMarkerLatLng) === false) {
										return;
									}
									
									//GUARD: do nothing if the target LatLng is not within the GVTA
									if (ifLatLngWithinGVTA(customMarkerLatLng) === false) {
										return;
									}
									
									var customMarkerLat = customMarkerLatLng[0];
									var customMarkerLng = customMarkerLatLng[1];
									
									var customMarkerIconURL;
									
									try {
										var customMarkerIconURLString = curCustomMarker.hasAttribute("data-custom-marker-icon-url") && curCustomMarker.getAttribute("data-custom-marker-icon-url");
										customMarkerIconURL = customMarkerIconURLString && new URL(customMarkerIconURLString, document.location.origin);
										
									} catch (error) {
										console.error(error);
									}
									
									var addCustomMarkerCommand;
									
									if (getType(customMarkerIconURL) === getType.url) {
										var customMarkerIconURLAsString = customMarkerIconURL.toString();
										
										addCustomMarkerCommand =`
											{
												"commandType": "addMarker"
												, "name": "${customMarkerID}"
												, "icon": {
													"url": "${customMarkerIconURLAsString}"
													, "iconSize": [32, 32]
												}
												, "position": {
													"lat": ${customMarkerLat}
													, "lng": ${customMarkerLng}
												}
												, "zIndex": 8888
												, "onClickCommand": "selectPlace"
											}
										`;
									} else {
										addCustomMarkerCommand = `
											{
												"commandType": "addMarker"
												, "name": "${customMarkerID}"
												, "position": {
													"lat": ${customMarkerLat}
													, "lng": ${customMarkerLng}
												}
												, "zIndex": 8888
												, "onClickCommand": "selectPlace"
											}
										`;
									}
									
									if (getType(addCustomMarkerCommand) === getType.string && addCustomMarkerCommand.length > 0) {
										this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(addCustomMarkerCommand);
										
										//setup hide/show actions for the custom marker
										var isCustomMarkerHiddenObserver = new MutationObserver(allMutations => {
											var isHidden = curCustomMarker.hasAttribute("hidden");
											
											if (isHidden === true) {
												var hideCustomMarkerCommand =`
													{
														"commandType": "hideMarkerByName"
														, "name": "${customMarkerID}"
													}
												`;
												
												this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(hideCustomMarkerCommand);
											} else {
												var showCustomMarkerCommand =`
													{
														"commandType": "showMarkerByName"
														, "name": "${customMarkerID}"
													}
												`;
												
												this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(showCustomMarkerCommand);
											}
										});
										
										isCustomMarkerHiddenObserver.observe(curCustomMarker, { attributeFilter: ["hidden"] });
									}
								}
							});
						});
					})();
					
					break;
				case "data-custom-paths":
					; (() => {
						//GUARD: do nothing if the value hasn't changed
						if (this.#customPathIDs === curValue) {
							return;
						}
						
						this.#customPathIDs = curValue;
						
						window.runAfterPamMapLoad(this, () => {
							var allPrevCustomPathIDs = prevValue && prevValue.split(",").filter(ifTruthyValue);
							
							var allCustomPathIDs = this.#customPathIDs && this.#customPathIDs.split(",").filter(ifTruthyValue);
							
							//??? do we need to short-circuit if "allCustomPathIDs" is not an Array?
							//??? do we need to short-circuit if "allPrevCustomPathIDs" is not an Array?
							
							var allCustomPathIDsToRemove = allPrevCustomPathIDs && allPrevCustomPathIDs
							.filter(curPrevCustomPathID => {
								var isRemovingCustomPathID = allCustomPathIDs && allCustomPathIDs.includes(curPrevCustomPathID) === true ? false : true;
								
								return isRemovingCustomPathID;
							})
							.forEach(curPrevCustomPathID => {
								var removePrevCustomPathCommand = `
									{
										"commandType": "removePathByName"
										, "name": "${curPrevCustomPathID}"
									}
								`;
								
								removePrevCustomPathCommand && this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(removePrevCustomPathCommand);
							});
							
							var allCustomPathIDsToAdd = allCustomPathIDs && allCustomPathIDs
							.filter(curCustomPathID => {
								var isAddingCustomPathID = allPrevCustomPathIDs && allPrevCustomPathIDs.includes(curCustomPathID) === true ? false : true;
								
								return isAddingCustomPathID;
							})
							.forEach(curCustomPathID => {
								var curCustomPathElement = document.querySelector(`pam-map-path[data-custom-path-id="${curCustomPathID}"]`);
								
								if (curCustomPathElement) {
									//add custom path to map
									var customPathID = curCustomPathElement.hasAttribute("data-custom-path-id") && curCustomPathElement.getAttribute("data-custom-path-id");
									
									//GUARD: do nothing if there is no custom path ID
									if (getType(customPathID) !== getType.string || customPathID.length === 0) {
										return;
									}
									
									var allLatLngElements = Array.from(curCustomPathElement.querySelectorAll("lat-lng"));
									
									//GUARD: do nothing if there are no latlng elements
									if (Array.isArray(allLatLngElements) === false) {
										return;
									}
									
									var allPathPoints = allLatLngElements.map(curLatLngElement => {
										var latLngString = curLatLngElement.textContent;
										
										var output = {
											lat: parseFloat(latLngString.split(",")[0])
											, lng: parseFloat(latLngString.split(",")[1])
										}
										
										return output;
									});
									
									//GUARD: do nothing if there are less than 2 custom path points
									if (allPathPoints.length < 2) {
										return;
									}
									
									var customPathColor = curCustomPathElement.hasAttribute("data-custom-path-color") && curCustomPathElement.getAttribute("data-custom-path-color");
									
									var customPathTitle = curCustomPathElement.hasAttribute("data-custom-path-title") && curCustomPathElement.getAttribute("data-custom-path-title");
									
									var addCustomPathCommand = `
										{
											"commandType": "addPath"
											, "name": "${customPathID}"
											, "allPathPoints": ${JSON.stringify(allPathPoints)}
											, "pathColor": "${customPathColor || ""}"
											, "pathTitle": "${customPathTitle || ""}"
										}
									`;
									
									addCustomPathCommand && this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(addCustomPathCommand);
									
									//setup hide/show actions for the custom path
									var isCustomPathHiddenObserver = new MutationObserver(allMutations => {
										var isHidden = curCustomPath.hasAttribute("hidden");
										
										if (isHidden === true) {
											var hideCustomPathCommand =`
												{
													"commandType": "hidePathByName"
													, "name": "${customPathID}"
												}
											`;
											
											this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(hideCustomPathCommand);
										} else {
											var showCustomPathCommand =`
												{
													"commandType": "showPathByName"
													, "name": "${customPathID}"
												}
											`;
											
											this.#messageChannelPortWithGoogleMapIFrame && this.#messageChannelPortWithGoogleMapIFrame.postMessage(showCustomPathCommand);
										}
									});
									
									isCustomPathHiddenObserver.observe(curCustomPathElement, { attributeFilter: ["hidden"] });
								}
							});
						});
					})();
					
					break;
				case "data-reindeer-vehicles":
					; (() => {
						//GUARD: do nothing if the value hasn't changed
						if (this.#reindeerVehicleNumbers === curValue) {
							return;
						}
						
						this.#reindeerVehicleNumbers = curValue.split(",");
					})();
					
					break;
				case "data-show-reindeer-gtfsroutelines":
					; (() => {
						this.#showReindeerGTFSRouteLines = curValue === "false" ? false : true;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="pammapmarker">
	customElements.define("pam-map-marker", class PamMapMarker extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		#handleClick() {
			//??? refactor out the usage of so much 'this'
			
			//highlight the marker in the sidebar
			var targetPamMapMarker = this;
			
			var allPamMapMarkers = document.querySelectorAll("pam-map-marker");
			
			allPamMapMarkers.forEach(curPamMapMarker => {
				curPamMapMarker.classList.remove("focusedLocation");
				
				curPamMapMarker.hasAttribute("aria-expanded") === true && curPamMapMarker.setAttribute("aria-expanded", false);
			});
			
			targetPamMapMarker.classList.add("focusedLocation");
			
			//scroll the marker in the sidebar into view
			var targetArticleParent = targetPamMapMarker.closest("article");
			
			targetArticleParent && targetArticleParent.scrollIntoView({
				behavior: "smooth"
				, block: "nearest"
				, inline: "center"
			});
			
			//click the custom marker
			var targetPamMapMarkerID = targetPamMapMarker.hasAttribute("data-custom-marker-id") && targetPamMapMarker.getAttribute("data-custom-marker-id");
			
			if (targetPamMapMarkerID) {
				var targetPamMap = document.querySelector("pam-map");
				
				targetPamMap && targetPamMap.setAttribute("data-focus-on", targetPamMapMarkerID);
			}
		}
		
		#handlePamMapMarkerClick() {
			//??? refactor out the usage of so much 'this'
			
			//highlight the marker in the sidebar
			var targetPamMapMarker = this;
			
			var allPamMapMarkers = document.querySelectorAll("pam-map-marker");
			
			allPamMapMarkers.forEach(curPamMapMarker => {
				curPamMapMarker.classList.remove("focusedLocation");
				
				curPamMapMarker.hasAttribute("aria-expanded") === true && curPamMapMarker.setAttribute("aria-expanded", false);
			});
			
			targetPamMapMarker.classList.add("focusedLocation");
			
			//scroll the marker in the sidebar into view
			var targetArticleParent = targetPamMapMarker.closest("article");
			
			targetArticleParent && targetArticleParent.scrollIntoView({
				behavior: "smooth"
				, block: "nearest"
				, inline: "center"
			});
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.addEventListener("click", this.#handleClick);
			this.addEventListener("click-pam-map-marker", this.#handlePamMapMarkerClick);
		}
	});
</script><script class="timeRangePicker">
	customElements.define("time-range-picker", class TimeRangePicker extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-allow-end-times-past-midnight"
				, "data-start-time-input-name"
				, "data-end-time-input-name"
			];
		}
		
		#allowEndTimesPastMidnight;
		
		#startTimeInputName;
		#endTimeInputName;
		
		#setMinEndTime(startTimeInputElement, endTimeInputElement) {
			var startTimeValue = startTimeInputElement.value;
			
			var startTimeValueParts = startTimeValue && startTimeValue.split(":");
			
			var startTimeHours = startTimeValueParts && parseInt(startTimeValueParts[0], 10);
			var startTimeMinutes = startTimeValueParts && parseInt(startTimeValueParts[1], 10);
			
			//??? validate parsed hour and minute values
			var minEndDateTime = new Date();
			minEndDateTime.setHours(startTimeHours);
			minEndDateTime.setMinutes(startTimeMinutes + 1);
			
			var minEndTimeString = `${minEndDateTime.getHours().toString().padStart(2, "0")}:${minEndDateTime.getMinutes().toString().padStart(2, "0")}`;
			
			if (minEndTimeString) {
				endTimeInputElement.setAttribute("min", minEndTimeString);
			}
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			window.runAfterDOMContentLoaded(document, () => {
				var startTimeInputElement = this.#startTimeInputName && this.querySelector(`input[type="time"][name="${this.#startTimeInputName}"]`);
				var endTimeInputElement = this.#endTimeInputName && this.querySelector(`input[type="time"][name="${this.#endTimeInputName}"]`);
				
				//GUARD: do nothing if either start or end time inputs are missing
				if (!startTimeInputElement|| !endTimeInputElement) {
					this.remove();
					
					return;
				}
				
				this.#setMinEndTime(startTimeInputElement, endTimeInputElement);
				
				startTimeInputElement.addEventListener("change", () => {
					this.#setMinEndTime(startTimeInputElement, endTimeInputElement);
				});
			});
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-allow-end-times-past-midnight":
					; (() => {
						this.#allowEndTimesPastMidnight = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-start-time-input-name":
					; (() => {
						this.#startTimeInputName = curValue;
					})();
					
					break;
				case "data-end-time-input-name":
					; (() => {
						this.#endTimeInputName = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="buzzerfeed">
	customElements.define("buzzer-feed", class BuzzerFeed extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-number-of-articles"
				, "data-no-articles-found-text"
			];
		}
		
		#numArticles = 5;
		#noResultsFoundText = "The Buzzer feed failed to load. Please refresh your browser or try again later.";
		
		#renderArticle(curArticle) {
			var url = curArticle.link;  //??? not following URL Object Pattern
			var title = (curArticle.title && curArticle.title.rendered && curArticle.title.rendered.replaceAll("&#8216;", "'").replaceAll("&#8217;", "'").replaceAll("&#8211;", "-").replaceAll("&#038;", "&").replaceAll("&#8220;", '"').replaceAll("&#8221;", '"')).trim() || "";  //??? reformat this vertically/to be more readable in general...
			var articlePublishedDateTimeString = curArticle.date;
			var articlePublishedDateTime = new Date(articlePublishedDateTimeString);  //??? is there a helper from datetimehelpers.mjs?
			
			var output = document.createElement("li");
			output.setAttribute("class", "useContentSpacing useFontColor");
			
			var dateElement = document.createElement("time");
			dateElement.setAttribute("datetime", window.getDashDelimitedDateString(articlePublishedDateTime));
			dateElement.setAttribute("class", "useContentSpacing");
			
			var dateTextElementWrapper = document.createElement("small");
			
			var dateTextElement = document.createElement("strong");
			dateTextElement.textContent = articlePublishedDateTime.toLocaleDateString("en-us", {year: "numeric", month: "short", day: "numeric"});  //??? this should be in datetimehelpers.mjs?
			
			dateTextElementWrapper.append(dateTextElement);
			
			dateElement.append(dateTextElementWrapper);
			
			var linkElement = document.createElement("a");
			linkElement.setAttribute("href", url);  //??? replace with URL Object Pattern
			linkElement.setAttribute("title", `Link to '${title}' on buzzer.translink.ca`);
			linkElement.textContent = title;
			
			output.append(dateElement);
			output.append(linkElement);
			
			return output;
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			try {
				var buzzerURLString = "https://buzzer.translink.ca";
				var buzzerURL = buzzerURLString && new URL(buzzerURLString);
				
				if (buzzerURL) {
					//??? getting "preconnect was not used" warnings in console...
					var buzzerPreconnectElement = document.createElement("link");
					buzzerPreconnectElement.setAttribute("rel", "preconnect");
					buzzerPreconnectElement.setAttribute("href", buzzerURL);
					buzzerPreconnectElement.setAttribute("crossorigin", "");
					
					buzzerPreconnectElement && document.documentElement.append(buzzerPreconnectElement);
					
					window.createLazyLoader && window.createLazyLoader({
						lazyLoadTargets: this
						, onLoadFunction: async curTarget => {
							var apiURLString = "https://buzzer.translink.ca/wp-json/wp/v2/posts";
							var apiURL = apiURLString && new URL(apiURLString);
							
							//GUARD: do nothing if there is no valid URL
							if (!apiURL) {
								return;
							}
							
							apiURL.searchParams.append("per_page", this.#numArticles);
							
							try {
								var response = apiURL && await fetch(apiURL);
								var allArticles = response && response.ok === true && response.json && await response.json();
								
								//GUARD: do nothing if there are no articles
								if (!allArticles || allArticles.length === 0) {
									return;
								}
								
								var articleListElement = document.createElement("ul");
								articleListElement.setAttribute("class", "spacedList menu");
								
								allArticles.forEach(curArticle => {
									var newArticleElement = this.#renderArticle(curArticle);
									
									articleListElement.append(newArticleElement);
								});
								
								window.deleteAllChildNodes && window.deleteAllChildNodes(this);
								
								if (articleListElement.children.length > 0) {
									this.append(articleListElement);
								} else {
									this.textContent = this.#noResultsFoundText;
								}
							} catch (error) {
								window.deleteAllChildNodes && window.deleteAllChildNodes(this);
								
								var errorMessageElement = document.createElement("p");
								errorMessageElement.textContent = this.#noResultsFoundText;
								
								this.append(errorMessageElement);
							}
						}
					});
				} else {
					window.deleteAllChildNodes && window.deleteAllChildNodes(this);
					
					var errorMessageElement = document.createElement("p");
					errorMessageElement.textContent = this.#noResultsFoundText;
					
					this.append(errorMessageElement);
				}
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-number-of-articles":
					; (() => {
						this.#numArticles = parseInt(curValue, 10);
					})();
					
					break;
				case "data-no-articles-found-text":
					; (() => {
						this.#noResultsFoundText = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="documentLibrary">
	; (() => {
		const NAMESPACE = "SearchEngine";
		
		var SearchEngine = {};
		
		/* CREATE EXTERNAL HELPERS */
		var deleteAllChildNodes = window.deleteAllChildNodes || (container => {
			if (container && container.firstChild) {
				while (container.firstChild) {
					container.removeChild(container.lastChild);
				}
			}
		});
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [SearchEngine, NAMESPACE, deleteAllChildNodes];
		
		; ((SearchEngine, NAMESPACE, deleteAllChildNodes) => {
			var self = SearchEngine;
			
			/* DECLARE DATA MEMBERS */
			var apiURL;
			var indexName;
			var pathIDs;
			var excludePathIDs;
			var templateIDs;
			var defaultFacets;
			var facetOrder;
			var maxNumPageButtons;
			var useURLSettings;
			var forceSearchOnPageload;
			var getSearchTermFromURL;
			var setSearchTermInURL;
			var getSortOrderFromURL;
			var setSortOrderInURL;
			var getFacetValuesFromURL;
			var setFacetValuesInURL;
			var getPageNumberFromURL;
			var setPageNumberInURL;
			var getPageSizeFromURL;
			var setPageSizeInURL;
			var buildForm;
			var searchBoxSelector;
			var sortOrderSelector;
			var pageSizeSelector;
			var getPageButtons;
			var facetsContainerSelector;
			var facetValuesSelector;
			var resultsContainerSelector;
			var defaultSearchTerm;
			var defaultTag;
			var defaultSelectedFacets;
			var defaultSortBy
			var defaultPageSize;
			var renderResult;
			var onAfterResultsRendering;
			var renderFacet;
			var onAfterFacetRendering;
			var showNumberOfResults;
			var hideNumberOfResults;
			var showSortOrderControls;
			var hideSortOrderControls;
			var updatePagination;
			var searchAPISystemErrorMessage;
			var mockSearchAPI;
			var isSearchTermRequiredForSearchQuery;
			var showFacetsWithNoResults;
			var showFacetValuesWithNoResults;
			var closeFacetsWithNoResults;
			
			var mostRecentSearchRequest;
			var didMostRecentSearchRequestShowResults;
			
			var allFacetsList = {};
			self.activeFacetName = "";
			
			var runSearch = (afterSuccessCallback, doNotDisplayResults) => {
				var container = document.querySelector(resultsContainerSelector);
				
				//GUARD: do not search if there is no way to show the results; that would be useless load on the search API
				if (!container) {
					return;
				}
				
				var searchBox = document.querySelector(searchBoxSelector);
				var sortBySettingControl = document.querySelector(sortOrderSelector);
				var pageSizeSettingControl = parseInt(document.querySelector(pageSizeSelector));
				
				var searchTerm = searchBox ? searchBox.value : defaultSearchTerm;
				var sortBySetting = sortBySettingControl ? sortBySettingControl.value : defaultSortBy;
				var pageSizeSetting = pageSizeSettingControl ? parseInt(pageSizeSettingControl.value, 10) : defaultPageSize;
				
				search && search(container, searchTerm, sortBySetting, pageSizeSetting, afterSuccessCallback, doNotDisplayResults);
			};
			
			var search = (container, searchTerm, sortBySetting, pageSizeSetting, afterSuccessCallback, doNotDisplayResults) => {
				if (searchTerm === undefined || searchTerm === null) {
					searchTerm = "";
				}
				
				if (mockSearchAPI) {
					var numResultsToReturn = parseInt(searchTerm, 10);
					
					var newResults = [];
					
					for (var p = 1; p <= numResultsToReturn; p++) {
						newResults.push({
							title: `Item #${p}` 
							, url: `/${p}`
							, date: `${p}/4/20`
							, abstract: `This is the ${p}th item.`
							, itemType: (p % 2 === 0) ? "Webpage" : "PDF"
						});
					}
					
					displaySearchQueryResult && displaySearchQueryResult(searchTerm, sortBySetting, pageSizeSetting, { 
						values: newResults
					}, doNotDisplayResults);
				} else {
					var formattedFacets = [];
					
					var allFacetNames = new Set(Object.keys(allFacetsList));
					
					allFacetNames.forEach(curFacetName => {
						var selectedFacetValueNames = [];
						
						var facet = document.querySelector(`[name^="facet-${curFacetName}"]`);
						
						switch (facet.tagName) {
							case "INPUT":
								; (() => {
									var selectedFacetValues = Array.from(facet.nextElementSibling.querySelectorAll('input[name*="-values-"]:checked'));
									
									selectedFacetValues.forEach(curFacetValue => {
										var curFacetValueName = curFacetValue.name && curFacetValue.name.split("-values-")[1];
										
										curFacetValueName && selectedFacetValueNames.push(curFacetValueName);
									});
								})();
								
								break;
							default:
								; (() => {
									var curFacetValueElement = facet.querySelector(":checked");
									var curFacetValue = curFacetValueElement && curFacetValueElement.value;
									
									if (curFacetValue && curFacetValue !== "") {
										selectedFacetValueNames.push(curFacetValue);
									} else if (curFacetValue && curFacetValue === "") {
										var curFacet = curFacetValueElement.parentElement;
										var allFacetValueElements = curFacet.querySelector('option[value]:not[value=""]');
										
										selectedFacetValueNames = allFacetValueElements.map(curFacetValueElement => {
											var output = curFacetValueElement.value;
											
											return output;
										});
									}
								})();
							
								break;
						}
						
						var output = {
							"FieldName": curFacetName
							, "SortOrder": (curFacetName.toLowerCase() === "computeditemdateyearfield") ? "desc" : "asc"
							, "DisplayCount": 100
							, "SelectedValues": selectedFacetValueNames
							, "FieldType": defaultFacets[curFacetName].type
							, "UsesAndOperator": true
						};
						
						formattedFacets.push(output);
					});
					
					//if no facets were found, then use default facets
					if (formattedFacets.length === 0) {
						defaultFacets && Object.keys(defaultFacets).forEach(curFacet => {
							var output = {
								"FieldName": curFacet
								, "SortOrder": (curFacet.toLowerCase() === "computeditemdateyearfield") ? "desc" : "asc"
								, "DisplayCount": 100
								, "SelectedValues": []
								, "FieldType": defaultFacets[curFacet].type
								, "UsesAndOperator": true
							};
							
							formattedFacets.push(output);
						});
					}
					
					var targetPageNumber = getPageNumberFromURL && getPageNumberFromURL();
					var firstRecord = targetPageNumber && ((targetPageNumber - 1) * pageSizeSetting);
					
					var searchCriteria = JSON.stringify({
						TemplateIds: templateIDs
						, PathIds: pathIDs
						, ExcludePathIDs: excludePathIDs
						, First: firstRecord || 0
						, Facets: formattedFacets.length > 0 ? formattedFacets : defaultSelectedFacets
						, DisplayCount: pageSizeSetting
						, OrderBy: sortBySetting
						, SearchQuery: searchTerm
						, Tags: defaultTag
						, IndexName: indexName
					});
					
					if (searchCriteria !== mostRecentSearchRequest || doNotDisplayResults !== didMostRecentSearchRequestShowResults) {
						mostRecentSearchRequest = searchCriteria;
						didMostRecentSearchRequestShowResults = doNotDisplayResults;
						
						fetch(apiURL, {
							method: "POST"
							, mode: "cors"
							, headers: {
								"Content-Type": "application/json"
							}
							, body: searchCriteria
						}).then(response => {
							response.json()
							.then(result => {
								displaySearchQueryResult && displaySearchQueryResult(searchTerm, sortBySetting, pageSizeSetting, result, doNotDisplayResults)
								
								afterSuccessCallback && afterSuccessCallback(result);
							})
							.catch(error => {
								console.error(error);
								
								showNumberOfResults && showNumberOfResults(searchTerm, 0, searchAPISystemErrorMessage);
							});
						});
					}
				}
			};
			
			var displaySearchQueryResult = (searchTerm, sortBySetting, pageSizeSetting, result, doNotDisplayResults) => {
				//render search results
				var allResults = result.values;
				var allFacets = result.facets;
				var numResults = result.count;
				var numResultsPages = Math.ceil(numResults / pageSizeSetting);
				var curPageNumber = result.currentPage;
				
				/* RENDER SEARCH RESULTS */
				if (renderResult && !doNotDisplayResults) {
					var resultsContainer = document.querySelector(resultsContainerSelector);
					
					deleteAllChildNodes(resultsContainer);
					
					allResults && allResults.forEach(curResult => {
						var resultElement = renderResult(curResult);
						
						resultsContainer && resultsContainer.appendChild(resultElement);
					});
					
					onAfterResultsRendering && onAfterResultsRendering(resultsContainer);
				}
				/* end of RENDER SEARCH RESULTS */
					
				if (numResults > 0) {
					useURLSettings && setPageNumberInURL(curPageNumber);
					
					!doNotDisplayResults && showSortOrderControls && showSortOrderControls();
				} else {
					//hide all controls and labels
					hideSortOrderControls && hideSortOrderControls();
				}
				
				!doNotDisplayResults && showNumberOfResults && showNumberOfResults(searchTerm, numResults);
				
				/* RENDER FACETS */
				var facetsContainers = document.querySelectorAll(facetsContainerSelector); 
					
				if (renderFacet && allFacets && facetsContainerSelector) {
					var allFacetsWithFacetValues = {};
					
					var allFacetElements = {};
					
					var allFacetNames = new Set(Object.keys(allFacetsList));
					
					facetsContainers && facetsContainers.forEach(curFacetContainer => {
						allFacets && allFacets.forEach(curResult => {
							var curFacetName = curResult.fieldName;
							
							//GUARD: do nothing if the target facet triggered the search query
							if (self.activeFacetName === curFacetName) {
								return;
							}
							
							var curFacetData = {
								facetName: curFacetName
								, iconURL: ""
								, values: curResult.values
							};
							
							allFacetsWithFacetValues[curFacetName] = curResult.values.concat();
							
							if (allFacetNames.has(curFacetName) === true) {
								//this facet already exists, therefore we need to update its counter and its values' counter
								
								//get facet data
								var curFacet = curFacetContainer.querySelector(`[name^="facet-${curFacetName}"]`);
								
								//GUARD: do nothing if the facet element isn't found
								if (!curFacet) {
									return;
								}
								
								//update facet values
								var sumFacetValuesCounters = 0;
								
								//set all facet values to 0
								curFacetContainer.querySelectorAll(`[name^="facet-${curFacetName}-values-"]`).forEach(curFacetValueElement => {
									var curFacetValueTextElement = curFacetValueElement.nextElementSibling.querySelector("span");
									
									//GUARD: do nothing if there is no text element
									if (!curFacetValueTextElement) {
										return;
									}
									
									var curFacetValueLabelText = curFacetValueTextElement.textContent;
								
									curFacetValueLabelText = curFacetValueLabelText.substring(0, curFacetValueLabelText.indexOf("(")).trim() + " (0)";
									
									!showFacetValuesWithNoResults && curFacetValueElement.setAttribute("hidden", "");
									!showFacetValuesWithNoResults && curFacetValueTextElement.parentElement.setAttribute("hidden", "");
									
									curFacetValueTextElement.textContent = curFacetValueLabelText;
								});
								
								//set all facet values with counters greater than 0
								curFacetData.values && curFacetData.values.forEach(curFacetValue => {
									var curFacetValueElement = curFacetContainer.querySelector(`[name^="facet-${curFacetName}-values-${curFacetValue.value}"]`);
									
									//GUARD: do nothing if no facet value element was found
									if (!curFacetValueElement) {
										return;
									}
									
									var curFacetValueTextElement = curFacetValueElement.nextElementSibling.querySelector("span");
									
									var curFacetValueLabelText = curFacetValueTextElement.textContent;
									
									curFacetValueLabelText = curFacetValueLabelText.substring(0, curFacetValueLabelText.indexOf("(")).trim() + " (" + curFacetValue.count + ")";
									
									!showFacetValuesWithNoResults && curFacetValueElement.removeAttribute("hidden");
									!showFacetValuesWithNoResults && curFacetValueTextElement.parentElement.removeAttribute("hidden");
									
									curFacetValueTextElement.textContent = curFacetValueLabelText;
									
									sumFacetValuesCounters = sumFacetValuesCounters + curFacetValue.count;
								});
								
								//update the facet counter now that we have the sum of all facet-value counters
								var curFacetValuesContainer = curFacet.nextElementSibling;
								
								if (curFacetValuesContainer && curFacetValuesContainer.tagName === "DETAILS") {
									var curFacetValuesContainerHeader = curFacetValuesContainer && curFacetValuesContainer.querySelector("summary");
									
									var curFacetTextElement = curFacetValuesContainerHeader && curFacetValuesContainerHeader.querySelector("span");
									
									if (curFacetTextElement) {
										var curFacetLabelText = curFacetTextElement && curFacetTextElement.textContent || "";
										
										curFacetLabelText = curFacetLabelText.substring(0, curFacetLabelText.indexOf("(")).trim() + " (" + sumFacetValuesCounters + ")";
										
										if (sumFacetValuesCounters === 1) {
											curFacetValuesContainerHeader && curFacetValuesContainerHeader.setAttribute("aria-label", `${sumFacetValuesCounters} result for ${curFacetName}`);
										} else {
											curFacetValuesContainerHeader && curFacetValuesContainerHeader.setAttribute("aria-label", `${sumFacetValuesCounters} results for ${curFacetName}`);	
										}
										
										if (!sumFacetValuesCounters || sumFacetValuesCounters === 0) {
											closeFacetsWithNoResults && curFacetValuesContainer.hasAttribute("open") && curFacetValuesContainer.removeAttribute("open");
											
											!showFacetsWithNoResults && curFacet.setAttribute("hidden", "");
											!showFacetsWithNoResults && curFacetValuesContainer.setAttribute("hidden", "");
										} else {
											!showFacetsWithNoResults && curFacet.removeAttribute("hidden");
											!showFacetsWithNoResults && curFacetValuesContainer.removeAttribute("hidden");
										}
										
										curFacetTextElement.textContent = curFacetLabelText;
									}
								}
							} else {
								//this is a new facet, therefore we need to add it to the list of facets and render it and its values
								allFacetsList[curFacetName] = {};
								
								var newFacetElements = renderFacet(curFacetData);
								
								allFacetElements[curFacetName] = newFacetElements;
							}
						});
					});
					
					//render all new facets in a preconfigured order
					facetsContainers && facetsContainers.forEach(curFacetContainer => {
						facetOrder && facetOrder.forEach(nextFacet => {
							var facetElements = allFacetElements[nextFacet];
							
							if (curFacetContainer && facetElements && facetElements.length === 2) {
								var toggleElement = facetElements[0] && facetElements[0].cloneNode(true);
								var facetValuesContainer = facetElements[1].cloneNode(true);
								
								//check all facet-values when a facet-checkbox is clicked
								toggleElement && toggleElement.addEventListener("click", e => {
									var facet = e.target;
									
									var facetCheckedState = facet.checked;
									
									facetValuesContainer.querySelectorAll('[name*="-values-"]').forEach(curFacetValue => {
										curFacetValue.checked = facetCheckedState;
										
										//find other facet values with the same name in other and set them to the same checked start
										var allFacetContainers = document.querySelectorAll(".FacetsList");
										
										allFacetContainers && allFacetContainers.forEach(curFacetContainer => {
											curFacetContainer.querySelectorAll(`[name="${curFacetValue.name}"]`).forEach(targetFacetValue => {
												targetFacetValue.checked = facetCheckedState;
											});
										});
									});
									
									SearchEngine.activeFacetName = facet.name;
								});
								
								facetValuesContainer.tagName === "SELECT" && facetValuesContainer.addEventListener("change", e => {
									var facetElement = e.target;
									
									if (facetElement.hasAttribute("name") === true) {
										SearchEngine.activeFacetName = facetElement.getAttribute("name").replace("facet-", "");
									}
								});
								
								toggleElement && curFacetContainer.appendChild(toggleElement);
								curFacetContainer.appendChild(facetValuesContainer);
							}
						});
						
						//setup "clear all facet values" button if none already exists
						if (curFacetContainer.querySelector(".ClearAllFacets") === null) {
							var clearAllFacetsButton = document.createElement("button");
							clearAllFacetsButton.setAttribute("type", "button");
							clearAllFacetsButton.setAttribute("class", "ClearAllFacets smallViewOnlyContent");
							clearAllFacetsButton.setAttribute("style", "grid-column: span 2;");
							clearAllFacetsButton.textContent = "Reset Filters";
							
							clearAllFacetsButton.addEventListener("click", e => {
								allFacetElements && Object.keys(allFacetElements).forEach(curFacet => {
									//GUARD: we can't uncheck any checkboxes if none exists
									if (facetsContainers.length === 0) {
										return;
									}
									
									facetsContainers[0].querySelectorAll('[type="checkbox"][name^="facet-"]:not([name*="-values-"])').forEach(curFacetCheckbox => {
										curFacetCheckbox.checked = true;
										curFacetCheckbox.click();
									});
								});
							});
							
							curFacetContainer.append(clearAllFacetsButton);
						}
					});
					
					onAfterFacetRendering && onAfterFacetRendering(allFacetsWithFacetValues);
				}
				/* end of RENDER FACETS */
				
				!doNotDisplayResults && updatePagination && updatePagination(curPageNumber, pageSizeSetting, numResults, maxNumPageButtons, getPageNumberFromURL);
				
				//always stop tracking the active facet on every search query
				self.activeFacetName = "";
			};
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD:  do not allow a library to be initialized twice
				if (self.isInited === true) {
					return false;
				}
				
				//GUARD:  do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				apiURL = options.apiURL;
				indexName = options.indexName;
				pathIDs = options.pathIDs;
				excludePathIDs = options.excludePathIDs;
				templateIDs = options.templateIDs;
				defaultFacets = options.defaultFacets;
				facetOrder = options.facetOrder;
				maxNumPageButtons = options.maxNumPageButtons;
				useURLSettings = options.useURLSettings;
				forceSearchOnPageload = options.forceSearchOnPageload;
				getSearchTermFromURL = options.getSearchTermFromURL;
				setSearchTermInURL = options.setSearchTermInURL;
				getSortOrderFromURL = options.getSortOrderFromURL;
				setSortOrderInURL = options.setSortOrderInURL;
				getFacetValuesFromURL = options.getFacetValuesFromURL;
				setFacetValuesInURL = options.setFacetValuesInURL;
				getPageNumberFromURL = options.getPageNumberFromURL;
				setPageNumberInURL = options.setPageNumberInURL;
				getPageSizeFromURL = options.getPageSizeFromURL;
				setPageSizeInURL = options.setPageSizeInURL;
				buildForm = options.buildForm;
				searchBoxSelector = options.searchBoxSelector;
				sortOrderSelector = options.sortOrderSelector;
				pageSizeSelector = options.pageSizeSelector;
				getPageButtons = options.getPageButtons;
				facetsContainerSelector = options.facetsContainerSelector;
				facetValuesSelector = options.facetValuesSelector;
				resultsContainerSelector = options.resultsContainerSelector;
				defaultSearchTerm = options.defaultSearchTerm;
				defaultTag = options.defaultTag;
				defaultSelectedFacets = options.defaultSelectedFacets;
				defaultSortBy = options.defaultSortBy;
				defaultPageSize = options.defaultPageSize;
				renderResult = options.renderResult;
				onAfterResultsRendering = options.onAfterResultsRendering;
				renderFacet = options.renderFacet;
				onAfterFacetRendering = options.onAfterFacetRendering;
				showNumberOfResults = options.showNumberOfResults;
				hideNumberOfResults = options.hideNumberOfResults;
				showSortOrderControls = options.showSortOrderControls;
				hideSortOrderControls = options.hideSortOrderControls;
				updatePagination = options.updatePagination;
				searchAPISystemErrorMessage = options.searchAPISystemErrorMessage;
				mockSearchAPI = options.mockSearchAPI;
				isSearchTermRequiredForSearchQuery = options.isSearchTermRequiredForSearchQuery;
				showFacetsWithNoResults = options.showFacetsWithNoResults;
				showFacetValuesWithNoResults = options.showFacetValuesWithNoResults;
				closeFacetsWithNoResults = options.closeFacetsWithNoResults;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				runSearch && runSearch(searchResults => {
					//update UI of facet-values from URL settings
					var urlFacetValues = getFacetValuesFromURL && getFacetValuesFromURL();
					var urlFacetValuesList = urlFacetValues && urlFacetValues.split(",");
					
					var isAValidFacetValueSelected;
					
					var allFacetsWithSelectedFacetValues = new Set();
					
					urlFacetValuesList && urlFacetValuesList.forEach(curFacetValue => {
						var targetFacetValues = document.querySelectorAll(`[name*="-values-${curFacetValue}"], option[value="${curFacetValue}"]`);
						
						//select facet-values listed in the URL
						targetFacetValues && targetFacetValues.forEach(curTargetFacetValue => {
							switch (curTargetFacetValue.tagName) {
								case "INPUT":
									; (() => {
										curTargetFacetValue.checked = true;
										
										allFacetsWithSelectedFacetValues.add(curTargetFacetValue.parentElement.parentElement);
										
										isAValidFacetValueSelected = true;
									})();
									
									break;
								case "OPTION":
									; (() => {
										var targetIndex = curTargetFacetValue.index;
										
										curTargetFacetValue.parentElement.selectedIndex = targetIndex;
										
										isAValidFacetValueSelected = true;
									})();
									
									break;
							}
						});
						
						//update UI of facets based on selected facet-values
						allFacetsWithSelectedFacetValues.forEach(curFacet => {
							//open facet accordion because at least one facet-value is selected
							curFacet.tagName === "DETAILS" && curFacet.setAttribute("open", "");
							
							//check facet if all facet-values are selected
							var allUnselectedFacets = curFacet.querySelectorAll('[name*="-values-"]:not(:checked)');
							
							if (allUnselectedFacets.length === 0) {
								if (curFacet.previousElementSibling) {
									curFacet.previousElementSibling.checked = true;
								}
							}
						});
					});
					
					//if all the values in a dropdown-facet are selected in the URL, then select the show all element 
					var dropdownFacetSelector = `${facetsContainerSelector} select`;
					var allDropdownFacetElements = document.querySelectorAll(dropdownFacetSelector);
					
					allDropdownFacetElements.forEach(curFacetElement => {
						var allFacetValueElements = Array.from(curFacetElement.querySelectorAll('option[value]:not([value=""])')).map(curFacetValueElement => {
							var curFacetValue = curFacetValueElement.value;
							
							return curFacetValue;
						});
						
						if (urlFacetValuesList) {
							var isAllFacetValuesSelected;
							
							isAllFacetValuesSelected = allFacetValueElements.every(curTargetValue => {
								var output = urlFacetValuesList.includes(curTargetValue);
								
								return output;
							});
							
							if (isAllFacetValuesSelected) {
								var showAllElement = curFacetElement.querySelector('option[value=""]');
								
								if (showAllElement) {
									curFacetElement.selectedIndex = showAllElement.index;
								}
							}
						}
					});
					
					//init and populate searchbox from URL settings
					var searchTermControl = document.querySelector(searchBoxSelector);
                    
					if (searchTermControl) {
						if (!useURLSettings) {
							setSearchTermInURL && setSearchTermInURL("");
						}
						
						var searchTermURLSetting = useURLSettings && getSearchTermFromURL && getSearchTermFromURL();
						
						if (searchTermURLSetting) {
							searchTermControl.value = searchTermURLSetting;
						} else if (searchTermControl.value) {
							useURLSettings && setSearchTermInURL && setSearchTermInURL(searchTermControl.value);
						}
						
						
						searchTermControl.addEventListener("input", e => {
							var curSearchBox = e.target;
							
							useURLSettings && setSearchTermInURL && setSearchTermInURL(curSearchBox.value);
						});
						
						//set validation for searchbox
						if (isSearchTermRequiredForSearchQuery === true) {
							!searchTermControl.hasAttribute("required") && searchTermControl.setAttribute("required", "");
						}
					}
					
					var curSearchTerm = searchTermControl && searchTermControl.value || defaultSearchTerm;
					
					//run search if there is a current search term or a selected facet value
					if (isAValidFacetValueSelected || curSearchTerm || forceSearchOnPageload) {
						runSearch && runSearch();
					}
					
					/*
					//??? commenting out because I am not sure why this exists
					//??? UPDATE: this is only useful if we make it check for selected facets as well
					//ignore all URL settings if there is no search term
					if (!curSearchTerm) {
						setPageNumberInURL && setPageNumberInURL("");
						setPageSizeInURL && setPageSizeInURL("");
						setSortOrderInURL && setSortOrderInURL("");
					}
					*/
					
					//init <form>
					var formElement = buildForm && buildForm(apiURL);
				
					if (formElement) {
						document.documentElement.append(formElement);
					
						formElement.addEventListener("submit", e => {
							//always set to page 1 when changing any search parameter except pagination buttons
							setPageNumberInURL && setPageNumberInURL(1);
							runSearch && runSearch();
							
							e.preventDefault();
							return false;
						});
					}
					
					//init and populate page size control from URL settings
					var pageSizeControl = document.querySelector(pageSizeSelector);
					
					var pageSizeURLSetting = useURLSettings && getPageSizeFromURL && getPageSizeFromURL();
					
                    //NOTE: page size URL setting is only valid if the value exists in the dropdown
					var isPageSizeURLSettingValid = pageSizeURLSetting && pageSizeControl.querySelector(`[value="${pageSizeURLSetting}"]`);
					
					if (isPageSizeURLSettingValid) {
						pageSizeControl.value = pageSizeURLSetting;
					} else {
						useURLSettings && setPageSizeInURL && setPageSizeInURL(pageSizeControl.value);
					}
					
					pageSizeControl && pageSizeControl.addEventListener("change", e => {
						var curTarget = e.target;
						
						useURLSettings && setPageSizeInURL && setPageSizeInURL(curTarget.value);
						setPageNumberInURL && setPageNumberInURL(1);
						
						runSearch && runSearch();
					});
					
					//init and populate sort order control from URL settings
					var sortOrderControl = sortOrderSelector && document.querySelector(sortOrderSelector);
					
					if (sortOrderControl) {
						var sortOrderURLSetting = useURLSettings && getSortOrderFromURL && getSortOrderFromURL();
						
						var isSortOrderURLSettingValid = sortOrderControl.querySelector(`[value="${sortOrderURLSetting}"]`);
						
						if (isSortOrderURLSettingValid) {
							sortOrderControl.value = sortOrderURLSetting;
						} else {
							useURLSettings && setSortOrderInURL && setSortOrderInURL(sortOrderControl.value);
						}
						
						sortOrderControl && sortOrderControl.addEventListener("change", e => {
							var curTarget = e.target;
							
							useURLSettings && setSortOrderInURL && setSortOrderInURL(curTarget.value);
							
							runSearch && runSearch();
						});
					}
					
					//run search if there is a current search term or a selected facet value
					if (isAValidFacetValueSelected || curSearchTerm) {
						runSearch && runSearch();
					}
					
					//init facets
					var facetsContainers = document.querySelectorAll(facetsContainerSelector);
					
					facetsContainers.forEach(curFacetContainer => {
						curFacetContainer.addEventListener("click", e => {
							var target = e.target;
							
							if (target.tagName === "INPUT" && target.getAttribute("type", "checkbox")) {
								var targetName = target.hasAttribute("name") && target.getAttribute("name");
								
								if (targetName.indexOf("facet-") === 0) {
									var allSelectedFacets = [];
									
									curFacetContainer.querySelectorAll(`${facetValuesSelector}:checked`).forEach(curSelectedFacet => {
										var facetValue = curSelectedFacet.hasAttribute("name") && curSelectedFacet.getAttribute("name").split("-values-")[1];
										
										allSelectedFacets.push(facetValue);
									});
									
									//set active facet
									if (targetName.indexOf("-values-") >= 0) {
										self.activeFacetName = targetName.split("-values-")[0].replace("facet-", "");
									} else {
										self.activeFacetName = targetName;
									}
									
									useURLSettings && setPageNumberInURL && setPageNumberInURL(1);
									setFacetValuesInURL && setFacetValuesInURL(allSelectedFacets.join(","));
									runSearch && runSearch();
								}
							};
						});
						
						curFacetContainer.querySelectorAll("select").forEach(curContainer => {
							curContainer.addEventListener("change", e => {
								var target = e.target;
								
								var allSelectedFacets = new Set();
								
								curFacetContainer.querySelectorAll("option:checked").forEach((curSelectedFacetValueElement, idx) => {
									var SELECT_ALL_FACETS_CONSTANT = "";  //NOTE: must be lowercase
									
									var facetValue = curSelectedFacetValueElement.value.toLowerCase();
									
									if (facetValue && facetValue !== SELECT_ALL_FACETS_CONSTANT) {
										allSelectedFacets.add(facetValue);
									} else {
										//select all facet values in the current facet that is set to "show all"
										curSelectedFacetValueElement.parentElement.querySelectorAll('option[value]:not([value=""]').forEach(curFacetValueElement => {
											var curFacetValue = curFacetValueElement.value.toLowerCase();
											
											curFacetValue !== SELECT_ALL_FACETS_CONSTANT && allSelectedFacets.add(curFacetValue);
										});
									}
								});
								
								useURLSettings && setPageNumberInURL && setPageNumberInURL(1);
								setFacetValuesInURL && setFacetValuesInURL(Array.from(allSelectedFacets).join(","));
								runSearch && runSearch();
							});
						});
					});
					
					//init pagination buttons
					var allPageButtons = getPageButtons && getPageButtons();
					
					allPageButtons && allPageButtons.forEach(curPageButton => {
						curPageButton.addEventListener("click", e => {
							var curTarget = e.target;
							
							setPageNumberInURL && setPageNumberInURL(curTarget.value);
							
							runSearch && runSearch();
						});
					});
				}, true);
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
		
		customElements.define("document-library", class DocumentLibrary extends HTMLElement {
			static get observedAttributes() {
				return [
					"data-search-tag-name"
					, "data-search-tag-id"
					, "data-number-of-results"
					, "data-sort-by"
					, "data-more-info-label"
				];
			}
			
			#searchTagName;
			#searchTagId;
			#numTotalResults;
			#sortBy;
			#moreInfoLabel;
			
			constructor() {
				super();
			}
			
			async connectedCallback() {
				var searchResultsListContainer = document.createElement("ul");
				searchResultsListContainer.setAttribute("class", "searchResultsList menu");
				
				this.append(searchResultsListContainer);
				
				var defaultTagName = this.#searchTagName;
				var defaultTag = this.#searchTagId;
				var defaultSortBy = this.#sortBy;
				var defaultMoreInfoLabel = this.#moreInfoLabel;
				
				SearchEngine && SearchEngine.init({
					apiURL: window.buildEnvironmentSpecificURL("https://postaway.translink.ca/api/search")
					, indexName: window.codeo && window.codeo.searchIndex
					, pathIDs: [
						"{EE4E2425-8420-4676-8134-F2AF005FB1EB}"
					]
					, excludePathIDs: [
						"{1cafe3cd-ad36-4f72-9f4d-1fb243af0f73}"
					]
					, templateIDs: [
						"{79691C0E-5699-4E03-BA42-71F1477AC27F}"
					]
					, buildForm: searchFormURL => {
						var output = document.createElement("form");
						
						output.setAttribute("id", "searchAPI");
						output.setAttribute("method", "POST");
						output.setAttribute("action", searchFormURL);
						output.setAttribute("target", "_self");
						
						return output;
					}
					, resultsContainerSelector: ".searchResultsList"
					, defaultSearchTerm: undefined
					, defaultTagName: defaultTagName
					, defaultTag: defaultTag
					, defaultSelectedFacets: [
						{
							DisplayCount: 100
							, FieldName: "computedcontenttypefield"
							, FieldType: "String"
							, SelectedValues: ["PDF"]
							, SortOrder: "asc"
							, UsesAndOperator: true
						}
					]
					, defaultSortBy: defaultSortBy
					, defaultPageSize: this.#numTotalResults
					, defaultMoreInfoLabel: defaultMoreInfoLabel
					, renderResult: resultData => {
						var title = resultData.title;
						var url = resultData.url;
						
						var output = document.createElement("li");
						
						var ctaLinkElement = document.createElement("a");
						ctaLinkElement.setAttribute("href", url);
						ctaLinkElement.setAttribute("title", `Link to '${title}' PDF on this site`);
						
						ctaLinkElement.textContent = title; 
						
						output.append(ctaLinkElement);
						
						return output;
					}
					, onAfterResultsRendering: resultsContainer => {
						var seeMoreDocumentsLinkContainer = document.createElement("div");
						seeMoreDocumentsLinkContainer.setAttribute("class", "flexContainer contentItem");
						
						if (defaultTag && defaultTagName && defaultSortBy && defaultMoreInfoLabel) {
							var seeMoreDocumentsLink = document.createElement("a");
							seeMoreDocumentsLink.setAttribute("href", `/search?sort=${defaultSortBy}&facets=PDF&tags=${defaultTag}&tagNames=${defaultTagName}`);  //??? replace with URL object
							seeMoreDocumentsLink.setAttribute("title", `Link to ${defaultTagName} Related Document Library on this site`);
							seeMoreDocumentsLink.setAttribute("style", "margin-top: 1rem;");
							
							var seeMoreDocumentsLinkText = document.createElement("strong");
							seeMoreDocumentsLinkText.textContent = defaultMoreInfoLabel;
							
							seeMoreDocumentsLink.append(seeMoreDocumentsLinkText);
							
							seeMoreDocumentsLinkContainer.append(seeMoreDocumentsLink);
							
							resultsContainer.insertAdjacentElement("afterend", seeMoreDocumentsLinkContainer);
						}
					}
					, useURLSettings: false
					, forceSearchOnPageload: true
					, searchAPISystemErrorMessage: "A system error has occurred. Please try again."
				});
				
				window.FieldSync && window.FieldSync.init();
			}
			
			attributeChangedCallback(attributeName, prevValue, curValue) {
				switch (attributeName) {
					case "data-search-tag-name":
						; (() => {
							this.#searchTagName = curValue;  //??? sanitize?
						})();
						
						break;
					case "data-search-tag-id":
						; (() => {
							this.#searchTagId = [curValue];  //??? sanitize?
						})();
						
						break;
					case "data-number-of-results":
						; (() => {
							this.#numTotalResults = curValue;  //??? sanitize?
						})();
						
						break;
					case "data-sort-by":
						; (() => {
							this.#sortBy = curValue;  //??? sanitize?
						})();
						
						break;
					case "data-more-info-label":
						; (() => {
							this.#moreInfoLabel = curValue;  //??? sanitize?
						})();
						
						break;
					default:
						; (() => {
							console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
						})();
						
						break;
				}
			}
		});
	})();
</script><script type="module" class="HeadwayList">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { build12HourTimeStringFrom24HourTimeString } from "https://tlweblibs.translink.ca/DateTimeStringHelpers-1.1.0.mjs";
	import { ifTruthyValue, mergeSimpleCollections } from "/js/functionalHelpers.mjs";
	import { convertGTFSRouteLineNumberAndGTFSDestinationNameToGTFSDestinationFullName, formatGTFSItemName, parseGTFSRouteLineScheduleTrips, parseGTFSTripStoptime, parseGTFSLocationScheduleRouteLines, ifPickupGTFSTrip } from "/js/gtfsHelpers.mjs";
	import { GTFS_STATION_NUMBERS, GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER, fetchGTFSStationSchedulesForDate } from "/js/gtfsStations.mjs";
	import { fetchGTFSStopSchedulesForDate } from "/js/gtfsStops.mjs";
	
	customElements.define("headway-list", class HeadwayList extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-gtfsrouteline"
				, "data-gtfslocation"
				, "data-gtfsdirection"
				, "data-gtfsdestination"
				, "data-only-show-remaining-stop-times"
			];
		}
		
		#gtfsRouteLineNumber;
		#gtfsLocationNumber;
		#gtfsDirection;
		#gtfsDestination;
		#onlyShowRemainingStoptimes = false;
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			var gtfsLocationNumber = GTFS_PLATFORM_NUMBER_TO_STATION_NUMBER.get(this.#gtfsLocationNumber) || this.#gtfsLocationNumber;
			
			var isGTFSStop = (() => {
				if (GTFS_STATION_NUMBERS.has(gtfsLocationNumber) === false) {
					return true;
				}
				
				return false;
			})();
			
			try {
				var targetSearchDate = new Date();  //??? stop making new Date() locally and call an MJS helper instead?
				var yesterdaySearchDate = targetSearchDate && new Date(targetSearchDate);  //??? stop making new Date() locally and call an MJS helper instead?
				yesterdaySearchDate && yesterdaySearchDate.setDate(yesterdaySearchDate.getDate() - 1);
				
				//??? We should have "GTFSItems.fetchGTFSLocationSchedulesForDate" so we don't have to pick the right helper function manually
				var allGTFSLocationSchedulesForDateQueries =  [];
				
				if (isGTFSStop === true) {
					allGTFSLocationSchedulesForDateQueries = [
						fetchGTFSStopSchedulesForDate(gtfsLocationNumber, yesterdaySearchDate)
						, fetchGTFSStopSchedulesForDate(gtfsLocationNumber, targetSearchDate)
					];
				} else {
					allGTFSLocationSchedulesForDateQueries = [
						fetchGTFSStationSchedulesForDate(gtfsLocationNumber, yesterdaySearchDate)
						, fetchGTFSStationSchedulesForDate(gtfsLocationNumber, targetSearchDate)
					];
				}
				
				var allGTFSLocationSchedulesForDates = await Promise.all(allGTFSLocationSchedulesForDateQueries);
				
				//GUARD: do nothing if there are no GTFS Location schedules for the target dates
				if (getType(allGTFSLocationSchedulesForDates) !== getType.array) {
					return; //??? is this the correct response?  should we be deleting the current element?
				}
				
				if (allGTFSLocationSchedulesForDates.length === 0) {
					return; //??? is this the correct response?  should we be deleting the current element?
				}
				
				//??? move these to a global helper?
				var curDateStart = new Date();  //??? stop making new Date() locally and call an MJS helper instead?
				curDateStart.setHours(0);
				curDateStart.setMinutes(0);
				curDateStart.setSeconds(0);
				curDateStart.setMilliseconds(0);
				
				var curDateStartAsUnixTimestamp = curDateStart.getTime();
				
				var curDateEnd = new Date();  //??? stop making new Date() locally and call an MJS helper instead?
				curDateEnd.setHours(23);
				curDateEnd.setMinutes(59);
				curDateEnd.setSeconds(59);
				curDateEnd.setMilliseconds(999);
				var curDateEndAsUnixTimestamp = curDateEnd.getTime();
				
				var curDateTime = new Date();  //??? stop making new Date() locally and call an MJS helper instead?
				var curDateTimeAsUnixTimestamp = curDateTime.getTime();
				
				var atLeastOneGTFSTripHasPickup = false;
				var atLeastOneUpcomingGTFSTripHasPickup = false;
				
				//NOTE: we are not sorting 'allFormattedStoptimeElements' because we download the data in sequential order and assume that there is no overlap between the x-time of the previous day and the beginning of the current day's schedule  
				var allFormattedStoptimeElements = [];
				
				allGTFSLocationSchedulesForDates
				.flat() //NOTE: unwrap Promise.all() array
				.flatMap(parseGTFSLocationScheduleRouteLines)  
				.filter(ifTruthyValue)
				//??? remove all route schedules other than the target route and destination
				.filter(curGTFSLocationScheduleRouteLines => {
					//??? variable names could be better
				    var curGTFSRouteLineNumber = curGTFSLocationScheduleRouteLines.rs;
				    var curGTFSDirection = curGTFSLocationScheduleRouteLines.di;
				    var curGTFSDestination = formatGTFSItemName(curGTFSLocationScheduleRouteLines.hs);  //??? "formatGTFSItemName()" shouldn't be happening here...it should be happening in "fetchGTFSLocationSchedulesForDate()" or higher...
				    
				    //GUARD: do nothing if the current GTFSRouteLineNumber is missing
				    if (!curGTFSRouteLineNumber) {
				        return false;
				    }
				    
				    //GUARD: do nothing if the current GTFS direction is not whitelisted
				    if (getType(this.#gtfsDirection) !== getType.undefined && curGTFSDirection !== this.#gtfsDirection) {  //??? stop referencing this.#gtfsDirection directly and place it in a local variable instead?
				        return false;
				    }
				    
				    //GUARD: do nothing if the current GTFS destination is missing
				    if (!curGTFSDestination) {
				        return false;
				    }
				    
				    var isGTFSRouteLineNumbersMatching = this.#gtfsRouteLineNumber.toLowerCase() === curGTFSRouteLineNumber.toLowerCase();
				    
				    var isGTFSDestinationMatching = true;  //NOTE: it is set to default true because we do not fail/block if the client hasn't enabled this 'destination filter'
				    
				    if (getType(this.#gtfsDestination) !== getType.undefined) {  //??? stop referencing this.#gtfsDestination directly and place it in a local variable instead?
				        isGTFSDestinationMatching = this.#gtfsDestination.toLowerCase() === curGTFSDestination.toLowerCase();
				    }
				    
				    var isGTFSRouteLineScheduleMatching = isGTFSRouteLineNumbersMatching === true && isGTFSDestinationMatching === true;
				    
				    return isGTFSRouteLineScheduleMatching;
				})
				.flatMap(parseGTFSRouteLineScheduleTrips)
				.filter(ifPickupGTFSTrip)
				//??? remove all GTFSTrips outside of the target timerange
				.filter(curGTFSTrip => {
				    atLeastOneGTFSTripHasPickup = true;
				    
				    var gtfsDirectionName = formatGTFSItemName(curGTFSTrip.th).trim();  //??? "formatGTFSItemName()" shouldn't be happening here...it should be happening in "fetchGTFSLocationSchedulesForDate()" or higher...
				    
				    //GUARD: do nothing if there is no direction name
				    if (!gtfsDirectionName) {
				        return false;
				    }
				    
				    var gtfsTripStoptimeAs24HourTimeString = curGTFSTrip.dt;  //??? this line is duplicate multiple times, is there an opportunity to run it only once if we do a ".map()" before it's used?
				    
				    //GUARD: do nothing if there is no 24 hour time stoptime string
				    if (!gtfsTripStoptimeAs24HourTimeString) {
				        return false;
				    }
				    
				    var curStoptimeAsUnixTimestamp = curGTFSTrip.ut * 1000;
				    
				    //GUARD: do nothing if there is no stoptime unix timestamp
				    if (!curStoptimeAsUnixTimestamp) {
				        return false;
				    }
				    
				    //GUARD: do nothing if the stoptime is not today
				    if (curStoptimeAsUnixTimestamp < curDateStartAsUnixTimestamp || curStoptimeAsUnixTimestamp > curDateEndAsUnixTimestamp) {
				        return false;
				    }
				    
				    //GUARD: do nothing if the stoptime is earlier today
				    if (this.#onlyShowRemainingStoptimes === true && curStoptimeAsUnixTimestamp < curDateTimeAsUnixTimestamp) {
				        return false;
				    }
				    
				    atLeastOneUpcomingGTFSTripHasPickup = true;
				    
				    return true;
				})
				.map(parseGTFSTripStoptime)
				.filter(ifTruthyValue)
				//??? create HTML for stoptime timestring
				.map(curGTFSTripStoptime => {
				    var formattedGTFSTripStopTime = build12HourTimeStringFrom24HourTimeString(curGTFSTripStoptime);
				    
				    var gtfsTripStoptimeAs4DigitTimeString = parseInt(curGTFSTripStoptime.replace(":", ""), 10);  //??? this line is duplicate multiple times, is there an opportunity to run it only once if we do a ".map()" before it's used?
				    
				    var formatted24HourGTFSTripStoptime = `${(Math.floor(gtfsTripStoptimeAs4DigitTimeString / 100) % 24).toString().padStart(2, "0")}:${(gtfsTripStoptimeAs4DigitTimeString % 100).toString().padStart(2, "0")}`;  //??? should be added to "DateTimeStringHelpers.mjs"? a helper function to create a 0 padded 24 hour string with overflow support for the minutes column
					
					//??? everything above could be added to "DateTimeStringHelpers.mjs" and made pipelineable
				    
				    var gtfsTripStoptimeRowElement = document.createElement("tr");
				    
				    var gtfsTripStoptimeContainerElement = document.createElement("td");
				    gtfsTripStoptimeContainerElement.setAttribute("style", "text-align: right;");
				    
				    var gtfsTripStoptimeElement = document.createElement("time");
				    gtfsTripStoptimeElement.setAttribute("datetime", formatted24HourGTFSTripStoptime);
				    gtfsTripStoptimeElement.setAttribute("style", "white-space: nowrap;");
				    gtfsTripStoptimeElement.textContent = formattedGTFSTripStopTime;
				    
				    gtfsTripStoptimeContainerElement.append(gtfsTripStoptimeElement);
				    
				    var headsignElement = document.createElement("td"); //??? rename variable
					headsignElement.textContent = convertGTFSRouteLineNumberAndGTFSDestinationNameToGTFSDestinationFullName(this.#gtfsRouteLineNumber, this.#gtfsDestination); //??? shouldn't this be in a proper text element?  //??? using "this.#gtfsDestination" is a hack right?  that attribute is optional, so what happens if it's not set?
					
				    gtfsTripStoptimeRowElement.append(gtfsTripStoptimeContainerElement);
				    gtfsTripStoptimeRowElement.append(headsignElement);
				    
				    return gtfsTripStoptimeRowElement;
				})
				.reduce(mergeSimpleCollections, allFormattedStoptimeElements);
				
				if (atLeastOneGTFSTripHasPickup === false && atLeastOneUpcomingGTFSTripHasPickup === false) {
					this.remove();
					
					return;
				}
				
				var headwayListContainerElement = document.createElement("details");
				
				var headwayListContainerHeaderElement = document.createElement("summary");
				
				var headwayListContainerHeaderTextElement = document.createElement("strong");
				headwayListContainerHeaderTextElement.textContent = isGTFSStop === true ? "Today's Route Schedule" : "Today's Line Schedule";
				
				headwayListContainerHeaderElement.append(headwayListContainerHeaderTextElement);
				
				var headwayListElement = document.createElement("table");
				headwayListElement.setAttribute("tabindex", 0);
				headwayListElement.setAttribute("style", "display: block; max-height: 50vh; overflow-y: auto; table-layout: fixed;");
				
				var headwayListTableHeaderElement = document.createElement("thead");
				headwayListTableHeaderElement.setAttribute("style", "position: sticky; position: -webkit-sticky; top: 0px;");
				
				var headwayListTableHeaderRowElement = document.createElement("tr");
				
				var headwayListTimesColumnHeaderElement = document.createElement("th");
				headwayListTimesColumnHeaderElement.setAttribute("style", "width: 1%;");
				headwayListTimesColumnHeaderElement.textContent = "Times";  //??? unhardcode or is it fine?
				
				var headwayListHeadsignColumnHeaderElement = document.createElement("th");
				headwayListHeadsignColumnHeaderElement.setAttribute("style", "text-align: center;");
				headwayListHeadsignColumnHeaderElement.textContent = "Destination";  //??? unhardcode or is it fine?  //??? shouldn't this be in a proper text element?
				
				headwayListTableHeaderRowElement.append(headwayListTimesColumnHeaderElement);
				headwayListTableHeaderRowElement.append(headwayListHeadsignColumnHeaderElement);
				
				headwayListTableHeaderElement.append(headwayListTableHeaderRowElement);
				
				var headwayListTableBodyElement = document.createElement("tbody");
				
				if (getType(allFormattedStoptimeElements) === getType.array && allFormattedStoptimeElements.length > 0) {
					headwayListTableBodyElement.append(...allFormattedStoptimeElements);  //??? is it okay to use destructuring syntax?
				}
				
				if (atLeastOneUpcomingGTFSTripHasPickup === true) {
					headwayListElement.append(headwayListTableHeaderElement);
					headwayListElement.append(headwayListTableBodyElement);
					
					headwayListContainerElement.append(headwayListContainerHeaderElement);
					headwayListContainerElement.append(headwayListElement);
				} else if (atLeastOneGTFSTripHasPickup === true) {
					var noMoreRemainingTripsTextElement = document.createElement("p");
					noMoreRemainingTripsTextElement.textContent = "There are no more trips scheduled today.";  //??? remove hardcoding
					
					headwayListContainerElement.append(headwayListContainerHeaderElement);
					headwayListContainerElement.append(noMoreRemainingTripsTextElement);
				}
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(headwayListContainerElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-gtfsrouteline":
					; (() => {
						this.#gtfsRouteLineNumber = curValue;  //??? sanitize?
					})();
					
					break;
				case "data-gtfslocation":
					; (() => {
						this.#gtfsLocationNumber = curValue;  //??? sanitize?
					})();
					
					break;
				case "data-gtfsdirection":
					; (() => {
						this.#gtfsDirection = parseInt(curValue, 10);  //??? sanitize?  //??? is there a problem with the API? I thought the GTFSdirection was supposed to be a string?
					})();
					
					break;
				case "data-gtfsdestination":
					; (() => {
						this.#gtfsDestination = curValue;  //??? sanitize?
					})();
					
					break;
				case "data-only-show-remaining-stop-times":
					; (() => {
						this.#onlyShowRemainingStoptimes = curValue === "true" ? true : false;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="transitAlertsSigninPrompt">
	customElements.define("transit-alerts-signin-prompt", class TransitAlertsSigninPrompt extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			const AUTHED_MODULE_URL_STRING = "/js/authed.mjs";
			
			var authedModuleURL = AUTHED_MODULE_URL_STRING && new URL(AUTHED_MODULE_URL_STRING, document.location.origin);
			
			var { fetchIsAuthenticated } = authedModuleURL && await import(authedModuleURL);  //??? import needs to be inside try-catch
			
			var isAuthenticated = fetchIsAuthenticated && await fetchIsAuthenticated;
			
			//GUARD: do nothing if the user isn't signed into their Transit Alerts account
			if (!isAuthenticated) {
				return;
			}
			
			var signinTextElement = document.createElement("p");
			
			var signinLinkElement = document.createElement("a");
			signinLinkElement.setAttribute("href", "/alert-subscriptions");  //??? replace with URL Object Pattern
			signinLinkElement.textContent = "Manage my Alert Subscriptions";
			
			signinTextElement.append(signinLinkElement);
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			
			this.append(signinTextElement);
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) { }
	});
</script><script class="transitAlertsProfileDisplayName">
	customElements.define("transit-alerts-profile-display-name", class TransitAlertsProfileDisplayName extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-is-read-only"
				, "data-is-inheriting-font"
				, "data-prefix-text"
				, "data-suffix-text"
				, "data-target-form-id"
				, "data-target-input-name"
				, "data-show-validation-requirements"
			];
		}
		
		#isReadOnly;
		#isInheritingFont = false;
		#prefixText;
		#suffixText;
		
		#targetFormID;
		#targetInputName;
		#isShowingValidationRequirements;
		
		constructor() {
			super();
			
			this.#isReadOnly = false;
			this.#isShowingValidationRequirements = true;
		}
		
		async connectedCallback() {
			const AUTHED_MODULE_URL_STRING = "/js/authed.mjs";
			
			var authedModuleURL = AUTHED_MODULE_URL_STRING && new URL(AUTHED_MODULE_URL_STRING, document.location.origin);
			
			var { fetchAuthID } = authedModuleURL && await import(authedModuleURL);  //??? import needs to be inside try-catch
			
			var authID = fetchAuthID && await fetchAuthID;
			
			//GUARD: do nothing if there is no authID
			if (!authID) {
				return;
			}
			
			const TRANSLINK_PROFILE_MODULE_URL_STRING = "/js/translinkProfile.mjs";
			
			var translinkProfileModuleURL = TRANSLINK_PROFILE_MODULE_URL_STRING && new URL(TRANSLINK_PROFILE_MODULE_URL_STRING, document.location.origin);
			
			var { fetchUserProfile } = translinkProfileModuleURL && await import(translinkProfileModuleURL);  //??? import needs to be inside try-catch
			
			var userProfile = fetchUserProfile && authID && await fetchUserProfile(authID);
			
			var displayName = userProfile.displayName;
			
			var displayNameElement;
			
			if (this.#isReadOnly === true) {
				displayNameElement = document.createElement("span");
				
				if (displayName) {
					this.#isInheritingFont === true && displayNameElement.setAttribute("style", "font: inherit; text-overflow: ellipsis;");
					this.#isInheritingFont === false && displayNameElement.setAttribute("style", "text-overflow: ellipsis;");
					
					var formattedDisplayNameText = `${this.#prefixText || ""}${displayName}${this.#suffixText || ""}`;
					
					displayNameElement.textContent = formattedDisplayNameText;
				} else {
					this.#isInheritingFont === true && displayNameElement.setAttribute("style", "font: inherit; text-overflow: ellipsis; color: #76757A;");
					this.#isInheritingFont === false && displayNameElement.setAttribute("style", "text-overflow: ellipsis; color: #76757A;");
					displayNameElement.textContent = "e.g. John";
				}
			} else {
				displayNameElement = document.createElement("input");
				displayNameElement.setAttribute("type", "text");
				this.#targetFormID && displayNameElement.setAttribute("form", this.#targetFormID);
				this.#targetInputName && displayNameElement.setAttribute("name", this.#targetInputName);
				displayNameElement.setAttribute("placeholder", "e.g. John");
				displayNameElement.setAttribute("title", "Please enter a display name. Do not include website URLs or commas.");
				displayNameElement.setAttribute("required", "");
				displayNameElement.setAttribute("pattern", "^((?!(http|https|www|,)).)*$");
				displayNameElement.setAttribute("minlength", 2);
				displayNameElement.setAttribute("maxlength", 50);
				displayNameElement.setAttribute("autocomplete", "given-name");
				displayNameElement.setAttribute("style", "text-overflow: ellipsis;");
				
				if (displayName) {
					displayNameElement.value = displayName;
				}
			}
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			
			displayNameElement && this.append(displayNameElement);
			
			if (this.#isShowingValidationRequirements === true) {
				var requiredValidationElement = document.createElement("small");
				requiredValidationElement.setAttribute("aria-hidden", true);
				requiredValidationElement.setAttribute("style", "margin-top: 0px;");
				requiredValidationElement.textContent = "Required";
				
				var errorMessageElement = document.createElement("output");
				errorMessageElement.setAttribute("role", "alert");
				errorMessageElement.setAttribute("aria-live", "assertive");
				errorMessageElement.setAttribute("style", "margin-top: 0px;");
				errorMessageElement.setAttribute("hidden", "");
				
				this.append(requiredValidationElement);
				this.append(errorMessageElement);
			}
			
			userProfile.setDisplayName && userProfile.setDisplayName(displayNameElement, () => {
				window.location.href = "/account-settings";  //??? ugly hardcoding...
			});
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-is-read-only":
					; (() => {
						this.#isReadOnly = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-is-inheriting-font":
					; (() => {
						this.#isInheritingFont = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-prefix-text":
					; (() => {
						this.#prefixText = curValue;
					})();
					
					break;
				case "data-suffix-text":
					; (() => {
						this.#suffixText = curValue;
					})();
					
					break;
				case "data-target-form-id":
					; (() => {
						this.#targetFormID = curValue;
					})();
					
					break;
				case "data-target-input-name":
					; (() => {
						this.#targetInputName = curValue;
					})();
					
					break;
				case "data-show-validation-requirements":
					; (() => {
						this.#isShowingValidationRequirements = curValue === "false" ? false : true;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="transitAlertsProfileEmail">
	import { fetchAuthID } from "/js/authed.mjs";
	const TRANSLINK_PROFILE_MODULE_URL_STRING = "/js/translinkProfile.mjs";
	
	customElements.define("transit-alerts-profile-email", class TransitAlertsProfileEmail extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-is-read-only"
				, "data-show-validation-requirements"
			];
		}
		
		#isReadOnly;
		#isShowingValidationRequirements;
		
		constructor() {
			super();
			
			this.#isReadOnly = false;
			this.#isShowingValidationRequirements = true;
		}
		
		async connectedCallback() {
			try {
				var authID = fetchAuthID && await fetchAuthID;
				
				if (!authID) {
					return;
				}
				
				var translinkProfileModuleURL = TRANSLINK_PROFILE_MODULE_URL_STRING && new URL(TRANSLINK_PROFILE_MODULE_URL_STRING, document.location.origin);
				
				var { fetchUserProfile } = translinkProfileModuleURL && await import(translinkProfileModuleURL);
				
				var userProfile = authID && await fetchUserProfile(authID);
				
				var emailAddress = userProfile.emailAddress;
				
				var emailAddressElement;
				
				if (this.#isReadOnly === true) {
					emailAddressElement = document.createElement("span");
					
					if (emailAddress) {
						emailAddressElement.setAttribute("style", "text-overflow: ellipsis;");
						emailAddressElement.textContent = emailAddress;
					} else {
						emailAddressElement.setAttribute("style", "text-overflow: ellipsis; color: #76757A;");
						emailAddressElement.textContent = "e.g. name@example.com";
					}
				} else {
					emailAddressElement = document.createElement("input");
					emailAddressElement.setAttribute("type", "email");
					emailAddressElement.setAttribute("inputmode", "email");
					emailAddressElement.setAttribute("placeholder", "e.g. name@example.com");
					emailAddressElement.setAttribute("title", "Please enter a valid email (e.g. name@example.com)");
					emailAddressElement.setAttribute("pattern", "^[a-zA-Z0-9._%+-]{1,64}@([a-zA-Z0-9-]{1,63}\\.)+[a-zA-Z]{2,63}$");
					emailAddressElement.setAttribute("required", "");
					emailAddressElement.setAttribute("maxlength", 254);
					emailAddressElement.setAttribute("autocomplete", "email");
					emailAddressElement.setAttribute("style", "border: none; text-overflow: ellipsis;");
					
					if (emailAddress) {
						emailAddressElement.value = emailAddress;
					}
				}
				
				emailAddressElement && this.append(emailAddressElement);
				
				if (this.#isShowingValidationRequirements === true) {
					var requiredValidationElement = document.createElement("small");
					requiredValidationElement.setAttribute("aria-hidden", true);
					requiredValidationElement.textContent = "Required";
					
					this.append(requiredValidationElement);
				}
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-is-read-only":
					; (() => {
						this.#isReadOnly = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-show-validation-requirements":
					; (() => {
						this.#isShowingValidationRequirements = curValue === "false" ? false : true;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="transitAlertsProfilePhoneNumber">
	import { fetchAuthID } from "/js/authed.mjs";
	const TRANSLINK_PROFILE_MODULE_URL_STRING = "/js/translinkProfile.mjs";
	
	customElements.define("transit-alerts-profile-phone-number", class TransitAlertsProfilePhoneNumber extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-is-read-only"
				, "data-target-form-id"
				, "data-target-input-name"
			];
		}
		
		#isReadOnly;
		#targetFormID;
		#targetInputName;
		
		constructor() {
			super();
			
			this.#isReadOnly = false;
		}
		
		async connectedCallback() {
			var authID = fetchAuthID && await fetchAuthID;
			
			//GUARD: do nothing if there is no authID
			if (!authID) {
				return;
			}
			
			var translinkProfileModuleURL = TRANSLINK_PROFILE_MODULE_URL_STRING && new URL(TRANSLINK_PROFILE_MODULE_URL_STRING, document.location.origin);
			
			var { fetchUserProfile } = translinkProfileModuleURL && await import(translinkProfileModuleURL);  //??? import needs to be inside try-catch
			
			var userProfile = authID && await fetchUserProfile(authID);
			
			var phoneNumber = userProfile.phoneNumber;
			var phoneNumberElement;
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			
			if (this.#isReadOnly === true) {
				phoneNumberElement = document.createElement("span");
				
				if (phoneNumber) {
					phoneNumberElement.setAttribute("style", "text-overflow: ellipsis;");
					phoneNumberElement.textContent = NumberMasker.maskNumber(phoneNumber, "(000) 000-0000", "0", "1");
				} else {
					phoneNumberElement.setAttribute("style", "text-overflow: ellipsis; color: #76757A;");
					phoneNumberElement.textContent = "e.g. (604) 555-5555";
				}
				
				phoneNumberElement && this.append(phoneNumberElement);
			} else {
				var getVerificationCodeFormElement = document.createElement("form");
				getVerificationCodeFormElement.setAttribute("id", "getVerificationCode");
				getVerificationCodeFormElement.setAttribute("name", "getVerificationCode");
				getVerificationCodeFormElement.setAttribute("method", "GET");
				getVerificationCodeFormElement.setAttribute("action", "/transit-alerts-error");  //??? replace with URL Object Pattern
				getVerificationCodeFormElement.setAttribute("class", "useContentSpacing useForms useFormField useButton");
				
				var container = document.createElement("fieldset");
				
				var containerDescriptionElement = document.createElement("legend");
				containerDescriptionElement.setAttribute("hidden", "");
				containerDescriptionElement.textContent = "Set Phone Number for SMS Delivery";
				
				var changingPhoneNumberWarningTextElement = document.createElement("p");
				changingPhoneNumberWarningTextElement.textContent = 'Once you click "Send verification code" for your new number, your previous number will be removed. Your SMS delivery settings will be turned off.';
				
				var phoneNumberLabelElement = document.createElement("label");
				
				phoneNumberElement = document.createElement("input");
				phoneNumberElement.setAttribute("type", "tel");
				phoneNumberElement.setAttribute("inputmode", "tel");
				this.#targetFormID && phoneNumberElement.setAttribute("form", this.#targetFormID);
				phoneNumberElement.setAttribute("name", "PhoneNumber");
				phoneNumberElement.setAttribute("placeholder", "e.g. (604) 555-5555");
				phoneNumberElement.setAttribute("title", "Please enter a valid 10-digit phone number");
				phoneNumberElement.setAttribute("required", "");
				phoneNumberElement.setAttribute("pattern", "^[\\(]?[2-9]{1}\\d{2}[\\)][ ]\\d{3}[\\-]\\d{4}$");
				phoneNumberElement.setAttribute("minlength", 14);
				phoneNumberElement.setAttribute("maxlength", 14);
				phoneNumberElement.setAttribute("autocomplete", "tel-national");
				
				if (phoneNumber) {
					phoneNumberElement.value = NumberMasker.maskNumber(phoneNumber, "(000) 000-0000", "0", "1");
				}
				
				var phoneNumberRequirementsElement = document.createElement("small");
				phoneNumberRequirementsElement.setAttribute("aria-hidden", true);
				phoneNumberRequirementsElement.textContent = "Required";
				
				var phoneNumberErrorMessagingElement = document.createElement("output");
				phoneNumberErrorMessagingElement.setAttribute("role", "alert");
				phoneNumberErrorMessagingElement.setAttribute("aria-live", "assertive");
				phoneNumberErrorMessagingElement.setAttribute("hidden", "");
				
				phoneNumberLabelElement.append(document.createTextNode("Phone Number"));
				phoneNumberLabelElement.append(phoneNumberElement);
				phoneNumberLabelElement.append(phoneNumberRequirementsElement);
				phoneNumberLabelElement.append(phoneNumberErrorMessagingElement);
				
				var phoneNumberButtonsContainerElement = document.createElement("div");
				phoneNumberButtonsContainerElement.setAttribute("class", "contentItem flexContainer flexWrapper fullyJustifiedContent verticallyCenteredContent");
				phoneNumberButtonsContainerElement.setAttribute("style", "gap: 1rem;");
				
				var changePhoneNumberElement = document.createElement("button");
				changePhoneNumberElement.setAttribute("type", "reset");
				changePhoneNumberElement.setAttribute("data-type", "unstyledButton");
				changePhoneNumberElement.setAttribute("data-faux-type", "link");
				changePhoneNumberElement.setAttribute("style", "margin-top: 0px; margin-right: auto;");
				changePhoneNumberElement.setAttribute("hidden", "");
				changePhoneNumberElement.textContent = "Edit phone number";
				
				var sendVerificationCodeWrapperElement = document.createElement("div");
				sendVerificationCodeWrapperElement.setAttribute("class", "flexContainer flexColumn rightJustifiedContent useButton");
				sendVerificationCodeWrapperElement.setAttribute("style", "margin-left: auto;");
				
				var sendVerificationCodeElement = document.createElement("button");
				sendVerificationCodeElement.setAttribute("type", "submit");
				sendVerificationCodeElement.textContent = "Send verification code";
				
				sendVerificationCodeWrapperElement.append(sendVerificationCodeElement);
				
				phoneNumberButtonsContainerElement.append(changePhoneNumberElement);
				phoneNumberButtonsContainerElement.append(sendVerificationCodeWrapperElement);
				
				container.append(containerDescriptionElement);
				phoneNumber && container.append(changingPhoneNumberWarningTextElement);  //NOTE: only show this warning message when the user is changing an existing phone number
				container.append(phoneNumberLabelElement);
				container.append(phoneNumberButtonsContainerElement);
				
				getVerificationCodeFormElement.append(container);
				
				var setPhoneNumberFormElement = document.createElement("form");
				setPhoneNumberFormElement.setAttribute("id", "setPhoneNumber");
				setPhoneNumberFormElement.setAttribute("name", "setPhoneNumber");
				setPhoneNumberFormElement.setAttribute("method", "GET");
				setPhoneNumberFormElement.setAttribute("action", "/transit-alerts-error");  //??? this should be set to a real URL
				setPhoneNumberFormElement.setAttribute("class", "useContentSpacing useForms useFormField useButton");
				setPhoneNumberFormElement.setAttribute("style", "margin-top: 2.25rem;");
				setPhoneNumberFormElement.setAttribute("hidden", "");
				
				var verificationCodeContainerElement = document.createElement("fieldset");
				verificationCodeContainerElement.setAttribute("style", "display: contents;");
				
				var verificationCodeContainerDescriptionElement = document.createElement("legend");
				verificationCodeContainerDescriptionElement.setAttribute("hidden", "");
				verificationCodeContainerDescriptionElement.textContent = "Verify Phone Number for SMS Delivery";
				
				var verificationCodeDescriptionElement = document.createElement("p");
				verificationCodeDescriptionElement.textContent = "Enter your verification code to start receiving alerts on your mobile device. Your SMS delivery settings will be turned on.";
				
				var verificationCodeLabelElement = document.createElement("label");
				
				var verificationCodeElement = document.createElement("input");
				verificationCodeElement.setAttribute("type", "text");
				verificationCodeElement.setAttribute("inputmode", "numeric");
				verificationCodeElement.setAttribute("name", "smsToken");
				verificationCodeElement.setAttribute("placeholder", "e.g. 12345");
				verificationCodeElement.setAttribute("title", "You have entered in an invalid verification code. Please enter the 5-digit number (e.g. 12345) that was sent to your phone number.");
				verificationCodeElement.setAttribute("required", "");
				verificationCodeElement.setAttribute("pattern", "[0-9]{5}");
				verificationCodeElement.setAttribute("minlength", 5);
				verificationCodeElement.setAttribute("maxlength", 5);
				verificationCodeElement.setAttribute("style", "text-overflow: ellipsis;");
				
				var verificationCodeRequirementsElement = document.createElement("small");
				verificationCodeRequirementsElement.setAttribute("aria-hidden", true);
				verificationCodeRequirementsElement.textContent = "Required";
				
				var verificationCodeErrorMessagingElement = document.createElement("output");
				verificationCodeErrorMessagingElement.setAttribute("role", "alert");
				verificationCodeErrorMessagingElement.setAttribute("aria-live", "assertive");
				verificationCodeErrorMessagingElement.setAttribute("hidden", "");
				
				verificationCodeLabelElement.append(document.createTextNode("Phone Number Verification Code"));
				verificationCodeLabelElement.append(verificationCodeElement);
				verificationCodeLabelElement.append(verificationCodeRequirementsElement);
				verificationCodeLabelElement.append(verificationCodeErrorMessagingElement);
				
				var verificationCodeButtonsContainerElement = document.createElement("div");
				verificationCodeButtonsContainerElement.setAttribute("class", "contentItem flexContainer flexWrapper fullyJustifiedContent verticallyCenteredContent");
				verificationCodeButtonsContainerElement.setAttribute("style", "gap: 1rem;");
				
				var resendVerificationCodeWrapperElement = document.createElement("div");
				resendVerificationCodeWrapperElement.setAttribute("class", "useContentSpacing useButton");
				
				var resendVerificationCodeElement = sendVerificationCodeElement.cloneNode(true);
				resendVerificationCodeElement.setAttribute("form", "getVerificationCode");
				resendVerificationCodeElement.textContent = "Send new code";
				
				resendVerificationCodeWrapperElement.append(resendVerificationCodeElement);
				
				var verifyPhoneNumberElement = document.createElement("button");
				verifyPhoneNumberElement.setAttribute("type", "submit");
				verifyPhoneNumberElement.setAttribute("name", "verifyPhoneNumber");
				verifyPhoneNumberElement.setAttribute("class", "topAlignedItem");
				verifyPhoneNumberElement.setAttribute("style", "margin-top: 0px; margin-left: auto;");
				verifyPhoneNumberElement.textContent = "Verify code";
				
				verificationCodeButtonsContainerElement.append(resendVerificationCodeWrapperElement);
				verificationCodeButtonsContainerElement.append(verifyPhoneNumberElement);
				
				verificationCodeContainerElement.append(verificationCodeContainerDescriptionElement);
				verificationCodeContainerElement.append(verificationCodeDescriptionElement);
				verificationCodeContainerElement.append(verificationCodeLabelElement);
				verificationCodeContainerElement.append(verificationCodeButtonsContainerElement);
				
				setPhoneNumberFormElement.append(verificationCodeContainerElement);
				
				this.append(getVerificationCodeFormElement);
				this.append(setPhoneNumberFormElement);
				
				var repeatSendVerificationCodeDescriptionElement;
				
				sendVerificationCodeElement.addEventListener("click", e => {
					var target = e.target;
					
					var targetForm = target.form;
					
					//GUARD: do nothing if there is no parent form
					if (!targetForm) {
						return;
					}
					
					var isTargetFormValid = targetForm.checkValidity();
					
					//GUARD: do nothing if the parent form is not valid
					if (isTargetFormValid === false) {
						return;
					}
					
					//??? dedup this timer creation text
					repeatSendVerificationCodeDescriptionElement = document.createElement("small");
					
					var repeatSendVerificationCodeDescriptionCountdownElement = document.createElement("countdown-timer");
					repeatSendVerificationCodeDescriptionCountdownElement.setAttribute("data-start-time-in-seconds", 30);  //??? how to unhardcode
					
					repeatSendVerificationCodeDescriptionElement.append(document.createTextNode("Please wait "));
					repeatSendVerificationCodeDescriptionElement.append(repeatSendVerificationCodeDescriptionCountdownElement);
					repeatSendVerificationCodeDescriptionElement.append(document.createTextNode(" before sending a new verification code."));
					
					target.insertAdjacentElement("afterend", repeatSendVerificationCodeDescriptionElement);
				});
				
				resendVerificationCodeElement.addEventListener("click", e => {
					var target = e.target;
					
					//??? dedup this timer creation text
					repeatSendVerificationCodeDescriptionElement = document.createElement("small");
					
					var repeatSendVerificationCodeDescriptionCountdownElement = document.createElement("countdown-timer");
					repeatSendVerificationCodeDescriptionCountdownElement.setAttribute("data-start-time-in-seconds", 30);  //??? how to unhardcode
					
					repeatSendVerificationCodeDescriptionElement.append(document.createTextNode("Please wait "));
					repeatSendVerificationCodeDescriptionElement.append(repeatSendVerificationCodeDescriptionCountdownElement);
					repeatSendVerificationCodeDescriptionElement.append(document.createTextNode(" before resending a new code."));
					
					target.insertAdjacentElement("afterend", repeatSendVerificationCodeDescriptionElement);
				});
				
				var reenableSendVerificationCodeButtonIntervalID;
				
				getVerificationCodeFormElement.addEventListener("submit", e => {
					e.preventDefault();
					
					var targetForm = e.target;
					
					var submitterElement = window.bestEffort_GetFormSubmitter(e);
					
					var formData = new FormData(targetForm);
					
					var phoneNumberValue = formData && formData.get("PhoneNumber");
					
					//GUARD: do nothing if there is no phone number
					if (!phoneNumberValue) {
						return false;
					}
					
					//we must immediately disable the 'send verification code' buttons as soon as the 'send verification' process starts in order to prevent multiple verification codes from being sent out
					submitterElement && submitterElement.setAttribute && submitterElement.setAttribute("disabled", "");
					
					reenableSendVerificationCodeButtonIntervalID = window.setTimeout(() => {
						submitterElement && submitterElement.removeAttribute && submitterElement.removeAttribute("disabled");
						repeatSendVerificationCodeDescriptionElement && repeatSendVerificationCodeDescriptionElement.remove();
					}, 30000); //??? unhardcode somehow?
					
					userProfile.getPhoneNumberVerificationCode && userProfile.getPhoneNumberVerificationCode(phoneNumberValue, () => {
						submitterElement && submitterElement === sendVerificationCodeElement && window.clearTimeout(reenableSendVerificationCodeButtonIntervalID);
						
						phoneNumberElement.setAttribute("readonly", "");
						sendVerificationCodeElement.setAttribute("disabled", "");
						submitterElement && submitterElement === sendVerificationCodeElement && repeatSendVerificationCodeDescriptionElement && repeatSendVerificationCodeDescriptionElement.remove();
						changePhoneNumberElement.removeAttribute("hidden");
						setPhoneNumberFormElement.removeAttribute("hidden");
					});
					
					return false;
				});
				
				getVerificationCodeFormElement.addEventListener("reset", e => {
					phoneNumberElement.removeAttribute("readonly");
					sendVerificationCodeElement.removeAttribute("disabled");
					resendVerificationCodeElement.removeAttribute("disabled");
					repeatSendVerificationCodeDescriptionElement && repeatSendVerificationCodeDescriptionElement.remove();
					reenableSendVerificationCodeButtonIntervalID && window.clearTimeout(reenableSendVerificationCodeButtonIntervalID);
					changePhoneNumberElement.setAttribute("hidden", "");
					setPhoneNumberFormElement.setAttribute("hidden", "");
					
					return false;
				});
				
				setPhoneNumberFormElement.addEventListener("submit", e => {
					e.preventDefault();
					
					var formData = new FormData(setPhoneNumberFormElement);
					
					var verificationCodeValue = formData.get("smsToken");
					
					//GUARD: do nothing if there is no verification code
					if (!verificationCodeValue) {
						return false;
					}
					
					userProfile.setPhoneNumber && userProfile.setPhoneNumber(verificationCodeValue, {
						onSuccessCallback: () => {
							window.location.href = "/account-settings";  //??? ugly hardcoding...
						}
						, onHTTP400Callback: () => {
							//??? maybe make this a local reference using the current <form> instead of referencing directly?
							//GUARD: do nothing if there is no error messaging element?  //??? maybe we should try harder to recover instead of giving up?
							if (!verificationCodeErrorMessagingElement) {
								return;
							}
							
							window.deleteAllChildNodes && window.deleteAllChildNodes(verificationCodeErrorMessagingElement);
							
							var verificationCodeErrorMessagingTextElement = document.createElement("small");
							verificationCodeErrorMessagingTextElement.classList.add("verticallyCenteredContent");
							verificationCodeErrorMessagingTextElement.setAttribute("style", "display: flex; margin-top: 0.25rem;");
							verificationCodeErrorMessagingTextElement.textContent = "The verification code you've entered is incorrect. Please check your entry and try again.";
							
							verificationCodeErrorMessagingElement.append(verificationCodeErrorMessagingTextElement);
							verificationCodeErrorMessagingElement.removeAttribute("hidden");
							
							verificationCodeElement && verificationCodeElement.setAttribute("aria-invalid", true);
						}
					});
					
					return false;
				});
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-is-read-only":
					; (() => {
						this.#isReadOnly = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-target-form-id":
					; (() => {
						this.#targetFormID = curValue;
					})();
					
					break;
				case "data-target-input-name":
					; (() => {
						this.#targetInputName = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="transitAlertsDeliveryOption">
	import { fetchAuthID } from "/js/authed.mjs";
	const TRANSLINK_PROFILE_MODULE_URL_STRING = "/js/translinkProfile.mjs";
	
	customElements.define("transit-alerts-delivery-option", class TransitAlertsDeliveryOption extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-method"
				, "data-is-delete-only"
				, "data-do-not-allow-user-to-enable"
				, "data-show-infowindow-on-enable"
				, "data-show-infowindow-on-disable"
			];
		}
		
		#deliveryOption;
		#isDeleteOnly;
		#canBeEnabled;
		#onEnableInfoWindowName;
		#onDisableInfoWindowName;
		
		constructor() {
			super();
			
			this.#canBeEnabled = true;
		}
		
		async connectedCallback() {
			//GUARD: do nothing if no delivery option was set
			if (!this.#deliveryOption) {
				return;
			}
			
			try {
				var authID = fetchAuthID && await fetchAuthID;
			
				//GUARD: do nothing if there is no authID
				if (!authID) {
					return;
				}
				
				var translinkProfileModuleURL = TRANSLINK_PROFILE_MODULE_URL_STRING && new URL(TRANSLINK_PROFILE_MODULE_URL_STRING, document.location.origin);
				
				var { fetchUserProfile } = translinkProfileModuleURL && await import(translinkProfileModuleURL);
				
				var userProfile = fetchUserProfile && authID && await fetchUserProfile(authID);
				
				var deliveryOptionElement = document.createElement("button");
				deliveryOptionElement.setAttribute("type", "submit");
				
				if (this.#isDeleteOnly === true) {
					switch (this.#deliveryOption.toLowerCase()) {
						case "email":
							; (() => {
								deliveryOptionElement.textContent = "Turn off Email Alerts";
								
								//??? there is no logic here to call the DELETE API because there is currently no usecase for the logic; but it can definitely be implemented
							})();
							
							break;
						case "sms":
							; (() => {
								deliveryOptionElement.textContent = "Turn off SMS Alerts";
								
								userProfile.deletePhoneNumber(deliveryOptionElement, () => {
									//NOTE: update all SMS delivery option elements to be false
									//??? this whole section is kinda hacky
									
									var allSMSDeliveryOptionElements = document.querySelectorAll(`${this.tagName}[data-method="sms"]`);
									
									allSMSDeliveryOptionElements.forEach(curSMSDeliveryOptionElement => {
										curSMSDeliveryOptionElement.insertAdjacentElement("afterend", curSMSDeliveryOptionElement.cloneNode());
										
										curSMSDeliveryOptionElement.remove();
									});
								});
							})();
							
							break;
						default:
							; (() => {
								
							})();
							
							break;
					}
				} else {
					var isDeliveryOptionEnabled = false; 
					
					switch (this.#deliveryOption.toLowerCase()) {
						case "email":
							; (() => {
								isDeliveryOptionEnabled = userProfile.isEmailDeliveryEnabled;
								
								this.#canBeEnabled === true && userProfile.syncEmailDeliveryToInput && userProfile.syncEmailDeliveryToInput(deliveryOptionElement);
							})();
							
							break;
						case "sms":
							; (() => {
								isDeliveryOptionEnabled = userProfile.isSMSDeliveryEnabled;
								
								//NOTE: SMS delivery can never be enabled using a toggle according to business rules for security, privacy, and UX reasons.  We are intentionally not writing that logic to prevent accidental breaking of business rules.
							})();
							
							break;
						default:
							; (() => {
								
							})();
							
							break;
					}
					
					deliveryOptionElement.setAttribute("data-type", "unstyledButton");
					deliveryOptionElement.setAttribute("role", "switch");
					deliveryOptionElement.setAttribute("aria-checked", isDeliveryOptionEnabled === true ? true : false);
					deliveryOptionElement.setAttribute("style", "gap: 0.5rem;");
					
					var deliveryOptionEnabledLabelWrapperElement = document.createElement("small");
					
					var deliveryOptionEnabledLabelElement = document.createElement("strong");
					deliveryOptionEnabledLabelElement.textContent = "On";
					
					deliveryOptionEnabledLabelWrapperElement.append(deliveryOptionEnabledLabelElement);
					
					var deliveryOptionDisabledLabelElement = document.createElement("small");
					deliveryOptionDisabledLabelElement.textContent = "Off";
					
					deliveryOptionElement.append(deliveryOptionEnabledLabelWrapperElement);
					deliveryOptionElement.append(deliveryOptionDisabledLabelElement);
					
					deliveryOptionElement.addEventListener("click", e => {
						var target = e.target;
						
						var isEnabled = target.hasAttribute("aria-checked") && target.getAttribute("aria-checked") === "false" ? true : false;
						
						if (isEnabled === true && this.#onEnableInfoWindowName) {
							var onEnableInfoWindow = document.querySelector(`[data-infowindow-name="${this.#onEnableInfoWindowName}"]`);
							
							onEnableInfoWindow && onEnableInfoWindow.showModal && onEnableInfoWindow.showModal();
						}
						
						if (isEnabled === false && this.#onDisableInfoWindowName) {
							var onDisableInfoWindow = document.querySelector(`[data-infowindow-name="${this.#onDisableInfoWindowName}"]`);
							
							onDisableInfoWindow && onDisableInfoWindow.showModal && onDisableInfoWindow.showModal();
						}
						
						if (this.#canBeEnabled === false) {
							e.stopPropagation();
							e.preventDefault();
							return false;
						}
					});
				}
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(deliveryOptionElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-method":
					; (() => {
						this.#deliveryOption = curValue;
					})();
					
					break;
				case "data-is-delete-only":
					; (() => {
						this.#isDeleteOnly = curValue === "false" ? false : true;
					})();
					
					break;
				case "data-do-not-allow-user-to-enable":
					; (() => {
						this.#canBeEnabled = curValue === "true" ? false : true;
					})();
					
					break;
				case "data-show-infowindow-on-enable":
					; (() => {
						this.#onEnableInfoWindowName = curValue;
					})();
					
					break;
				case "data-show-infowindow-on-disable":
					; (() => {
						this.#onDisableInfoWindowName = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="transitAlertsDeliverySettingsSummary">
	import { fetchAuthID } from "/js/authed.mjs";
	const TRANSLINK_PROFILE_MODULE_URL_STRING = "/js/translinkProfile.mjs";
	
	customElements.define("transit-alerts-delivery-settings-summary", class TransitAlertsDeliverySettingsSummary extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			try {
				var authID = fetchAuthID && await fetchAuthID;
				
				//GUARD: do nothing if there is no authID
				if (!authID) {
					return;
				}
				
				var translinkProfileModuleURL = TRANSLINK_PROFILE_MODULE_URL_STRING && new URL(TRANSLINK_PROFILE_MODULE_URL_STRING, document.location.origin);
				
				var { fetchUserProfile } = translinkProfileModuleURL && await import(translinkProfileModuleURL);
				
				var userProfile = fetchUserProfile && authID && await fetchUserProfile(authID);
				
				var isEmailDeliveryEnabled = userProfile.isEmailDeliveryEnabled;
				var isSMSDeliveryEnabled = userProfile.isSMSDeliveryEnabled;
				
				var deliveryIconsContainer = document.createElement("div");
				isEmailDeliveryEnabled === false && isSMSDeliveryEnabled === false && deliveryIconsContainer.setAttribute("hidden", "");
				
				var emailDeliveryIconElement = document.createElement("img");
				emailDeliveryIconElement.setAttribute("role", "presentation");
				emailDeliveryIconElement.setAttribute("src", "/-/media/translink/icons/alerts/new/email.svg");  //??? replace with URL Object Pattern
				emailDeliveryIconElement.setAttribute("width", 27);
				emailDeliveryIconElement.setAttribute("height", 27);
				emailDeliveryIconElement.setAttribute("style", "width: 1.5rem; height: 1.5rem;");
				isEmailDeliveryEnabled === false && emailDeliveryIconElement.setAttribute("hidden", "");
				emailDeliveryIconElement.setAttribute("aria-hidden", true);
				
				var smsDeliveryIconElement = document.createElement("img");
				smsDeliveryIconElement.setAttribute("role", "presentation");
				smsDeliveryIconElement.setAttribute("src", "/-/media/translink/icons/alerts/new/sms.svg");  //??? replace with URL Object Pattern
				smsDeliveryIconElement.setAttribute("width", 27);
				smsDeliveryIconElement.setAttribute("height", 27);
				smsDeliveryIconElement.setAttribute("style", "width: 1.5rem; height: 1.5rem;");
				isSMSDeliveryEnabled === false && smsDeliveryIconElement.setAttribute("hidden", "");
				smsDeliveryIconElement.setAttribute("aria-hidden", true);
				
				deliveryIconsContainer.append(emailDeliveryIconElement);
				deliveryIconsContainer.append(smsDeliveryIconElement);
				
				var messageElement = document.createElement("p");
				messageElement.setAttribute("style", "flex: 1 1 0; margin: 0px; min-width: 15rem; max-width: 100%;");
				
				var deliverySettingsLinkElement = document.createElement("a");
				deliverySettingsLinkElement.setAttribute("href", "/delivery-settings");  //??? replace with URL Object Pattern
				deliverySettingsLinkElement.setAttribute("style", "margin-left: auto; margin-top: 0px; padding: 1rem 0px 1rem 1rem; background-color: var(--lightGrey);");
				deliverySettingsLinkElement.textContent = "Change Delivery Settings";
				
				if (isEmailDeliveryEnabled === true && isSMSDeliveryEnabled === true) {
					messageElement.textContent = "You are receiving alert notifications by email and text message.";
				} else if (isEmailDeliveryEnabled === true && isSMSDeliveryEnabled === false) {
					messageElement.textContent = "You are receiving alert notifications by email.";
				} else if (isEmailDeliveryEnabled === false && isSMSDeliveryEnabled === true) {
					messageElement.textContent = "You are receiving alert notifications by text message.";
				} else if (isEmailDeliveryEnabled === false && isSMSDeliveryEnabled === false) {
					messageElement.textContent = "You have no alert delivery options selected.";
				}
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(deliveryIconsContainer);
				this.append(messageElement);
				this.append(deliverySettingsLinkElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) { }
	});
</script><script type="module" class="transitAlertSubscriptions">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { build12HourTimeStringFrom24HourTimeString } from "https://tlweblibs.translink.ca/DateTimeStringHelpers-1.1.0.mjs";
	import { getURLSearchParameter } from "https://tlweblibs.translink.ca/URLHelpers-1.0.0.mjs";
	import { CRITICAL_ALERT_ROUTELINE_NUMBER, formatGTFSRouteLineNumberAsPaddedGTFSRouteLineNumber, formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber, ifLikeGTFSStationNumber, ifLikeGTFSRouteLineNumber, ifLikeGTFSItemName } from "/js/gtfsHelpers.mjs";
	import { GTFS_LINE_NUMBERS, GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME, GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE } from "/js/gtfsLines.mjs";
	import { fetchGTFSRouteLineFullNamesByNumber, fetchGTFSRouteLineFullNamesByNumberWithoutLeadingZeros, fetchGTFSRouteLineFullNamesWithoutLeadingZerosByNumber } from "/js/gtfsRouteLines.mjs";
	import { GTFS_STATION_NUMBERS_TO_STATION_NAMES, GTFS_STATION_NUMBERS_TO_STATION_NAMES_URL_SAFE, GTFS_STATION_NAMES_URL_SAFE_TO_STATION_NUMBERS } from "/js/gtfsStations.mjs";
	import { fetchSubscribableGTFSItemFullNames, fetchSubscribableGTFSItemFullNamesByNumber, fetchValidAlertSubscriptions, fetchValidAlertSubscriptionGTFSItemNumbers } from "/js/alertSubscriptions.mjs";
	
	customElements.define("transit-alert-subscriptions", class TransitAlertSubscriptions extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-include-gtfs-items"
				, "data-exclude-gtfs-items"
				, "data-exclude-stations"
				, "data-exclude-routelines"
				, "data-show-current-subscriptions"
				, "data-show-subscription-search"
				, "data-search-term-querystring-is"
				, "data-search-term"
				, "data-you-are-already-subscribed-messaging"
				, "data-show-search-submit"
				, "data-set-max-height-for-results"
				, "data-show-delete-all-alerts-button"
				, "data-preview-map-id"
				, "data-target-form-id"
				, "data-target-input-name"
			];
		}
		
		#includedGTFSItems;
		#excludedGTFSItems;
		#excludeGTFSRouteLines;
		#excludeGTFSStations;
		#showCurSubscriptions;
		#showSubscriptionSearch;
		#searchTermQueryString;
		#searchTerm;
		#alreadySubscribedMessaging = "You are already subscribed to this alert. Select another route to create a new transit alert or click on Edit to update your subscription to this route.";
		#showSearchSubmit;
		#setMaxHeightForResults = false;
		#showDeleteAllAlerts;
		#targetPreviewMapID;
		#targetFormID;
		#targetInputName;
		
		#searchResultsContainer;
		
		async #renderGTFSItemSubscription(targetGTFSItem, idx) {
			try {
				var gtfsItemNumber;
				var gtfsItemName;
				
				var gtfsItemIconURLString = window.DEFAULT_GTFS_ROUTELINE_ICON;
				
				var targetGTFSRouteLineNumber = targetGTFSItem.routeNumber;
				
				if (ifLikeGTFSRouteLineNumber(targetGTFSRouteLineNumber) === true) {
					var allGTFSRouteLineFullNamesByNumber = await fetchGTFSRouteLineFullNamesByNumber;
					
					var paddedGTFSRouteLineNumber = formatGTFSRouteLineNumberAsPaddedGTFSRouteLineNumber(targetGTFSRouteLineNumber);
					var unpaddedGTFSRouteLineNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(targetGTFSRouteLineNumber);
					var gtfsRouteLineName = allGTFSRouteLineFullNamesByNumber.has(unpaddedGTFSRouteLineNumber) && allGTFSRouteLineFullNamesByNumber.get(unpaddedGTFSRouteLineNumber) || unpaddedGTFSRouteLineNumber; 
					
					gtfsItemNumber = unpaddedGTFSRouteLineNumber;
					gtfsItemName = (window.GTFS_ROUTELINE_NUMBER_TO_NAME[unpaddedGTFSRouteLineNumber] || gtfsRouteLineName).replace(paddedGTFSRouteLineNumber, unpaddedGTFSRouteLineNumber); //??? this global is a candidate module?  currently, this cannot be replaced by "GTFSLines.GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME" because it doesn't support "000 Critical Alert"
					
					var gtfsRouteLineIconURLString = window.GTFS_ROUTELINE_NUMBER_TO_ICON[unpaddedGTFSRouteLineNumber];
					
					if (getType(gtfsRouteLineIconURLString) === getType.string) {
						gtfsItemIconURLString = gtfsRouteLineIconURLString;
					}
				}
				
				if (ifLikeGTFSStationNumber(targetGTFSItem.stationId) === true) {
					gtfsItemNumber = targetGTFSItem.stationId;
					gtfsItemName = GTFS_STATION_NUMBERS_TO_STATION_NAMES.get(gtfsItemNumber);
					gtfsItemIconURLString = "/-/media/translink/icons/alerts/skytrain.svg"; //??? should this be global //??? where is support for WCE-only and SeaBus-only stations?
				}
				
				//GUARD: do nothing if there is no GTFSItemName
				if (ifLikeGTFSItemName(gtfsItemName) === false) {
					return;
				}
				
				gtfsItemName = gtfsItemName.replaceAll("/", " / ");
				
				var isAlertSubscriptionEnabled = targetGTFSItem.isEnabled;
				
				var formattedActiveDaysOfWeekString = (() => {
					//??? this really should be an independent helper function
					var output = "";
					
					//??? where is the reduce() comment?
					var activeDaysOfWeek = targetGTFSItem.activeDaysOfWeek.isDayOfWeekEnabled.reduce((output, isCurDayActive, curDayOfWeekIndex) => {
						isCurDayActive === true && output.push(curDayOfWeekIndex);
						
						return output;
					}, []);
					
					var numActiveDaysOfWeek = activeDaysOfWeek.length; 
					
					switch (numActiveDaysOfWeek) {
						case 0:
							; (() => {
								output = "No days";
							})();
							
							break;
						case 1:
							; (() => {
								output = window.DAYS_OF_WEEK[activeDaysOfWeek[0]];
							})();
							
							break;
						case 2:
							; (() => {
								output = `${window.SHORT_DAYS_OF_WEEK[activeDaysOfWeek[0]]}, ${window.SHORT_DAYS_OF_WEEK[activeDaysOfWeek[1]]}`;
							})();
							
							break;
						case 3:
						case 4:
						case 5:
						case 6:
							; (() => {
								const CONTIGUOUS_INDEXES_STRING = ",0,1,2,3,4,5,6,";
								
								var isActiveDaysOfWeekContiguous = CONTIGUOUS_INDEXES_STRING.includes(`,${activeDaysOfWeek.join(",")},`);
								
								if (isActiveDaysOfWeekContiguous === true) {
									output = `${window.SHORT_DAYS_OF_WEEK[activeDaysOfWeek[0]]}-${window.SHORT_DAYS_OF_WEEK[activeDaysOfWeek[activeDaysOfWeek.length - 1]]}`;
								} else {
									output = `${window.SHORT_DAYS_OF_WEEK[activeDaysOfWeek[0]]}, ${window.SHORT_DAYS_OF_WEEK[activeDaysOfWeek[1]]}, ${window.SHORT_DAYS_OF_WEEK[activeDaysOfWeek[2]]}`;
									
									if (numActiveDaysOfWeek > 3) {
										output = `${output}...`;
									}
								}
							})();
							
							break;
						case 7:
							; (() => {
								output = "Every day";
							})();
							
							break;
						default:
							; (() => {
								
							})();
							
							break;
					}
					
					return output;
				})();
				
				var formattedActiveTimeOfDayString = (() => {
					var output = "Multiple times";
					
					var allStartTimes = new Set();
					var allEndTimes = new Set();
					
					targetGTFSItem.activeDaysOfWeek.isDayOfWeekEnabled.forEach((isCurDayOfWeekEnabled, idx) => {
						if (isCurDayOfWeekEnabled === true) {
							allStartTimes.add(targetGTFSItem.activeDaysOfWeek.startTimes[idx]);
							allEndTimes.add(targetGTFSItem.activeDaysOfWeek.endTimes[idx]);
						}
					});
					
					var isOnlyOneStartEndTime = allStartTimes.size === 1 && allEndTimes.size === 1 ? true : false;
					
					if (isOnlyOneStartEndTime === true) {
						var startTime = Array.from(allStartTimes)[0];
						var endTime = Array.from(allEndTimes)[0];
						
						var formattedStartTime = startTime && build12HourTimeStringFrom24HourTimeString(startTime);
						var formattedEndTime = endTime && build12HourTimeStringFrom24HourTimeString(endTime);
						
						output = `${formattedStartTime} - ${formattedEndTime}`;
					}
					
					return output;
				})();
				
				//GUARD: do nothing if the current GTFS item doesn't have a name or active days of week description
				if (!gtfsItemName || !formattedActiveDaysOfWeekString || !formattedActiveTimeOfDayString) {
					return;
				}
				
				var formattedGTFSItemNumber = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE.get(gtfsItemNumber) || GTFS_STATION_NUMBERS_TO_STATION_NAMES_URL_SAFE.get(gtfsItemNumber) || gtfsItemNumber.toUpperCase();
				
				var alertSubscriptionElement = document.createElement("article");
				alertSubscriptionElement.setAttribute("class", "contentItem flexContainer flexColumnWhenSmallViewOnlyContent flexWrapper rightJustifiedContent verticallyCenteredContent");
				idx === 0 && alertSubscriptionElement.setAttribute("style", "gap: 1rem; margin-top: 0px; border-top: 1px solid var(--lightGrey); border-bottom: 1px solid var(--lightGrey); padding-top: 1rem; padding-bottom: 1rem;");
				idx !== 0 && alertSubscriptionElement.setAttribute("style", "gap: 1rem; margin-top: 0px; border-bottom: 1px solid var(--lightGrey); padding-top: 1rem; padding-bottom: 1rem;");
				
				var gtfsItemNameWrapperElement = document.createElement("header");
				gtfsItemNameWrapperElement.setAttribute("class", "flexContainer verticallyCenteredContent");
				gtfsItemNameWrapperElement.setAttribute("style", "gap: 0.75rem; margin-right: auto;");
				
				var gtfsItemIconElement;
				
				try {
					var gtfsItemIconURL = gtfsItemIconURLString && new URL(gtfsItemIconURLString, document.location.origin);
					
					if (getType(gtfsItemIconURL) === getType.url) {
						gtfsItemIconElement = document.createElement("img");
						gtfsItemIconElement.setAttribute("alt", "");
						gtfsItemIconElement.setAttribute("src", gtfsItemIconURL);
						gtfsItemIconElement.setAttribute("width", 24);
						gtfsItemIconElement.setAttribute("height", 24);
						gtfsItemIconElement.setAttribute("style", "width: 1.3333rem; height: 1.3333rem;");
					}
				} catch (error) {
					console.error(error);
				}
				
				var gtfsItemNameLargeViewElement = document.createElement("span");
				gtfsItemNameLargeViewElement.setAttribute("class", "largeViewOnlyContent");
				gtfsItemNameLargeViewElement.setAttribute("style", "margin-top: 0px; margin-right: 2rem;");
				gtfsItemNameLargeViewElement.textContent = gtfsItemName;
				
				var gtfsItemNameSmallViewElement = document.createElement("strong");
				gtfsItemNameSmallViewElement.setAttribute("class", "smallViewOnlyContent");
				gtfsItemNameSmallViewElement.setAttribute("style", "margin-top: 0px;");
				gtfsItemNameSmallViewElement.textContent = gtfsItemName;
				
				gtfsItemIconElement && gtfsItemNameWrapperElement.append(gtfsItemIconElement);
				gtfsItemNameWrapperElement.append(gtfsItemNameLargeViewElement);
				gtfsItemNameWrapperElement.append(gtfsItemNameSmallViewElement);
				
				var alertSubscriptionDataWrapper = document.createElement("section");
				alertSubscriptionDataWrapper.setAttribute("class", "flexContainer flexColumnWhenSmallViewOnlyContent flexWrapper verticallyCenteredContent useFontColor useButton");
				alertSubscriptionDataWrapper.setAttribute("style", "gap: 1rem;");
				
				var alertActiveDaysDurationLargeViewElement = document.createElement("span");
				alertActiveDaysDurationLargeViewElement.setAttribute("class", "largeViewOnlyContent");
				alertActiveDaysDurationLargeViewElement.setAttribute("style", "margin-top: 0px; flex-grow: 0; flex-shrink: 0; width: 8rem;");
				alertActiveDaysDurationLargeViewElement.textContent = formattedActiveDaysOfWeekString;
				
				var alertActiveDaysDurationSmallViewElement = document.createElement("span");
				alertActiveDaysDurationSmallViewElement.setAttribute("class", "smallViewOnlyContent");
				alertActiveDaysDurationSmallViewElement.setAttribute("style", "margin-top: 0px; margin-bottom: -1rem; flex-grow: 0; flex-shrink: 0; width: 8rem;");
				alertActiveDaysDurationSmallViewElement.textContent = formattedActiveDaysOfWeekString;
				
				var alertActiveTimesDurationElement = document.createElement("span");
				alertActiveTimesDurationElement.setAttribute("style", "margin-top: 0px; flex-grow: 0; flex-shrink: 0; width: 9.5rem;");
				alertActiveTimesDurationElement.textContent = formattedActiveTimeOfDayString;
				
				var alertActiveWrapperElement = document.createElement("div");
				alertActiveWrapperElement.setAttribute("class", "flexContainer fullyJustifiedContent");
				
				var alertActiveElement = document.createElement("span");
				alertActiveElement.setAttribute("class", "flexContainer");
				alertActiveElement.setAttribute("style", "gap: 0.5rem; margin-top: 0px; flex-grow: 0; flex-shrink: 0; width: 4rem;");
				
				var alertActiveElementIconIndicatorElement = document.createElement("span");
				alertActiveElementIconIndicatorElement.setAttribute("style", `display: inline-block !important; align-self: center; width: 1rem; aspect-ratio: 1 / 1; border-radius: 50%; background-color: ${isAlertSubscriptionEnabled ? "#4AAA42" : "#FF0000"};`);
				
				alertActiveElement.append(alertActiveElementIconIndicatorElement);
				alertActiveElement.append(document.createTextNode(isAlertSubscriptionEnabled ? "On" : "Off"));
				
				alertActiveWrapperElement.append(alertActiveElement);
				
				var alertEditLinkSmallViewElement;
				
				try {
					const EDIT_ALERTS_PAGE_URL_STRING = "/alert-subscriptions/create-alert/edit-alert";
					var editAlertsPageURL = EDIT_ALERTS_PAGE_URL_STRING && formattedGTFSItemNumber && new URL(EDIT_ALERTS_PAGE_URL_STRING, document.location.origin); //??? need to put a try-catch around here
					editAlertsPageURL && formattedGTFSItemNumber && editAlertsPageURL.searchParams.append("for", formattedGTFSItemNumber);
					
					if (getType(editAlertsPageURL) === getType.url) {
						alertEditLinkSmallViewElement = document.createElement("a");
						alertEditLinkSmallViewElement.setAttribute("href", editAlertsPageURL);
						alertEditLinkSmallViewElement.setAttribute("class", "smallViewOnlyContent");
						alertEditLinkSmallViewElement.setAttribute("style", "margin-top: 0px;");
						alertEditLinkSmallViewElement.textContent = "Edit";
						
						alertActiveWrapperElement.append(alertEditLinkSmallViewElement);
						
						var alertEditLinkLargeViewElement = alertEditLinkSmallViewElement.cloneNode && alertEditLinkSmallViewElement.cloneNode(true);
						
						if (alertEditLinkLargeViewElement) {
							alertEditLinkLargeViewElement.setAttribute("class", "largeViewOnlyContent");
							
							alertSubscriptionDataWrapper.append(alertActiveDaysDurationLargeViewElement);
							alertSubscriptionDataWrapper.append(alertActiveDaysDurationSmallViewElement);
							alertSubscriptionDataWrapper.append(alertActiveTimesDurationElement);
							alertSubscriptionDataWrapper.append(alertActiveWrapperElement);
							alertSubscriptionDataWrapper.append(alertEditLinkLargeViewElement);
						}
					}
				} catch (error) {
					console.error(error);
				}
				
				alertSubscriptionElement.append(gtfsItemNameWrapperElement);
				alertSubscriptionElement.append(alertSubscriptionDataWrapper);
				
				return alertSubscriptionElement;
			} catch (error) {
				console.error(error);
			}
		};
		
		async #renderSearchResults() {
			var targetPreviewMapElementID = this.#targetPreviewMapID;
			var targetPreviewMapElement = targetPreviewMapElementID && document.getElementById(targetPreviewMapElementID);
			
			if (targetPreviewMapElement) {
				targetPreviewMapElement.removeAttribute("data-gtfsroutelines");
				targetPreviewMapElement.removeAttribute("data-gtfslocations");
				targetPreviewMapElement.removeAttribute("data-center-to");
				targetPreviewMapElement.removeAttribute("data-view-all-of");
				targetPreviewMapElement.setAttribute("data-zoom-level", 3);  //??? reset to zoomed out //??? this number is hardcoded, we should find the original zoom level on pageload  //??? actually, do we want this?  it could be seen as too distracting
			}
			
			try {
				var result = await Promise.all([
					fetchGTFSRouteLineFullNamesByNumber
					, fetchGTFSRouteLineFullNamesWithoutLeadingZerosByNumber
					, fetchSubscribableGTFSItemFullNames
					, fetchValidAlertSubscriptionGTFSItemNumbers
				]); //??? rename variable
				
				var allGTFSRouteLineFullNamesByNumber = result[0]
				var allGTFSRouteLineFullNamesWithoutLeadingZerosByNumber = result[1];
				var allSubscribableGTFSItemFullNames = result[2];
				var allValidAlertSubscriptionGTFSItemNumbers = result[3];
				
				var resultsContainer = this.#searchResultsContainer;
				
				//GUARD: do nothing if there is no output container;
				if (!resultsContainer || !resultsContainer.append) {
					return;
				}
				
				var alreadySubscribedWarningElements;
				
				var allSubscribableGTFSItems = allSubscribableGTFSItemFullNames && Array.from(allSubscribableGTFSItemFullNames);
				
				//??? 'allFormattedGTFSItemNames' should be provided by a module
				//??? I think 'excludeGTFSRouteLines' && 'excludeGTFSStations' have an issue where they're both excluding non routes + lines. eg critical and handyDART
				var filteredSubscribableGTFSItems = Array.from(allSubscribableGTFSItems);
				
				if (this.#excludeGTFSRouteLines === true) {
					filteredSubscribableGTFSItems = filteredSubscribableGTFSItems && filteredSubscribableGTFSItems.filter && filteredSubscribableGTFSItems.filter(curGTFSItemFullName => {
						var curGTFSItemNumber = curGTFSItemFullName.split(" ")[0];
						var unpaddedCurGTFSItemNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(curGTFSItemNumber);
						
						return allGTFSRouteLineFullNamesByNumber.has(unpaddedCurGTFSItemNumber) === false;
					});
				}
				
				if (this.#excludeGTFSStations === true) {
					filteredSubscribableGTFSItems = filteredSubscribableGTFSItems && filteredSubscribableGTFSItems.filter && filteredSubscribableGTFSItems.filter(curGTFSItemFullName => {
						var curGTFSItemNumber = curGTFSItemFullName.split(" ")[0];
						var unpaddedCurGTFSItemNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(curGTFSItemNumber);
						
						return allGTFSRouteLineFullNamesByNumber.has(unpaddedCurGTFSItemNumber) === true;
					});
				}
				
				if (this.#includedGTFSItems !== undefined) {
					filteredSubscribableGTFSItems = filteredSubscribableGTFSItems && filteredSubscribableGTFSItems.filter && filteredSubscribableGTFSItems.filter(curGTFSItemFullName => {
						var curGTFSItemNumber = curGTFSItemFullName.split(" ")[0];
						var unpaddedCurGTFSItemNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(curGTFSItemNumber);
						
						return this.#includedGTFSItems.includes(unpaddedCurGTFSItemNumber);
					});
				}
				
				if (this.#includedGTFSItems === undefined && this.#excludedGTFSItems !== undefined) {
					filteredSubscribableGTFSItems = filteredSubscribableGTFSItems && filteredSubscribableGTFSItems.filter && filteredSubscribableGTFSItems.filter(curGTFSItemFullName => {
						var curGTFSItemNumber = curGTFSItemFullName.split(" ")[0];
						var unpaddedCurGTFSItemNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(curGTFSItemNumber);
						
						return this.#excludedGTFSItems.includes(unpaddedCurGTFSItemNumber) === false;
					});
				}
				
				var allFormattedGTFSItemNames = filteredSubscribableGTFSItems && filteredSubscribableGTFSItems.map && filteredSubscribableGTFSItems.map(curGTFSItemFullName => {
					var curGTFSItemNumber = curGTFSItemFullName.split(" ")[0];
					var unpaddedCurGTFSItemNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(curGTFSItemNumber);
					
					var sanitizedCurGTFSItemFullName = curGTFSItemFullName;
					sanitizedCurGTFSItemFullName = sanitizedCurGTFSItemFullName.replaceAll(" @ ", " at ");
					sanitizedCurGTFSItemFullName = curGTFSItemNumber && unpaddedCurGTFSItemNumber && sanitizedCurGTFSItemFullName.replace(curGTFSItemNumber, unpaddedCurGTFSItemNumber);
					
					return sanitizedCurGTFSItemFullName;
				});
				
				var searchTerm = this.#searchTerm;
				
				if (searchTerm && searchTerm !== "") {
					//if the search term is for an unpadded GTFS route/line number and it directly matches it, we will show only the exact route/line
					//??? hardcoded way to prevent searching for '000' returning the 'critical alerts' result; we need to find a way to handle this without hardcoding it; maybe remove it from 'routeLinesByNumberWithoutLeadingZeros'?
					var foundGTFSRouteLine = searchTerm.startsWith("0") === true && searchTerm !== CRITICAL_ALERT_ROUTELINE_NUMBER && allGTFSRouteLineFullNamesWithoutLeadingZerosByNumber.get(searchTerm);
					
					if (foundGTFSRouteLine) {
						allFormattedGTFSItemNames = [foundGTFSRouteLine];  //??? make this return the unpadded version
					} else {
						allFormattedGTFSItemNames = allFormattedGTFSItemNames && allFormattedGTFSItemNames.filter && allFormattedGTFSItemNames.filter(curGTFSItemFullName => {
							var searchCandidate = curGTFSItemFullName;
							
							window.GTFS_NON_SEARCHABLE_TERMS.forEach(curNonSearchableTerm => {
								searchCandidate = searchCandidate.replaceAll(curNonSearchableTerm, "");
								searchCandidate = searchCandidate.trim();
							});
							
							if (searchCandidate.toLowerCase().includes(searchTerm.toLowerCase()) === true) {  //??? replace with global helper
								return true;
							} else {
								return false;
							}
						});
					}
				}
				
				var allGTFSItemInputElements = allFormattedGTFSItemNames && allFormattedGTFSItemNames.map((curGTFSItemUnpaddedFullName, idx) => {
					//??? why are we doing GTFSItemName parsing/formatting here when we have "GTFSHelpers.mjs"???
					var curGTFSItemNumber = curGTFSItemUnpaddedFullName.split(" ")[0];
					
					var formattedCurGTFSItemUnpaddedFullName = curGTFSItemUnpaddedFullName && curGTFSItemUnpaddedFullName.replaceAll("/", " / ");
					
					if (curGTFSItemNumber.length > 3 || GTFS_LINE_NUMBERS.has(curGTFSItemNumber) === true || curGTFSItemNumber === CRITICAL_ALERT_ROUTELINE_NUMBER) {
						formattedCurGTFSItemUnpaddedFullName = formattedCurGTFSItemUnpaddedFullName.replace(`${curGTFSItemNumber} `, "");
					}
					
					var formattedCurGTFSItemNumber = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME_URL_SAFE.get(curGTFSItemNumber) || GTFS_STATION_NUMBERS_TO_STATION_NAMES_URL_SAFE.get(curGTFSItemNumber) || curGTFSItemNumber.toUpperCase();
					
					var curGTFSItemElementWrapper = document.createElement("label");
					idx === 0 && curGTFSItemElementWrapper.setAttribute("style", "display: flex;");
					idx !== 0 && curGTFSItemElementWrapper.setAttribute("style", "display: flex; margin-top: 0.5rem;");
					
					var curGTFSItemElement = document.createElement("input");
					curGTFSItemElement.setAttribute("type", "radio");
					this.#targetFormID && curGTFSItemElement.setAttribute("form", this.#targetFormID);
					this.#targetInputName && curGTFSItemElement.setAttribute("name", this.#targetInputName);
					curGTFSItemElement.setAttribute("value", formattedCurGTFSItemNumber);
					curGTFSItemElement.setAttribute("style", "flex-shrink: 0; position: relative; top: 2px;");
					
					var curGTFSItemElementWrapperTextElement = document.createElement("span");
					curGTFSItemElementWrapperTextElement.setAttribute("data-role", "p");
					curGTFSItemElementWrapperTextElement.textContent = formattedCurGTFSItemUnpaddedFullName;
					
					curGTFSItemElementWrapper.append(curGTFSItemElement);
					curGTFSItemElementWrapper.append(curGTFSItemElementWrapperTextElement);
					
					curGTFSItemElement.addEventListener("click", e => {
						var target = e.target;
						var targetGTFSItemNumber = target.hasAttribute("value") && target.getAttribute("value");
						
						//GUARD: do nothing if there is no target GTFS item number
						if (!targetGTFSItemNumber) {
							return;
						}
						
						targetGTFSItemNumber = window.GTFS_LINE_NAMES_URL_SAFE_TO_LINE_NUMBERS[targetGTFSItemNumber] || GTFS_STATION_NAMES_URL_SAFE_TO_STATION_NUMBERS.get(targetGTFSItemNumber) || targetGTFSItemNumber.toUpperCase(); //??? cannot migrate "window.GTFS_LINE_NAMES_URL_SAFE_TO_LINE_NUMBERS" to "GTFSLines.mjs" because it has "000 Critical Alerts" //??? shouldn't this just be one giant collection instead of separate ones?
						
						//??? this is terribly inefficient to keep doing this search for form submit buttons on every radio button click
						var targetForm = curGTFSItemElement.form;
						var allTargetFormSubmitButtons = Array.from(targetForm.elements).filter(curElement => {
							return curElement.matches('[type="submit"]');
						});
						
						var foundAlreadySubscribedWarningElements = targetForm.elements["AlreadySubscribedErrorMessage"];
						
						alreadySubscribedWarningElements = foundAlreadySubscribedWarningElements.length > 0 ? Array.from(foundAlreadySubscribedWarningElements) : [foundAlreadySubscribedWarningElements];  //NOTE: if 'form.elements' returns multiple elements, we can wrap that into an Array object.  However, if 'form.elements' only returns a single element, then Array.from creates an empty array  //??? ugly hardcoding
						
						var isSubscribed = allValidAlertSubscriptionGTFSItemNumbers.includes(targetGTFSItemNumber);
						
						allTargetFormSubmitButtons.forEach(curSubmitButton => {
							curSubmitButton.removeAttribute("disabled");
							
							if (isSubscribed === true) {
								curSubmitButton.textContent = "Edit";  //??? ugly hardcoding  //??? replace with attribute
								
								alreadySubscribedWarningElements.forEach(curAlreadySubscribedWarningElement => {
									curAlreadySubscribedWarningElement.removeAttribute("hidden");
								});
							} else {
								curSubmitButton.textContent = "Next";  //??? ugly hardcoding  //??? replace with attribute
								
								alreadySubscribedWarningElements.forEach(curAlreadySubscribedWarningElement => {
									curAlreadySubscribedWarningElement.setAttribute("hidden", "");
								});
							}
						});
						
						if (targetPreviewMapElement) {
							switch (targetGTFSItemNumber.length) {
								case 1:
								case 2:
								case 3:  //NOTE: is a GTFSRouteLine //??? replace with enum in gtfs helper?
									; (() => {
										targetPreviewMapElement.removeAttribute("data-gtfslocations");
										targetPreviewMapElement.setAttribute("data-gtfsroutelines", targetGTFSItemNumber);
										targetPreviewMapElement.setAttribute("data-view-all-of", targetGTFSItemNumber);
									})();
									
									break;
								case 5:  //NOTE: is a GTFSLocation //??? replace with enum in gtfs helper?
									; (() => {
										targetPreviewMapElement.removeAttribute("data-gtfsroutelines");
										targetPreviewMapElement.setAttribute("data-gtfslocations", targetGTFSItemNumber);
										targetPreviewMapElement.setAttribute("data-center-to", targetGTFSItemNumber);
										targetPreviewMapElement.setAttribute("data-zoom-level", 12);
									})();
									
									break;
								default:
									; (() => {
										
									})();
									
									break;
							}
						}
					});
					
					return curGTFSItemElementWrapper;
				});
				
				allGTFSItemInputElements = allGTFSItemInputElements.filter(x => x); //NOTE: "filter(x => x)" to remove empty strings and other falsey values
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(resultsContainer);  //??? is this whole rerender the entire list a bad take?  we have to delete, create, add, and addeventlisteners for every search; seems like it might be better to just hide elements instead?
				
				if (this.#includedGTFSItems === undefined && this.#excludedGTFSItems === undefined) {
					//show 'did you mean?' prompt
					if (searchTerm && searchTerm !== "") {
						var alternateSuggestionsErrorMessageContainer = document.createElement("output");
						alternateSuggestionsErrorMessageContainer.setAttribute("class", "contentItem useContentSpacing");
						alternateSuggestionsErrorMessageContainer.setAttribute("style", "padding: 1rem; background-color: var(--lightGrey);");
						
						var alternateSuggestionsErrorMessageTextElement = document.createElement("p");
						
						alternateSuggestionsErrorMessageContainer.append(alternateSuggestionsErrorMessageTextElement);
						
						//??? if "data-target-form-id" doesn't actually lead to an element, we should not render this or at least not render input-value-syncer as a button?
						
						var searchableTerm = document.createElement("input-value-syncer");
						searchableTerm.setAttribute("role", "button");
						searchableTerm.setAttribute("data-faux-type", "link");
						searchableTerm.setAttribute("data-target-form-id", `${this.#targetFormID}Search`);  //??? is this a hardcoding that needs to be removed?
						searchableTerm.setAttribute("data-target-input-name", "searchFor");
						searchableTerm.setAttribute("aria-label", "search for");
						searchableTerm.setAttribute("style", "font: inherit;");
						
						var canadaLineSearchableTerm = searchableTerm.cloneNode(true);
						canadaLineSearchableTerm.textContent = "Canada Line";
						
						var expoLineSearchableTerm = searchableTerm.cloneNode(true);
						expoLineSearchableTerm.textContent = "Expo Line";
						
						var millenniumLineSearchableTerm = searchableTerm.cloneNode(true);
						millenniumLineSearchableTerm.textContent = "Millennium Line";
						
						var wceSearchableTerm = searchableTerm.cloneNode(true);
						wceSearchableTerm.textContent = "West Coast Express";
						
						var seaBusSearchableTerm = searchableTerm.cloneNode(true);
						seaBusSearchableTerm.textContent = "SeaBus";
						
						var route250SearchableTerm = searchableTerm.cloneNode(true);
						route250SearchableTerm.textContent = "250";
						
						var formattedSearchTerm = searchTerm.toLowerCase().trim();
						
						switch (formattedSearchTerm) {
							case "sky":
							case "train":
							case "skytrain":
							case "sky train":
								; (() => {
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode("The SkyTrain system is comprised of three lines, the "));
									alternateSuggestionsErrorMessageTextElement.append(canadaLineSearchableTerm);
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode(", "));
									alternateSuggestionsErrorMessageTextElement.append(expoLineSearchableTerm);
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode(" and "));
									alternateSuggestionsErrorMessageTextElement.append(millenniumLineSearchableTerm);
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode("."));
									
									resultsContainer.append(alternateSuggestionsErrorMessageContainer);
								})();
								
								break;
							case "evergreen":
							case "evergreen line":
							case "evergreen extension":
								; (() => {
									var evergreenExtensionTextElement = document.createElement("strong");
									evergreenExtensionTextElement.textContent = "Evergreen extension";
									
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode("The "));
									alternateSuggestionsErrorMessageTextElement.append(millenniumLineSearchableTerm);
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode(" includes the "));
									alternateSuggestionsErrorMessageTextElement.append(evergreenExtensionTextElement);
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode(", operating between VCC-Clark station and Lafarge Lake-Douglas station."));
									
									resultsContainer.append(alternateSuggestionsErrorMessageContainer);
								})();
								
								break;
							case "wce":
								; (() => {
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode("The "));
									alternateSuggestionsErrorMessageTextElement.append(wceSearchableTerm);
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode(" is our commuter rail service that travels between Downtown Vancouver and Mission City."));
									
									resultsContainer.append(alternateSuggestionsErrorMessageContainer);
								})();
								
								break;
							case "sea bus":
								; (() => {
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode("The "));
									alternateSuggestionsErrorMessageTextElement.append(seaBusSearchableTerm);
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode(" is our passenger ferry that crosses the Burrard inlet, connecting Downtown Vancouver to North Vancouver between Waterfront Station and Lonsdale Quay."));
									
									resultsContainer.append(alternateSuggestionsErrorMessageContainer);
								})();
								
								break;
							case "250a":
								; (() => {
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode("The 250A Dundarave to 25th & Main can be found under the route "));
									alternateSuggestionsErrorMessageTextElement.append(route250SearchableTerm);
									alternateSuggestionsErrorMessageTextElement.append(document.createTextNode("."));
									
									resultsContainer.append(alternateSuggestionsErrorMessageContainer);
								})();
								
								break;
							default:
								; (() => {
									
								})();
								
								break;
						}
					}
					
					var resultsContainerHeaderTextElement = document.createElement("strong");
					resultsContainerHeaderTextElement.textContent = "From your search:";
					
					resultsContainer.append(resultsContainerHeaderTextElement);
				}
				
				var subscriptionSearchFormElement = document.getElementById(this.#targetFormID);
				var allSubscriptionSearchFormSubmitButtons = Array.from(subscriptionSearchFormElement.elements).filter(curSubscriptionSearchFormInputElement => {
					return curSubscriptionSearchFormInputElement.matches('[type="submit"]');
				});
				
				alreadySubscribedWarningElements && alreadySubscribedWarningElements.forEach(curAlreadySubscribedWarningElement => {
					curAlreadySubscribedWarningElement.setAttribute("hidden", "");
				});
				
				allSubscriptionSearchFormSubmitButtons.forEach(curSubscriptionSearchSubmitButton => {
					curSubscriptionSearchSubmitButton.setAttribute("disabled", "");
					curSubscriptionSearchSubmitButton.textContent = "Next";
				});
				
				if (allGTFSItemInputElements && allGTFSItemInputElements.length > 0) {
					allGTFSItemInputElements.forEach(curGTFSItemInputElement => {
						resultsContainer.append(curGTFSItemInputElement);
					});
				} else {
					var noResultsFoundMessageElement = document.createElement("p");
					
					var noResultsFoundMessageTextWrapperElement = document.createElement("em");
					
					var noResultsFoundMessageTextElement = document.createElement("input-value-syncer");
					noResultsFoundMessageTextElement.setAttribute("data-target-form-id", `${this.#targetFormID}Search`);  //??? need to undo this hardcoding  //??? this is a very weird name, not sure if it makes sense or follows conventions
					noResultsFoundMessageTextElement.setAttribute("data-target-input-name", "searchFor");  //??? need to undo this hardcoding
					noResultsFoundMessageTextElement.setAttribute("aria-label", "search for");  //??? this aria-label is hardcoded for <input-value-syncer>s for search boxes; need to replace this aria-label with something more generic or make it an attribute-setting
					noResultsFoundMessageTextElement.setAttribute("style", "display: contents; font: inherit;");
					
					noResultsFoundMessageTextWrapperElement.append(noResultsFoundMessageTextElement);
					
					noResultsFoundMessageElement.append(document.createTextNode("No results found for "));
					noResultsFoundMessageElement.append(noResultsFoundMessageTextWrapperElement);
					
					resultsContainer.append(noResultsFoundMessageElement);
				}
			} catch (error) {
				console.error(error);
			}
		};
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			try {
				var result = await Promise.all([
					fetchSubscribableGTFSItemFullNamesByNumber
					, fetchValidAlertSubscriptions
				]); //??? rename variable
				
				var allSubscribableGTFSItemFullNamesByNumber = result[0];
				var allValidAlertSubscriptions = result[1];
				
				var deleteAllAlertsButtonWrapper;
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				if (this.#showDeleteAllAlerts === true) {
					deleteAllAlertsButtonWrapper = document.createElement("div");
					deleteAllAlertsButtonWrapper.setAttribute("class", "contentItem flexContainer rightJustifiedContent");
					deleteAllAlertsButtonWrapper.setAttribute("style", "order: 1; margin-top: 2.25rem;");
					
					var deleteAllAlertsButton = document.createElement("button");
					deleteAllAlertsButton.setAttribute("type", "button");
					deleteAllAlertsButton.setAttribute("data-type", "unstyledButton");
					deleteAllAlertsButton.setAttribute("data-faux-type", "link");
					deleteAllAlertsButton.setAttribute("data-infowindow", "Confirm Delete All Alerts");
					deleteAllAlertsButton.setAttribute("data-no-infowindow-icon", "");
					deleteAllAlertsButton.setAttribute("style", "margin-top: 0px;");
					deleteAllAlertsButton.textContent = "Delete all alerts";
					
					deleteAllAlertsButtonWrapper.append(deleteAllAlertsButton);
				}
				
				if (this.#showCurSubscriptions === true) {
					var curSubscriptionContainerElement = document.createElement("div");
					
					this.append(curSubscriptionContainerElement);
					
					var numRenderAlertSubscriptionElements = 0;
					
					allValidAlertSubscriptions.forEach(async curGTFSItem => {
						try {
							var curGTFSStationNumber = curGTFSItem.stationId;
							var curGTFSRouteLineNumber = curGTFSItem.routeNumber;
							var curPaddedGTFSItemNumber;
							
							if (ifLikeGTFSRouteLineNumber(curGTFSRouteLineNumber) === true) {
								curPaddedGTFSItemNumber = formatGTFSRouteLineNumberAsPaddedGTFSRouteLineNumber(curGTFSRouteLineNumber);
							}
							
							//GUARD: do nothing if the subscribed-alert is not a subscribable GTFS item
							//??? 'allSubscribableGTFSItemFullNamesByNumber' should be have both padded and unpadded numbers or another version of it should be exported
							if (allSubscribableGTFSItemFullNamesByNumber.has(curGTFSStationNumber) === false && allSubscribableGTFSItemFullNamesByNumber.has(curPaddedGTFSItemNumber) === false) {
								return;
							}
							
							numRenderAlertSubscriptionElements = numRenderAlertSubscriptionElements + 1;
							
							var newAlertSubscriptionElement = await this.#renderGTFSItemSubscription(curGTFSItem, numRenderAlertSubscriptionElements);
							
							newAlertSubscriptionElement && curSubscriptionContainerElement.append(newAlertSubscriptionElement);
						} catch (error) {
							console.error(error);
						}
					}); //??? LOOK HERE FOR SO MANY PROBLEMS
					
					//??? BUG: this is rendering first because everything else is async; need to add this to the rendering queue at the very end
					//??? we are currently making this appear at the end using flex-ordering, but that's improper and an accessibility issue
					allValidAlertSubscriptions.length > 0 && this.#showDeleteAllAlerts === true && deleteAllAlertsButtonWrapper !== undefined && this.append(deleteAllAlertsButtonWrapper);
				}
				
				if (this.#showSubscriptionSearch === true && this.#targetFormID) {
					var subscriptionSearchForm = document.getElementById(this.#targetFormID);
					
					if (!subscriptionSearchForm) {
						try {
							const EDIT_ALERTS_PAGE_URL_STRING = "/alert-subscriptions/create-alert/edit-alert";
							var editAlertsPageURL = EDIT_ALERTS_PAGE_URL_STRING && new URL(EDIT_ALERTS_PAGE_URL_STRING, document.location.origin);
							
							if (getType(editAlertsPageURL) === getType.url) {
								subscriptionSearchForm = document.createElement("form");
								subscriptionSearchForm.setAttribute("id", this.#targetFormID);
								subscriptionSearchForm.setAttribute("name", this.#targetFormID);
								subscriptionSearchForm.setAttribute("method", "GET");
								subscriptionSearchForm.setAttribute("action", editAlertsPageURL); 
								
								document.body.append(subscriptionSearchForm);
							}
						} catch (error) {
							console.error(error);
						}
					}
					
					var subscriptionSearchBoxFormName = `${this.#targetFormID}Search`;
					var subscriptionSearchBoxForm = document.getElementById(subscriptionSearchBoxFormName);
					
					if (!subscriptionSearchBoxForm) {
						try {
							const ALERT_SUBSCRIPTIONS_PAGE_URL_STRING = "/alert-subscriptions";
							var alertSubscriptionsPageURL = ALERT_SUBSCRIPTIONS_PAGE_URL_STRING && new URL(ALERT_SUBSCRIPTIONS_PAGE_URL_STRING, document.location.origin);
							
							if (getType(alertSubscriptionsPageURL) === getType.url) {
								subscriptionSearchBoxForm = document.createElement("form");
								subscriptionSearchBoxForm.setAttribute("id", subscriptionSearchBoxFormName);
								subscriptionSearchBoxForm.setAttribute("name", subscriptionSearchBoxFormName);
								subscriptionSearchBoxForm.setAttribute("method", "GET");
								subscriptionSearchBoxForm.setAttribute("action", alertSubscriptionsPageURL);
								
								document.body.append(subscriptionSearchBoxForm);
							}
						} catch (error) {
							console.error(error);
						}
					}
					
					if (this.#includedGTFSItems === undefined && this.#excludedGTFSItems === undefined) {
						var subscriptionSearchBoxLabelElement = document.createElement("label");
						subscriptionSearchBoxLabelElement.setAttribute("class", "maxWidth");
						subscriptionSearchBoxLabelElement.textContent = "Search by transit mode, route # or name";
						
						var subscriptionSearchBoxWrapper = document.createElement("div");
						subscriptionSearchBoxWrapper.setAttribute("class", "flexContainer useButton useFormField");
						
						var subscriptionSearchBoxElement = document.createElement("input");
						subscriptionSearchBoxElement.setAttribute("type", "search");
						subscriptionSearchBoxElement.setAttribute("form", subscriptionSearchBoxFormName);  //??? name is weird, will likely change in the future
						subscriptionSearchBoxElement.setAttribute("name", "searchFor");  //??? name is weird, will likely change in the future
						subscriptionSearchBoxElement.setAttribute("list", "SubscribableGTFSItems");
						subscriptionSearchBoxElement.setAttribute("placeholder", "e.g. 123, N9, or R1");
						subscriptionSearchBoxElement.setAttribute("style", "flex: 1;");
						subscriptionSearchBoxElement.setAttribute("enterkeyhint", "search");
						
						var subscriptionSearchButtonElement = document.createElement("button");
						subscriptionSearchButtonElement.setAttribute("type", "submit");
						subscriptionSearchButtonElement.setAttribute("form", subscriptionSearchBoxFormName);  //??? name is weird, will likely change in the future
						subscriptionSearchButtonElement.setAttribute("class", "flexContainer");
						subscriptionSearchButtonElement.setAttribute("style", "gap: 0.5rem; margin-left: 1rem; margin-top: 0px;");
						
						var subscriptionSearchButtonIconElement;
						
						try {
							const LIGHT_MAGNIFYING_GLASS_ICON_URL_STRING = "/-/media/translink/icons/shared/magnifier_white.svg";
							var lightMagnifyingGlassIconURL = LIGHT_MAGNIFYING_GLASS_ICON_URL_STRING && new URL(LIGHT_MAGNIFYING_GLASS_ICON_URL_STRING, document.location.origin);
							
							if (getType(lightMagnifyingGlassIconURL) === getType.url) {
								subscriptionSearchButtonIconElement = document.createElement("img");
								subscriptionSearchButtonIconElement.setAttribute("alt", "");
								subscriptionSearchButtonIconElement.setAttribute("src", lightMagnifyingGlassIconURL);
								subscriptionSearchButtonIconElement.setAttribute("width", 27);
								subscriptionSearchButtonIconElement.setAttribute("height", 27);
							}
						} catch (error) {
							console.error(error);
						}
						
						var subscriptionSearchButtonTextElement = document.createElement("span");
						subscriptionSearchButtonTextElement.setAttribute("class", "largeViewOnlyContent");
						subscriptionSearchButtonTextElement.textContent = "Search";
						
						subscriptionSearchButtonIconElement && subscriptionSearchButtonElement.append(subscriptionSearchButtonIconElement);
						subscriptionSearchButtonElement.append(subscriptionSearchButtonTextElement);
						
						subscriptionSearchBoxWrapper.append(subscriptionSearchBoxElement);
						subscriptionSearchBoxWrapper.append(subscriptionSearchButtonElement);
						subscriptionSearchBoxLabelElement.append(subscriptionSearchBoxWrapper);
					}
					
					var subscriptionSearchResultsContainerElement = document.createElement("div");
					subscriptionSearchResultsContainerElement.setAttribute("class", "contentItem flexContainer flexColumn leftJustifiedContent useContentSpacing useFormField");
					this.#setMaxHeightForResults === true && subscriptionSearchResultsContainerElement.setAttribute("style", "max-height: 50vh; overflow-y: auto;");
					
					this.#searchResultsContainer = subscriptionSearchResultsContainerElement;
					
					var createAlertButtonElementWrapper = document.createElement("div");  //??? 'createAlertButtonElementWrapper' is a bad name because it wraps more than just the alert button
					createAlertButtonElementWrapper.setAttribute("class", "contentItem flexContainer flexColumn rightJustifiedContent verticallyCenteredContent useButton");
					createAlertButtonElementWrapper.setAttribute("style", "margin-top: 3.5rem; gap: 1rem;");
					this.#showSearchSubmit === false && createAlertButtonElementWrapper.setAttribute("hidden", "");
					
					var alreadySubscribedWarningElement = document.createElement("output");
					alreadySubscribedWarningElement.setAttribute("form", this.#targetFormID);
					alreadySubscribedWarningElement.setAttribute("name", "AlreadySubscribedErrorMessage");  //??? ugly hardcoding
					alreadySubscribedWarningElement.setAttribute("class", "contentItem useContentSpacing useFontColor");
					alreadySubscribedWarningElement.setAttribute("style", "padding: 1rem; background-color: var(--lightGrey);");
					alreadySubscribedWarningElement.setAttribute("hidden", "");
					
					var alreadySubscribedWarningTextElement = document.createElement("p");
					alreadySubscribedWarningTextElement.textContent = this.#alreadySubscribedMessaging;
					
					alreadySubscribedWarningElement.append(alreadySubscribedWarningTextElement);
					
					var createAlertButtonElement = document.createElement("button");
					createAlertButtonElement.setAttribute("type", "submit");
					createAlertButtonElement.setAttribute("form", this.#targetFormID);
					createAlertButtonElement.setAttribute("style", "margin-top: 0px;");
					createAlertButtonElement.setAttribute("disabled", "");
					createAlertButtonElement.textContent = "Next";
					
					createAlertButtonElementWrapper.append(alreadySubscribedWarningElement);
					createAlertButtonElementWrapper.append(createAlertButtonElement);
					
					this.#includedGTFSItems === undefined && this.#excludedGTFSItems === undefined && this.append(subscriptionSearchBoxLabelElement);
					this.append(subscriptionSearchResultsContainerElement);  //??? is this the correct place for this line of code?
					this.append(createAlertButtonElementWrapper);
					
					if (this.#includedGTFSItems === undefined && this.#excludedGTFSItems === undefined) {
						//??? this callback is too hardcoded?
						subscriptionSearchBoxForm.addEventListener("submit", e => {
							e.preventDefault();
							
							var searchTerm = subscriptionSearchBoxElement.value;
							
							searchTerm = searchTerm.trim();  //??? not sure if it's correct to trim or if we should fully respect the user input?
							
							this.setAttribute("data-search-term", searchTerm);
							
							alreadySubscribedWarningElement.setAttribute("hidden", "");
							
							return false;
						});
						
						var candidateDefaultSearchTerm = this.#searchTermQueryString && getURLSearchParameter(this.#searchTermQueryString);
						
						if (getType(candidateDefaultSearchTerm) === getType.string) {
							try {
								var allGTFSRouteLineFullNamesByNumberWithoutLeadingZeros = await fetchGTFSRouteLineFullNamesByNumberWithoutLeadingZeros;
								
								var candidateDefaultSearchTermAsUpperCaseString = candidateDefaultSearchTerm.toUpperCase();
								var candidateDefaultSearchTermAsLowerCaseString = candidateDefaultSearchTerm.toLowerCase();
								
								var subscribableGTFSItemNumber = allGTFSRouteLineFullNamesByNumberWithoutLeadingZeros.has(candidateDefaultSearchTermAsUpperCaseString) === true
								&& candidateDefaultSearchTermAsUpperCaseString
								|| window.GTFS_LINE_NAMES_URL_SAFE_TO_LINE_NUMBERS[candidateDefaultSearchTermAsLowerCaseString]
								|| GTFS_STATION_NAMES_URL_SAFE_TO_STATION_NUMBERS.get(candidateDefaultSearchTermAsLowerCaseString);
								
								if (subscribableGTFSItemNumber) {
									var formattedGTFSItemNumber = GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME.get(subscribableGTFSItemNumber) || GTFS_STATION_NUMBERS_TO_STATION_NAMES.get(subscribableGTFSItemNumber) || subscribableGTFSItemNumber.toUpperCase();
									
									subscriptionSearchBoxElement.value = formattedGTFSItemNumber;
								}
							} catch (error) {
								console.error(error);
							}
						}
					} else {
						this.#renderSearchResults();
					}
				}
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-include-gtfs-items":
					; (() => {
						this.#includedGTFSItems = curValue.split(","); //??? should validate these are all valid GTFS items
					})();
					
					break;
				case "data-exclude-gtfs-items":
					; (() => {
						this.#excludedGTFSItems = curValue.split(","); //??? should validate these are all valid GTFS items
					})();
					
					break;
				case "data-exclude-routelines":
					; (() => {
						this.#excludeGTFSRouteLines = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-exclude-stations":
					; (() => {
						this.#excludeGTFSStations = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-show-current-subscriptions":
					; (() => {
						this.#showCurSubscriptions = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-show-subscription-search":
					; (() => {
						this.#showSubscriptionSearch = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-search-term-querystring-is":
					; (() => {
						this.#searchTermQueryString = curValue;
					})();
					
					break;
				case "data-search-term":
					; (() => {
						this.#searchTerm = curValue; //??? should validate this is a string?
						
						this.#showSubscriptionSearch === true && getType(this.#searchTerm) === getType.string && this.#renderSearchResults();  //??? is there a .bind(this) missing?
					})();
					
					break;
				case "data-you-are-already-subscribed-messaging":
					; (() => {
						this.#alreadySubscribedMessaging = curValue;
					})();
					
					break;
				case "data-show-search-submit":
					; (() => {
						this.#showSearchSubmit = curValue === "false" ? false : true;
					})();
					
					break;
				case "data-set-max-height-for-results":
					; (() => {
						this.#setMaxHeightForResults = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-show-delete-all-alerts-button":
					; (() => {
						this.#showDeleteAllAlerts = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-preview-map-id":
					; (() => {
						this.#targetPreviewMapID = curValue;  //??? sanitize?
					})();
					
					break;
				case "data-target-form-id":
					; (() => {
						this.#targetFormID = curValue;  //??? sanitize?
					})();
					
					break;
				case "data-target-input-name":
					; (() => {
						this.#targetInputName = curValue;  //??? sanitize?
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="transitAlertsSubscriptionPrompt">
	import { fetchValidAlertSubscriptionGTFSItemNumbers } from "/js/alertSubscriptions.mjs";
	
	customElements.define("transit-alert-subscription-prompt", class TransitAlertsSubscriptionPrompt extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-target-gtfsitem"
				, "data-remove-hidden-on-init"
			];
		}
		
		#targetGTFSItem;
		#isRemovingHiddenOnInit;
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			if (!this.#targetGTFSItem) {
				this.remove();
			} else {
				try {
					var allValidAlertSubscriptionGTFSItemNumbers = await fetchValidAlertSubscriptionGTFSItemNumbers;
					
					//??? we need to enhance this widget to never show up when the target GTFS item is no longer valid
					var foundTargetGTFSItem = allValidAlertSubscriptionGTFSItemNumbers && allValidAlertSubscriptionGTFSItemNumbers.includes(this.#targetGTFSItem);
					
					if (foundTargetGTFSItem === true) {
						this.remove();
					} else if (this.#isRemovingHiddenOnInit === true) {
						this.removeAttribute("hidden");
					}
				} catch (error) {
					console.error(error);
				}
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-target-gtfsitem":
					; (() => {
						this.#targetGTFSItem = curValue;
					})();
					
					break;
				case "data-remove-hidden-on-init":
					; (() => {
						this.#isRemovingHiddenOnInit = curValue === "true" ? true : false;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="transitAlertsSubscriptionTitle">
	import { formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber } from "/js/gtfsHelpers.mjs";
	import { fetchGTFSRouteLineFullNamesByNumber } from "/js/gtfsRouteLines.mjs";
	import { GTFS_STATION_NUMBERS_TO_STATION_NAMES, fetchGTFSStationsByNumber } from "/js/gtfsStations.mjs";
	import { fetchValidAlertSubscriptionGTFSItemNumbers } from "/js/alertSubscriptions.mjs";
	
	customElements.define("transit-alert-subscription-title", class TransitAlertsSubscriptionTitle extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-is-editing-subscription"
			];
		}
		
		#preHeadingElement;
		#headingElement;
		
		async #updateTitle() {
			try {
				var [gtfsRouteLineFullNamesByNumber, gtfsStationsByNumber, validAlertSubscriptionGTFSItemNumbers] = await Promise.all([
					fetchGTFSRouteLineFullNamesByNumber
					, fetchGTFSStationsByNumber
					, fetchValidAlertSubscriptionGTFSItemNumbers
				]);
				
				var curURL = new URL(document.location);
				var targetGTFSItemQuery = curURL && curURL.searchParams.get("for");
				
				if (targetGTFSItemQuery === undefined || targetGTFSItemQuery === null) {
					this.#preHeadingElement.textContent = "";
					this.#headingElement.textContent = "";
					
					return;
				}
				
				var targetGTFSItemNumber = window.GTFS_LINE_NAMES_URL_SAFE_TO_LINE_NUMBERS[targetGTFSItemQuery] || window.GTFS_STATION_NAMES_URL_SAFE_TO_STATION_NUMBERS[targetGTFSItemQuery] || targetGTFSItemQuery.toUpperCase();
				
				if (gtfsRouteLineFullNamesByNumber.has(targetGTFSItemNumber) === false && gtfsStationsByNumber.has(targetGTFSItemNumber) === false) {
					this.#preHeadingElement.textContent = "";
					this.#headingElement.textContent = "";
					
					return;
				}
				
				var unpaddedTargetGTFSRouteLineNumber;
				
				var gtfsItemName = "";
				
				if (gtfsRouteLineFullNamesByNumber.has(targetGTFSItemNumber) === true) {
					unpaddedTargetGTFSRouteLineNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(targetGTFSItemNumber) || targetGTFSItemNumber;
					
					gtfsItemName = window.GTFS_ROUTELINE_NUMBER_TO_NAME[unpaddedTargetGTFSRouteLineNumber] || (`Route ${unpaddedTargetGTFSRouteLineNumber} ${gtfsRouteLineFullNamesByNumber.get(unpaddedTargetGTFSRouteLineNumber).substring(gtfsRouteLineFullNamesByNumber.get(unpaddedTargetGTFSRouteLineNumber).indexOf(" "))}`).replaceAll("/", " / ");  //??? this is a terribly complex line; need to refactor to expand
				}
				
				if (gtfsStationsByNumber.has(targetGTFSItemNumber) === true) {
					gtfsItemName = GTFS_STATION_NUMBERS_TO_STATION_NAMES.get(targetGTFSItemNumber);
				}
				
				if (!gtfsItemName) {
					this.#preHeadingElement.textContent = "";
					this.#headingElement.textContent = "";
					
					return;
				}
				
				if (unpaddedTargetGTFSRouteLineNumber && validAlertSubscriptionGTFSItemNumbers.includes(unpaddedTargetGTFSRouteLineNumber) === true || validAlertSubscriptionGTFSItemNumbers.includes(targetGTFSItemNumber) === true) {
					this.#preHeadingElement.textContent = "Editing subscription for";
					this.#headingElement.textContent = gtfsItemName;
				} else {
					this.#preHeadingElement.textContent = "Creating subscription for";
					this.#headingElement.textContent = gtfsItemName;
				}
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				//??? the preheading <p> needs some aria to relate it to the heading itself
				var preHeadingElementWrapper = document.createElement("p");
				preHeadingElementWrapper.setAttribute("style", "margin: 0px;");
				
				preHeadingElementWrapper.append(this.#preHeadingElement);
				
				this.append(preHeadingElementWrapper);
				this.append(this.#headingElement);
			} catch (error) {
				console.error(error);
			}
		};
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#preHeadingElement = document.createElement("strong");
			
			this.#headingElement = document.createElement("h2");
			this.#headingElement.setAttribute("style", "margin: 0px;");
			
			this.#updateTitle();
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) { }
	});
</script><script type="module" class="transitAlertsDeleteSubscription">
	import { buildEnvironmentSpecificURL } from "https://tlweblibs.translink.ca/buildEnvironmentSpecificURL-1.0.1.mjs";
	import { fetchAuthID } from "/js/authed.mjs";
	const ALERT_SUBSCRIPTIONS_MODULE_URL_STRING = "/js/alertSubscriptions.mjs";
	
	customElements.define("transit-alert-delete-subscription", class TransitAlertsDeleteSubscription extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-target-gtfsitem"
				, "data-target-form-id"
			];
		}
		
		#targetGTFSItem;
		#targetFormID;
		
		async #render() {
			var FORM_ID = this.#targetFormID;
			
			//GUARD: do nothing if there is no form ID
			if (!FORM_ID) {
				return;
			}
			
			try {
				var authID = fetchAuthID && await fetchAuthID;
				
				//GUARD: do nothing if there is no auth ID
				if (!authID) {
					return;
				}
				
				var targetGTFSItemNumber = this.#targetGTFSItem;
				var paddedTargetGTFSItemNumber = window.getPaddedGTFSRouteLineNumber && window.getPaddedGTFSRouteLineNumber(targetGTFSItemNumber) || targetGTFSItemNumber;
				
				var targetFormElement = document.getElementById(FORM_ID);
				
				if (!targetFormElement) {
					try {
						var apiURLString = await buildEnvironmentSpecificURL(`https://postaway.translink.ca/api/rsp/${authID}/alerts`);
						var apiURL = apiURLString && new URL(apiURLString);
						
						buildEnvironmentSpecificURL()
						targetFormElement = document.createElement("form");
						targetFormElement.setAttribute("id", FORM_ID);
						targetFormElement.setAttribute("name", FORM_ID);
						targetFormElement.setAttribute("method", "DELETE");
						targetFormElement.setAttribute("action", apiURL)
						
						targetFormElement.addEventListener("submit", e => {
							var targetURLString = targetFormElement.hasAttribute("action") && targetFormElement.getAttribute("action");
							var targetURL = targetURLString && new URL(targetURLString);
							
							var fetchOptions = window.getFetchOptionsFromFormElement(targetFormElement, { setContentTypeToJSON: true });
							fetchOptions.body = JSON.stringify([
								{
									routeNumber: paddedTargetGTFSItemNumber.length < 5 && paddedTargetGTFSItemNumber || null
									, stationId: paddedTargetGTFSItemNumber.length === 5 && paddedTargetGTFSItemNumber || null
								}
							]);
							
							targetURL && fetch(targetURL, fetchOptions)
							.finally(() => {
								window.location.href = "/alert-subscriptions";
							});
							
							e.preventDefault();
							return false;
						});
						
						document.body.append(targetFormElement);
					} catch (error) {
						console.error(error);
					}
				}
				
				var deleteAlertButton = document.createElement("button");
				deleteAlertButton.setAttribute("type", "submit");
				deleteAlertButton.setAttribute("form", FORM_ID);
				deleteAlertButton.setAttribute("class", "maxWidth");
				deleteAlertButton.textContent = "Delete subscription";
				
				this.append(deleteAlertButton);
			} catch (error) {
				console.error(error);
			}
		}
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			if (this.#targetGTFSItem === undefined) {
				var curURL = new URL(document.location);
				var targetGTFSItemQuery = curURL && curURL.searchParams.get("for");
				
				var targetGTFSItemNumber = window.GTFS_LINE_NAMES_URL_SAFE_TO_LINE_NUMBERS[targetGTFSItemQuery] || window.GTFS_STATION_NAMES_URL_SAFE_TO_STATION_NUMBERS[targetGTFSItemQuery] || targetGTFSItemQuery.toUpperCase();
				
				this.setAttribute("data-target-gtfsitem", targetGTFSItemNumber);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-target-gtfsitem":
					; (async () => {
						try {
							var alertSubscriptionsModuleURL = ALERT_SUBSCRIPTIONS_MODULE_URL_STRING && new URL(ALERT_SUBSCRIPTIONS_MODULE_URL_STRING, document.location.origin);
							
							var { fetchValidAlertSubscriptionGTFSItemNumbers } = alertSubscriptionsModuleURL && await import(alertSubscriptionsModuleURL);
							
							var validAlertSubscriptionGTFSItemNumbers = fetchValidAlertSubscriptionGTFSItemNumbers && await fetchValidAlertSubscriptionGTFSItemNumbers;
							
							var foundTargetGTFSItem = validAlertSubscriptionGTFSItemNumbers && validAlertSubscriptionGTFSItemNumbers.includes(curValue.toUpperCase());
							
							if (foundTargetGTFSItem === true) {
								this.#targetGTFSItem = curValue;
								
								this.#targetFormID !== undefined && this.#targetGTFSItem !== undefined && this.#render();
							}
						} catch (error) {
							console.error(error);
						}
					})();
					
					break;
				case "data-target-form-id":
					; (() => {
						this.#targetFormID = curValue;
						
						this.#targetFormID !== undefined && this.#targetGTFSItem !== undefined && this.#render();
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="transitAlertsDeleteAllSubscriptions">
	import { buildEnvironmentSpecificURL } from "https://tlweblibs.translink.ca/buildEnvironmentSpecificURL-1.0.1.mjs";
	import { fetchAuthID } from "/js/authed.mjs";
	
	customElements.define("transit-alert-delete-all-subscriptions", class TransitAlertsDeleteAllSubscriptions extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			try {
				var authID = fetchAuthID && await fetchAuthID;
				
				//GUARD: do nothing if there is no auth ID
				if (!authID) {
					return;
				}
				
				const FORM_ID = "deleteAllAlertSubscriptions";
				
				var apiURLString = await buildEnvironmentSpecificURL(`https://postaway.translink.ca/api/rsp/${authID}/allalerts`);
				var apiURL = apiURLString && new URL(apiURLString);
				
				//??? need to convert this to a "crash landing form"
				var deleteAllAlertSubscriptionsFormElement = document.createElement("form");
				deleteAllAlertSubscriptionsFormElement.setAttribute("id", FORM_ID);
				deleteAllAlertSubscriptionsFormElement.setAttribute("name", FORM_ID);
				deleteAllAlertSubscriptionsFormElement.setAttribute("method", "DELETE");  //??? I think this is illegal?  can only set method to GET or POST
				deleteAllAlertSubscriptionsFormElement.setAttribute("action", apiURL);
				
				var confirmationButtonElement = document.createElement("button");
				confirmationButtonElement.setAttribute("type", "submit");
				confirmationButtonElement.setAttribute("form", FORM_ID);
				confirmationButtonElement.setAttribute("class", "maxWidth");
				confirmationButtonElement.textContent = "Delete alert subscriptions";  //??? remove hardcoding?
				
				this.append(confirmationButtonElement);
				
				deleteAllAlertSubscriptionsFormElement.addEventListener("submit", e => {
					e.preventDefault();  //??? why is this so high up instead of at the bottom?
					
					var targetURL = deleteAllAlertSubscriptionsFormElement && window.getFetchURLFromFormElement && window.getFetchURLFromFormElement(deleteAllAlertSubscriptionsFormElement);  //??? replace reference to 'deleteAllAlertSubscriptionsFormElement' with "target.form"
					
					var fetchOptions = window.getFetchOptionsFromFormElement(deleteAllAlertSubscriptionsFormElement);
					
					try {
						targetURL && fetch(targetURL, fetchOptions);  //??? seems like we should do something if targetURL is not found?
					} catch (error) {
						console.error(error);
					} finally {
						window.location.href = "/alert-subscriptions";  //??? replace with URL object
					}
					
					return false;
				});
				
				document.body.append(deleteAllAlertSubscriptionsFormElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) { }
	});
</script><script type="module" class="transitAlertsDeleteAccount">
	import { buildEnvironmentSpecificURL } from "https://tlweblibs.translink.ca/buildEnvironmentSpecificURL-1.0.1.mjs";
	import { fetchAuthID } from "/js/authed.mjs";
	
	customElements.define("transit-alert-delete-account", class TransitAlertsDeleteAccount extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			try {
				var authID = fetchAuthID && await fetchAuthID;
				
				//GUARD: do nothing if there is no auth ID
				if (!authID) {
					return;
				}
				
				var apiURLString = await buildEnvironmentSpecificURL(`https://postaway.translink.ca/api/users/${authID}`);
				var apiURL = apiURLString && new URL(apiURLString);
				
				var deleteTransitAlertsAccountFormElement = document.createElement("form");
				deleteTransitAlertsAccountFormElement.setAttribute("id", "deleteTransitAlertsAccount");
				deleteTransitAlertsAccountFormElement.setAttribute("name", "deleteTransitAlertsAccount");
				deleteTransitAlertsAccountFormElement.setAttribute("method", "GET");
				deleteTransitAlertsAccountFormElement.setAttribute("action", "/");  //??? replace with proper crash landing page....the /transit-alerts-error page?    //??? replace with URL Object Pattern
				deleteTransitAlertsAccountFormElement.setAttribute("data-fetch-method", "DELETE");
				deleteTransitAlertsAccountFormElement.setAttribute("data-fetch-action", apiURL);
				
				var confirmationButtonElement = document.createElement("button");
				confirmationButtonElement.setAttribute("type", "submit");
				confirmationButtonElement.setAttribute("class", "maxWidth");
				confirmationButtonElement.textContent = "Delete account";
				
				deleteTransitAlertsAccountFormElement.append(confirmationButtonElement);
				
				deleteTransitAlertsAccountFormElement.addEventListener("submit", async e => {
					e.preventDefault();
					
					try {
						var targetURL = deleteTransitAlertsAccountFormElement && window.getFetchURLFromFormElement && window.getFetchURLFromFormElement(deleteTransitAlertsAccountFormElement);
						
						var fetchOptions = window.getFetchOptionsFromFormElement(deleteTransitAlertsAccountFormElement);
						
						var response = await fetch(targetURL, fetchOptions);
						
						if (response.ok === true && response.status === 200) {
							var targetForm = document.getElementById("AccountLogout");
							
							if (targetForm) {
								targetForm.action = "/auth/postdeletesignout";  //??? refactor to use setAttribute() and URL Object
								
								targetForm.submit();
							}
						} else {
							//??? add error handling
						}
					} catch (error) {
						console.error(error);
					}
					
					return false;
				});
				
				this.append(deleteTransitAlertsAccountFormElement);
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) { }
	});
</script><script type="module" class="TransitAlertsSuspendDeliverySettings">
	import { fetchAuthID } from "/js/authed.mjs";
	const TRANSLINK_PROFILE_MODULE_URL_STRING = "/js/translinkProfile.mjs";
	
	customElements.define("transit-alerts-suspend-delivery-settings", class TransitAlertsSuspendDeliverySettings extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-is-summary-only"
				, "data-target-form-id"
			];
		}
		
		#isSummaryOnly;
		
		#targetFormID;
		
		#setMinEndDate(startDateInputElement, endDateInputElement) {
			var startDateValue = startDateInputElement.value;
			
			//??? validate parsed hour and minute values
			var minEndDateTime = new Date(startDateValue);
			minEndDateTime.setDate(minEndDateTime.getDate() + 1);
			
			if (minEndDateTime) {
				endDateInputElement.setAttribute("min", minEndDateTime);
			}
		}
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			try {
				var authID = fetchAuthID && await fetchAuthID;
				
				//GUARD: do nothing if there is no auth ID
				if (!authID) {
					return false;
				}
				
				var translinkProfileModuleURL = TRANSLINK_PROFILE_MODULE_URL_STRING && new URL(TRANSLINK_PROFILE_MODULE_URL_STRING, document.location.origin);
				
				var { fetchUserProfile } = translinkProfileModuleURL && await import(translinkProfileModuleURL);
				
				var userProfile = authID && await fetchUserProfile(authID);
				
				var FORM_ID = this.#targetFormID;
				
				var isDisabled = userProfile.isDeliverySuspended;
				
				var timeZoneOffsetInMinutes = (new Date()).getTimezoneOffset();
				
				var startDateInitValue = userProfile.deliverySuspensionStartDateTimeISOString && window.getDashDelimitedDateString(new Date(userProfile.deliverySuspensionStartDateTimeISOString));
				var startDate = startDateInitValue && new Date(startDateInitValue) || new Date();
				startDateInitValue && startDate.setDate(startDate.getDate() + 1);
				startDate.setHours(0);
				startDate.setMinutes(0);
				startDate.setSeconds(0);
				var startDateAsString = startDate && window.getDashDelimitedDateString(startDate);
				
				var endDateInitValue = userProfile.deliverySuspensionEndDateTimeISOString && window.getDashDelimitedDateString(new Date(userProfile.deliverySuspensionEndDateTimeISOString));
				var endDate = endDateInitValue && new Date(endDateInitValue) || new Date();
				endDate.setHours(0);
				endDate.setMinutes(0 + timeZoneOffsetInMinutes);
				var endDateAsString = endDate && window.getDashDelimitedDateString(endDate);
				
				//GUARD: do nothing if there is no form ID
				if (!FORM_ID) {
					return;
				}
				
				var targetURLString = authID && window.buildEnvironmentSpecificURL(`https://postaway.translink.ca/api/rsp/${authID}/delivery/snooze`);
				var targetURL = targetURLString && new URL(targetURLString);
				
				var targetFormElement = document.getElementById(FORM_ID);
				
				if (!targetFormElement) {
					targetFormElement = document.createElement("form");
					targetFormElement.setAttribute("id", FORM_ID);
					targetFormElement.setAttribute("name", FORM_ID);
					targetFormElement.setAttribute("method", "PUT");
					targetFormElement.setAttribute("action", targetURL);
					
					targetFormElement.addEventListener("submit", e => {
						e.preventDefault();
						
						//??? close modal window on successful update  //??? but this is bad?  it's a hardcoded update
						userProfile.setDeliverySuspension && userProfile.setDeliverySuspension(targetFormElement, () => {
							var submitterButtonElement = window.bestEffort_GetFormSubmitter && window.bestEffort_GetFormSubmitter(e);
							
							var dialogForm = submitterButtonElement && submitterButtonElement.closest('form[method="dialog"]');
							
							dialogForm && dialogForm.submit();
							
							window.location.reload();
						});
						
						return false;
					});
					
					document.body.append(targetFormElement);
				}
				
				isDisabled === true && targetFormElement.setAttribute("novalidate", "");
				isDisabled === false && targetFormElement.removeAttribute("novalidate");
				
				var curDate = new Date();
				curDate.setHours(0);
				curDate.setMinutes(0);
				curDate.setSeconds(0);
				curDate.setMilliseconds(0);
				
				if (this.#isSummaryOnly === true) {
					//do not show the summary if snooze isn't being used
					if (isDisabled === true) {
						this.remove();
						
						return;
					}
					
					//do not show the summary if we are past the end date
					if (endDate && endDate < curDate) {
						this.remove();
						
						return;
					}
					
					var snoozeIconElement = document.createElement("img");
					snoozeIconElement.setAttribute("role", "presentation");
					snoozeIconElement.setAttribute("src", "/-/media/translink/icons/alerts/new/off.svg");  //??? replace with URL Object Pattern
					snoozeIconElement.setAttribute("width", 86);
					snoozeIconElement.setAttribute("height", 100);
					snoozeIconElement.setAttribute("loading", "lazy");
					snoozeIconElement.setAttribute("decoding", "async");
					snoozeIconElement.setAttribute("style", "width: fit-content;");
					snoozeIconElement.setAttribute("aria-hidden", true);
					
					var snoozeTimeframeDescriptionElement = document.createElement("p");
					snoozeTimeframeDescriptionElement.setAttribute("class", "centerText");
					
					var snoozeTimeFrameTextElement = document.createElement("strong");
					
					var formattedStartDateString = "";
					var formattedEndDateString = "";
					
					var curDateYear = curDate.getFullYear();
					var startDateYear = startDate.getFullYear();
					var endDateYear = endDate.getFullYear();
					
					var isStartDateInCurYear = startDateYear === curDateYear;
					var isEndDateInCurYear = endDateYear === curDateYear;
					
					if (isStartDateInCurYear === false || isEndDateInCurYear === false) {
						formattedStartDateString = `${window.MONTHS[startDate.getMonth()]} ${startDate.getDate()}, ${startDateYear}`;
						formattedEndDateString = `${window.MONTHS[endDate.getMonth()]} ${endDate.getDate()}, ${endDateYear}`;
					} else {
						formattedStartDateString = `${window.MONTHS[startDate.getMonth()]} ${startDate.getDate()}`;
						formattedEndDateString = `${window.MONTHS[endDate.getMonth()]} ${endDate.getDate()}`;
					}
					
					if (startDateYear === endDateYear && startDate.getDate() === endDate.getDate()) {
						var snoozeTextTimeElement = document.createElement("time");
						snoozeTextTimeElement.setAttribute("datetime", startDateAsString);
						snoozeTextTimeElement.setAttribute("style", "font: inherit;");
						snoozeTextTimeElement.textContent = formattedStartDateString;
						
						snoozeTimeFrameTextElement.append(snoozeTextTimeElement);
						
						snoozeTimeframeDescriptionElement.append(document.createTextNode("You have turned off all your alerts on"));
					} else {
						var snoozeTimeFrameStartingTextTimeElement = document.createElement("time");
						snoozeTimeFrameStartingTextTimeElement.setAttribute("datetime", startDateAsString);
						snoozeTimeFrameStartingTextTimeElement.setAttribute("style", "font: inherit;");
						snoozeTimeFrameStartingTextTimeElement.textContent = formattedStartDateString;
						
						var snoozeTimeFrameEndingTextTimeElement = document.createElement("time");
						snoozeTimeFrameEndingTextTimeElement.setAttribute("datetime", endDateAsString);
						snoozeTimeFrameEndingTextTimeElement.setAttribute("style", "font: inherit;");
						snoozeTimeFrameEndingTextTimeElement.textContent = formattedEndDateString;
						
						snoozeTimeFrameTextElement.append(snoozeTimeFrameStartingTextTimeElement);
						snoozeTimeFrameTextElement.append(document.createTextNode(" to "));
						snoozeTimeFrameTextElement.append(snoozeTimeFrameEndingTextTimeElement);
						
						snoozeTimeframeDescriptionElement.append(document.createTextNode("You have turned off all your alerts from"));
					}
					
					snoozeTimeframeDescriptionElement.append(document.createElement("br"));
					snoozeTimeframeDescriptionElement.append(snoozeTimeFrameTextElement);
					
					var changeSnoozeSettingsFormElement = document.createElement("form");
					changeSnoozeSettingsFormElement.setAttribute("id", `${FORM_ID}_disable_only`);  //??? remove hardcoding
					changeSnoozeSettingsFormElement.setAttribute("name", `${FORM_ID}_disable_only`);  //??? remove hardcoding
					changeSnoozeSettingsFormElement.setAttribute("method", "PUT");
					changeSnoozeSettingsFormElement.setAttribute("action", targetURL);
					changeSnoozeSettingsFormElement.setAttribute("class", "contentItem flexContainer flexWrapper horizontallyCenteredContent verticallyCenteredContent useButton");
					changeSnoozeSettingsFormElement.setAttribute("style", "gap: 1rem; margin-top: 2.25rem");
					changeSnoozeSettingsFormElement.setAttribute("novalidate", "");
					
					var changeSettingsButtonElement = document.createElement("button");
					changeSettingsButtonElement.setAttribute("type", "button");
					changeSettingsButtonElement.setAttribute("data-infowindow", "Turn Off All Alerts");
					changeSettingsButtonElement.setAttribute("data-no-infowindow-icon", "");
					changeSettingsButtonElement.setAttribute("style", "margin-top: 0px;");
					changeSettingsButtonElement.textContent = "Change time period";
					
					var resumeAlertsButtonElement = document.createElement("button");
					resumeAlertsButtonElement.setAttribute("type", "submit");
					resumeAlertsButtonElement.setAttribute("style", "margin-top: 0px;");
					resumeAlertsButtonElement.textContent = "Resume alerts now";
					
					var isDisabledInputField = document.createElement("input");
					isDisabledInputField.setAttribute("type", "hidden");
					isDisabledInputField.setAttribute("form", `${FORM_ID}_disable_only`);  //??? remove hardcoding
					isDisabledInputField.setAttribute("name", "isEnabled");
					isDisabledInputField.setAttribute("value", false);
					
					changeSnoozeSettingsFormElement.append(changeSettingsButtonElement);
					changeSnoozeSettingsFormElement.append(resumeAlertsButtonElement);
					changeSnoozeSettingsFormElement.append(isDisabledInputField);
					
					this.append(snoozeIconElement);
					this.append(snoozeTimeframeDescriptionElement);
					this.append(changeSnoozeSettingsFormElement);
					
					changeSnoozeSettingsFormElement.addEventListener("submit", e => {
						userProfile.setDeliverySuspension && userProfile.setDeliverySuspension(changeSnoozeSettingsFormElement, () => {
							window.location.reload();
						});
						
						e.preventDefault();
						return false;
					});
				} else {
					var wrapperElement = document.createElement("date-range-picker");
					wrapperElement.setAttribute("data-start-date-input-name", "startDateTime");
					wrapperElement.setAttribute("data-end-date-input-name", "endDateTime");
					wrapperElement.setAttribute("class", "flexContainer flexColumn verticallyCenteredContent");
					
					var startEndDateWrapperElement = document.createElement("div");
					startEndDateWrapperElement.setAttribute("class", "contentItem flexContainer flexWrapper");
					startEndDateWrapperElement.setAttribute("style", "gap: 1rem;");
					
					var startDateLabelElement = document.createElement("label");
					startDateLabelElement.setAttribute("style", "margin-top: 0px; flex: 1 0 0;");
					startDateLabelElement.textContent = "Turn off alerts from:";
					
					var startDateInputElement = document.createElement("input");
					startDateInputElement.setAttribute("type", "date");
					startDateInputElement.setAttribute("form", FORM_ID);
					startDateInputElement.setAttribute("name", "startDateTime");
					startDateInputElement.setAttribute("required", "");
					
					if (startDateInitValue === null || startDate.getDate() < curDate.getDate()) {
						startDateInputElement.setAttribute("value", "currentDateTime");
					} else {
						startDateInputElement.setAttribute("value", startDateAsString);
					}
					
					startDateInputElement.setAttribute("min", "currentDateTime");
					startDateInputElement.setAttribute("aria-describedby", "start-end-date_error-msg");
					startDateInputElement.setAttribute("aria-errormessage", "start-end-date_error-msg");
					
					startDateLabelElement.append(startDateInputElement);
					
					var endDateLabelElement = document.createElement("label");
					endDateLabelElement.setAttribute("style", "margin-top: 0px; flex: 1 0 0;");
					endDateLabelElement.textContent = "To:";
					
					var endDateInputElement = document.createElement("input");
					endDateInputElement.setAttribute("type", "date");
					endDateInputElement.setAttribute("form", FORM_ID);
					endDateInputElement.setAttribute("name", "endDateTime");
					endDateInputElement.setAttribute("required", "");
					
					if (endDateInitValue === null || endDate.getDate() < curDate.getDate()) {
						endDateInputElement.setAttribute("value", "currentDateTime");
					} else {
						endDateInputElement.setAttribute("value", endDateAsString);
					}
					
					endDateInputElement.setAttribute("min", "currentDateTime");
					endDateInputElement.setAttribute("aria-describedby", "start-end-date_error-msg");
					endDateInputElement.setAttribute("aria-errormessage", "start-end-date_error-msg");
					
					endDateLabelElement.append(endDateInputElement);
					
					startEndDateWrapperElement.append(startDateLabelElement);
					startEndDateWrapperElement.append(endDateLabelElement);
					
					var startEndDateErrorMessagingElement = document.createElement("output");
					startEndDateErrorMessagingElement.setAttribute("role", "alert");
					startEndDateErrorMessagingElement.setAttribute("id", "start-end-date_error-msg");
					startEndDateErrorMessagingElement.setAttribute("aria-live", "assertive");
					startEndDateErrorMessagingElement.setAttribute("style", "margin-top: 0px; margin-left: auto; font-weight: 700;");
					
					wrapperElement.append(startEndDateWrapperElement);
					wrapperElement.append(startEndDateErrorMessagingElement);
					
					var isEnabledInput = document.createElement("input");
					isEnabledInput.setAttribute("type", "hidden");
					isEnabledInput.setAttribute("form", FORM_ID);
					isEnabledInput.setAttribute("name", "isEnabled");
					isEnabledInput.setAttribute("value", true);
					
					this.append(wrapperElement);
					this.append(isEnabledInput);
					
					startDateInputElement.addEventListener("change", e => {
						var curValue = e.target.value;
						
						curValue && endDateInputElement.setAttribute("min", curValue);
						!curValue && endDateInputElement.setAttribute("value", "currentDateTime");
					});
				}
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-is-summary-only":
					; (() => {
						this.#isSummaryOnly = curValue === "true" ? true : false;
					})();
					
					break;
				case "data-target-form-id":
					; (() => {
						this.#targetFormID = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="gtfsFavourite">
	import { getType, isValidNumber } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { getURLSearchParameter } from "https://tlweblibs.translink.ca/URLHelpers-1.0.0.mjs";
	import { PersistentStorage } from "https://tlweblibs.translink.ca/PersistentStorage-2.0.1.mjs";
	import { convertLatAndLngToLatLng } from "/js/geographyHelpers.mjs";
	import { GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME } from "/js/gtfsLines.mjs";
	import { fetchGTFSStationNamesByNumber } from "/js/gtfsStations.mjs";
	import { fetchGTFSStopNamesByNumber } from "/js/gtfsStops.mjs";
	import { fetchGTFSRouteLinesByNumber } from "/js/gtfsRouteLines.mjs";
	
	customElements.define("gtfs-favourite", class GTFSFavourite extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-lat-key"
				, "data-lng-key"
			];
		}
		
		#ADD_GTFS_FAVOURITE_FORM_NAME = "addGTFSFavourite";
		#STORAGE_NAMESPACE = "V3GTFSFavourites";
		
		#isConnected = false;
		
		#targetGTFSItemNumber;
		#targetGTFSItemName;
		#gtfsItemType;
		
		#latURLSearchParameterKey = "lat";
		#lngURLSearchParameterKey = "lng";
		#distanceInMetresURLSearchParameterKey = "distanceInMetres";
		
		#targetLatAsString = "";
		#targetLngAsString = "";
		#targetDistanceInMetres;
		#targetFavURLIsLatLng = false;
		
		#targetFavURLString = "";  //??? we should make the default value a const?
		
		#formatKeyWithStorageNamespace = key => {
			//??? check that key is actually a string?
			var output = `${this.#STORAGE_NAMESPACE}.${key}`;
			
			return output;
		};
		
		#saveCurFavPageURLString = () => {
			//??? stop accessing private members directly; just assign them to a local at the beginning
			this.#targetFavURLString = "";
			
			this.#targetLatAsString = getURLSearchParameter(this.#latURLSearchParameterKey);
			this.#targetLngAsString = getURLSearchParameter(this.#lngURLSearchParameterKey);
			this.#targetDistanceInMetres = getURLSearchParameter(this.#distanceInMetresURLSearchParameterKey);
			
			var curFavPageURLAsString;
			
			try {
				var curFavPageURLString = document.location.pathname;
				var curFavPageURL = curFavPageURLString && new URL(curFavPageURLString, document.location.origin);
				
				var targetLat = parseFloat(this.#targetLatAsString);
				var targetLng = parseFloat(this.#targetLngAsString);
				
				var targetLatLng = convertLatAndLngToLatLng(targetLat, targetLng);
				
				if (getType(targetLatLng) === getType.array) {
					curFavPageURL.searchParams.set(this.#latURLSearchParameterKey, this.#targetLatAsString);
					curFavPageURL.searchParams.set(this.#lngURLSearchParameterKey, this.#targetLngAsString);
					
					var targetDistanceInMetresAsNumber = parseInt(this.#targetDistanceInMetres, 10);  //??? should we change this to a float check?
					
					if (isValidNumber(targetDistanceInMetresAsNumber) === true) {
						curFavPageURL.searchParams.set(this.#distanceInMetresURLSearchParameterKey, targetDistanceInMetresAsNumber);
					}
					
					this.#targetFavURLIsLatLng = true;
				}
				
				curFavPageURLAsString = curFavPageURL.toString();
				
				this.#targetFavURLString = curFavPageURLAsString;
			} catch (error) {
				console.error(error);
			}
			
			return curFavPageURLAsString;
		};
		
		#render = () => {
			//remove any placeholder content once we have "soft confirmed" GPS is enabled
			//NOTE: "soft confirm" means that we look for signs that GPS permissions have been enabled and used, such as the existance of "latlng" data in the URL
			//NOTE: We cannot "hard confirm" GPS permissions are enabled because that might trigger a permissions popup
			//??? this behavior is very very likely buggy and may require "hard confirm" logic in the future
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			
			try {
				var curFavPageURLAsString = this.#saveCurFavPageURLString();  //??? should convert this to use URL Objects instead?
				
				var allGTFSFavouriteURLStrings = PersistentStorage.getAllKeys()  //??? should convert this to use URL Objects instead?
				.filter(curGTFSFavouriteKey => {
					var curGTFSFavouriteKeyNamespace = curGTFSFavouriteKey.split(".")[0];
					
					var isStartingWithStorageNamespace = curGTFSFavouriteKeyNamespace === this.#STORAGE_NAMESPACE;
					
					return isStartingWithStorageNamespace;
				})
				.map(curGTFSFavouriteKey => {
					try {
						var curGTFSFavouriteURLString = PersistentStorage.getItem(curGTFSFavouriteKey);
						
						return curGTFSFavouriteURLString;
					} catch (error) {
						console.error(error);
						
						return;
					}
				})
				.filter(curGTFSFavouriteURLString => {
					try {
						var curGTFSFavouriteURL = curGTFSFavouriteURLString && new URL(curGTFSFavouriteURLString, document.location.origin);
						
						if (getType(curGTFSFavouriteURL) === getType.url) {
							return true;
						} else {
							return false;
						}
					} catch (error) {
						console.error(error);
						
						return false;
					}
				});
				
				var targetGTFSItemType = this.#gtfsItemType || "";
				
				//??? "isCurFavPageURLAlreadyFavourited" should be "isCurFavPageURLStringAlreadyFavourited"
				var isCurFavPageURLAlreadyFavourited = allGTFSFavouriteURLStrings.includes(curFavPageURLAsString);    //??? should convert this to use URL Objects instead?
				
				if (isCurFavPageURLAlreadyFavourited === true) {
					const gtfsFavouritesPageLinkURLString = "/schedules-and-maps/favourites";
					var gtfsFavouritesPageLinkURL = gtfsFavouritesPageLinkURLString && new URL(gtfsFavouritesPageLinkURLString, document.location.origin);
					
					var gtfsFavouritesPageLinkElement = document.createElement("a");
					gtfsFavouritesPageLinkElement.setAttribute("href", gtfsFavouritesPageLinkURL);
					gtfsFavouritesPageLinkElement.textContent = "view your favourites";
					
					var alreadyAddedFavouriteMessageElement = document.createElement("p");
					
					switch (targetGTFSItemType.toLowerCase()) {
						case "line":
							; (() => {
								alreadyAddedFavouriteMessageElement.append(document.createTextNode("You've already added this line as a favourite. Please "));
								alreadyAddedFavouriteMessageElement.append(gtfsFavouritesPageLinkElement);
								alreadyAddedFavouriteMessageElement.append(document.createTextNode(" to edit or delete this item."));
							})();
							
							break;
						case "route":
							; (() => {
								alreadyAddedFavouriteMessageElement.append(document.createTextNode("You've already added this route as a favourite. Please "));
								alreadyAddedFavouriteMessageElement.append(gtfsFavouritesPageLinkElement);
								alreadyAddedFavouriteMessageElement.append(document.createTextNode(" to edit or delete this item."));
							})();
							
							break;
						case "stop":
							; (() => {
								alreadyAddedFavouriteMessageElement.append(document.createTextNode("You've already added this stop as a favourite. Please "));
								alreadyAddedFavouriteMessageElement.append(gtfsFavouritesPageLinkElement);
								alreadyAddedFavouriteMessageElement.append(document.createTextNode(" to edit or delete this item."));
							})();
							
							break;
						case "station":
							; (() => {
								alreadyAddedFavouriteMessageElement.append(document.createTextNode("You've already added this station as a favourite. Please "));
								alreadyAddedFavouriteMessageElement.append(gtfsFavouritesPageLinkElement);
								alreadyAddedFavouriteMessageElement.append(document.createTextNode(" to edit or delete this item."));
							})();
							
							break;
						default:
							; (() => {
								alreadyAddedFavouriteMessageElement.append(document.createTextNode("You've already added this location as a favourite. Please "));
								alreadyAddedFavouriteMessageElement.append(gtfsFavouritesPageLinkElement);
								alreadyAddedFavouriteMessageElement.append(document.createTextNode(" to edit or delete this item."));
							})();
							
							break;
					}
					
					this.append(alreadyAddedFavouriteMessageElement);
				} else {
					var defaultGTFSFavouriteName = "";
					
					if (this.#targetFavURLIsLatLng === true) {
						var distanceInMetres = parseInt(this.#targetDistanceInMetres, 10);
						
						if (isValidNumber(distanceInMetres) === true) {
							var defaultDistanceInMetresText = distanceInMetres === 1 ? "1 metre" : `${this.#targetDistanceInMetres} metres`;
							
							defaultGTFSFavouriteName = `${defaultDistanceInMetresText} from ${this.#targetLatAsString},${this.#targetLngAsString}`;  //??? replace with "getLatLng()"?
						} else {
							defaultGTFSFavouriteName = `${this.#targetLatAsString},${this.#targetLngAsString}`;  //??? replace with "getLatLng()"?
						}
					} else {
						switch (targetGTFSItemType.toLowerCase()) {
							case "line":
							case "route":
								; (() => {
									var gtfsDirectionPickerElement = document.querySelector('select[name="routeDirection"]');  //??? is there anyway to update the architecture to no longer need this hack?
									
									var selectedGTFSDirectionElement = gtfsDirectionPickerElement && gtfsDirectionPickerElement.selectedOptions && gtfsDirectionPickerElement.selectedOptions[0];
									
									var gtfsDirectionName = selectedGTFSDirectionElement && selectedGTFSDirectionElement.text;
									
									if (getType(gtfsDirectionName) === getType.string) {
										defaultGTFSFavouriteName = this.#targetGTFSItemName
										.replaceAll("{direction}", gtfsDirectionName)
										.trim();
									} else {
										defaultGTFSFavouriteName = this.#targetGTFSItemName
										.replaceAll(" {direction}", "")
										.trim();
									}
								})();
								
								break;
							case "stop":
								; (() => {
									defaultGTFSFavouriteName = `Stop # ${this.#targetGTFSItemNumber} - ${this.#targetGTFSItemName}`.trim();
								})();
								
								break;
							case "station":
								; (() => {
									defaultGTFSFavouriteName = this.#targetGTFSItemName.trim();
								})();
								
								break;
							default:
								; (() => {
									//??? error messaging?
								})();
								
								break;
						}
						
						if (defaultGTFSFavouriteName !== "") {
							defaultGTFSFavouriteName = `${defaultGTFSFavouriteName} ${(window.location.href.toLowerCase().includes("/map") === true ? "Map" : "Schedule")}`;  //??? maybe refactor this out? maybe use URL Objects so we can part by "/"?
						}
					}
					
					var addGTFSFavouriteFormElement = document.getElementById(this.#ADD_GTFS_FAVOURITE_FORM_NAME);
					
					var introMessageElement = document.createElement("p");
					introMessageElement.textContent = "Would you like to add this item to your list of Favourites?";
					
					var gtfsFavouriteKeyLabelElement = document.createElement("label");
					gtfsFavouriteKeyLabelElement.textContent = "Name";
					
					var gtfsFavouriteKeyInputElement = document.createElement("input");
					gtfsFavouriteKeyInputElement.setAttribute("type", "text");
					gtfsFavouriteKeyInputElement.setAttribute("form", this.#ADD_GTFS_FAVOURITE_FORM_NAME);
					gtfsFavouriteKeyInputElement.setAttribute("name", "gtfsFavouriteKey");  //??? hardcoded, need to remove hardcoding
					gtfsFavouriteKeyInputElement.setAttribute("required", "");
					gtfsFavouriteKeyInputElement.setAttribute("value", defaultGTFSFavouriteName);
					
					var gtfsFavouriteKeyInputValidationElement = document.createElement("small");
					gtfsFavouriteKeyInputValidationElement.setAttribute("aria-hidden", true);
					gtfsFavouriteKeyInputValidationElement.textContent = "Required";
					
					var gtfsFavouriteKeyInputErrorMessageElement = document.createElement("output");
					gtfsFavouriteKeyInputErrorMessageElement.setAttribute("role", "alert");
					gtfsFavouriteKeyInputErrorMessageElement.setAttribute("form", this.#ADD_GTFS_FAVOURITE_FORM_NAME);
					gtfsFavouriteKeyInputErrorMessageElement.setAttribute("aria-live", "polite");
					gtfsFavouriteKeyInputErrorMessageElement.setAttribute("hidden", "");
					
					gtfsFavouriteKeyLabelElement.append(gtfsFavouriteKeyInputElement);
					gtfsFavouriteKeyLabelElement.append(gtfsFavouriteKeyInputValidationElement);
					gtfsFavouriteKeyLabelElement.append(gtfsFavouriteKeyInputErrorMessageElement);
					
					var submitButtonElementWrapper = document.createElement("div");
					submitButtonElementWrapper.setAttribute("class", "contentItem flexContainer rightJustifiedContent");
					
					var submitButtonElement = document.createElement("button");
					submitButtonElement.setAttribute("type", "submit");
					submitButtonElement.setAttribute("value", "confirm");
					submitButtonElement.setAttribute("form", this.#ADD_GTFS_FAVOURITE_FORM_NAME);
					submitButtonElement.setAttribute("style", "margin-top: 0px; flex: 1;");
					submitButtonElement.textContent = "Add to favourites";
					
					submitButtonElementWrapper.append(submitButtonElement);
					
					this.append(introMessageElement);
					this.append(gtfsFavouriteKeyLabelElement);
					this.append(submitButtonElementWrapper);
				}
			} catch (error) {
				console.error(error);
			}
		};
		
		constructor() {
			super();
		}
		
		async connectedCallback() {
			this.#isConnected = true;
			
			var addGTFSFavouriteFormElement = document.createElement("form");
			addGTFSFavouriteFormElement.setAttribute("id", this.#ADD_GTFS_FAVOURITE_FORM_NAME);
			addGTFSFavouriteFormElement.setAttribute("name", this.#ADD_GTFS_FAVOURITE_FORM_NAME);
			addGTFSFavouriteFormElement.setAttribute("method", "GET");
			addGTFSFavouriteFormElement.setAttribute("action", "/");  //??? add in a proper crash landing page, not just the homepage
			
			addGTFSFavouriteFormElement.addEventListener("submit", e => {
				//GUARD: do nothing if there is no target Favourite URL
				if (getType(this.#targetFavURLString) !== getType.string) {
					e.preventDefault();
					return false;
				}
				
				if (this.#targetFavURLString === "") {
					e.preventDefault();
					return false;
				}
				
				var target = e.target;
				
				var gtfsFavouriteKeyInputElement = target.elements["gtfsFavouriteKey"];  //??? hardcoded, need to remove hardcoding
				
				var gtfsFavouriteKey = gtfsFavouriteKeyInputElement.value;
				
				var formattedGTFSFavouriteKey = this.#formatKeyWithStorageNamespace(gtfsFavouriteKey);
				
				//??? check if both the key and the value are valid?
				PersistentStorage.setItem(formattedGTFSFavouriteKey, this.#targetFavURLString);  //??? setup error messaging if this fails?
				
				var parentDialogElement = this.closest("dialog");
				parentDialogElement && parentDialogElement.close();
				
				e.preventDefault();
				return false;
			});
			
			if (window.GTFS) {
				try {
					var [allGTFSRouteLinesByNumber, allGTFSStopNamesByNumber, allGTFSStationNamesByNumber] = await Promise.all([
						fetchGTFSRouteLinesByNumber
						, fetchGTFSStopNamesByNumber
						, fetchGTFSStationNamesByNumber
					]);
					
					this.#targetGTFSItemNumber = window.GTFS.lineNumber || window.GTFS.routeNumber || window.GTFS.stopNumber || window.GTFS.stationId;
					
					if (GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME.has(this.#targetGTFSItemNumber) === true) {
						this.#targetGTFSItemName = `${GTFS_ROUTELINE_NAMES_AND_NUMBERS_TO_NAME.get(this.#targetGTFSItemNumber)} {direction}`;
						
						this.#gtfsItemType = "LINE";
					} else if (allGTFSRouteLinesByNumber.has(this.#targetGTFSItemNumber) === true) {
						this.#targetGTFSItemName = `${this.#targetGTFSItemNumber} {direction}`;
						
						this.#gtfsItemType = "ROUTE";
					} else if (allGTFSStopNamesByNumber.has(this.#targetGTFSItemNumber) === true) {
						this.#targetGTFSItemName = allGTFSStopNamesByNumber.get(this.#targetGTFSItemNumber);
						
						this.#gtfsItemType = "STOP";
					} else if (allGTFSStationNamesByNumber && allGTFSStationNamesByNumber.has(this.#targetGTFSItemNumber) === true) {
						this.#targetGTFSItemName = allGTFSStationNamesByNumber.get(this.#targetGTFSItemNumber);
						
						this.#gtfsItemType = "STATION";
					} else {
						//??? this is a hack to run the "Add Station" user flow correctly because the iOS TLA bug leads to the "allGTFSStationNamesByNumber" variable being undefined
						if (!allGTFSStationNamesByNumber) {
							if (getType(window.GTFS.stationId) === getType.string) {
								this.#targetGTFSItemName = window.GTFS.stationName || "";
								
								this.#gtfsItemType = "STATION";
							}
							
							//??? log error
							
						} else {
							//??? unexpected error
						}
					}
				} catch (error) {
					console.error(error);
				}
			}
			
			//every time this element appears onscreen, we will handle the current URL LatLng.  While the element is onscreen, the target URL LatLng will not change.  We will only handle a new URL LatLng after the element is hidden/closed and then becomes visible/opened again.  //??? update message to not only be talking about LatLng
			var isOnscreenObserver = new IntersectionObserver(entries => {
				entries.forEach(entry => {
					if (entry.intersectionRatio > 0) {
						this.#render();
						
						this.append(addGTFSFavouriteFormElement);
					} else {
						this.#targetFavURLString = "";
						this.#targetFavURLIsLatLng = false;
						
						window.deleteAllChildNodes && window.deleteAllChildNodes(this);
						
						//??? add "loading" message here so you see it on next open?
					}
				});
			});
			
			isOnscreenObserver.observe(this);
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-lat-key":
					; (() => {
						if (this.#isConnected === false) {
							this.#latURLSearchParameterKey = curValue;  //??? validate?
						}
					})();
					
					break;
				case "data-lng-key":
					; (() => {
						if (this.#isConnected === false) {
							this.#lngURLSearchParameterKey = curValue;  //??? validate?
						}
					})();
					
					break;
				case "data-distance-in-metres-key":
					; (() => {
						if (this.#isConnected === false) {
							this.#distanceInMetresURLSearchParameterKey = curValue;  //??? validate?
						}
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="gtfsfavouritemanager">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { PersistentStorage } from "https://tlweblibs.translink.ca/PersistentStorage-2.0.1.mjs";
	
	customElements.define("gtfs-favourite-manager", class GTFSFavouriteManager extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-target-gtfs-favourite"
			];
		}
		
		#EDIT_GTFS_FAVOURITE_FORM_NAME = "editGTFSFavourite";
		#STORAGE_NAMESPACE = "V3GTFSFavourites";
		
		#targetGTFSFavouriteName;
		
		#formatKeyWithStorageNamespace = key => {
			//??? check that key is actually a string?
			var output = `${this.#STORAGE_NAMESPACE}.${key}`;
			
			return output;
		};
		
		#render() {
			//GUARD: do nothing if there is no target GTFS favourite
			if (getType(this.#targetGTFSFavouriteName) !== getType.string) {
				return;
			}
			
			var gtfsFavouriteName = this.#targetGTFSFavouriteName;
			
			var namespacedGTFSFavouriteName = this.#formatKeyWithStorageNamespace(gtfsFavouriteName);
			
			var targetGTFSFavouriteURLString = PersistentStorage.getItem(namespacedGTFSFavouriteName);
			
			var targetGTFSFavouriteURL = targetGTFSFavouriteURLString && new URL(targetGTFSFavouriteURLString, document.location.origin);
			
			//GUARD: do nothing if there is no Favourite URL
			if (getType(targetGTFSFavouriteURL) !== getType.url) {
				return;
			}
			
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			
			var editGTFSFavouriteFormElement = document.createElement("form");
			editGTFSFavouriteFormElement.setAttribute("id", this.#EDIT_GTFS_FAVOURITE_FORM_NAME);
			editGTFSFavouriteFormElement.setAttribute("name", this.#EDIT_GTFS_FAVOURITE_FORM_NAME);
			editGTFSFavouriteFormElement.setAttribute("method", "GET");
			editGTFSFavouriteFormElement.setAttribute("action", "/");  //??? add in a proper crash landing page, not just the homepage
			
			var gtfsFavouriteNameLabelElement = document.createElement("label");
			gtfsFavouriteNameLabelElement.textContent = "Name";
			
			var gtfsFavouriteNameInputElement = document.createElement("input");
			gtfsFavouriteNameInputElement.setAttribute("type", "text");
			gtfsFavouriteNameInputElement.setAttribute("form", this.#EDIT_GTFS_FAVOURITE_FORM_NAME);
			gtfsFavouriteNameInputElement.setAttribute("name", "curFavouriteName");  //??? need to unhardcode this
			gtfsFavouriteNameInputElement.setAttribute("id", "curFavouriteName");
			gtfsFavouriteNameInputElement.setAttribute("aria-errormessage", "curFavouriteName_error-msg");  //??? is this supposed to be done manually?
			gtfsFavouriteNameInputElement.setAttribute("required", "");
			gtfsFavouriteNameInputElement.setAttribute("value", gtfsFavouriteName);
			
			var gtfsFavouriteNameValidationTextElement = document.createElement("small");
			gtfsFavouriteNameValidationTextElement.setAttribute("aria-hidden", true);
			gtfsFavouriteNameValidationTextElement.textContent = "Required";
			
			var gtfsFavouriteNameErrorMessageElement = document.createElement("output");
			gtfsFavouriteNameErrorMessageElement.setAttribute("role", "alert");
			gtfsFavouriteNameErrorMessageElement.setAttribute("form", this.#EDIT_GTFS_FAVOURITE_FORM_NAME);
			gtfsFavouriteNameErrorMessageElement.setAttribute("aria-live", "polite");
			gtfsFavouriteNameErrorMessageElement.setAttribute("id", "curFavouriteName_error-msg");
			gtfsFavouriteNameErrorMessageElement.setAttribute("hidden", "");
			
			gtfsFavouriteNameLabelElement.append(gtfsFavouriteNameInputElement);
			gtfsFavouriteNameLabelElement.append(gtfsFavouriteNameValidationTextElement);
			gtfsFavouriteNameLabelElement.append(gtfsFavouriteNameErrorMessageElement);
			
			var actionBarWrapperElement = document.createElement("div");
			actionBarWrapperElement.setAttribute("class", "flexContainer fullyJustifiedContent contentItem");
			actionBarWrapperElement.setAttribute("style", "flex-direction: row-reverse; gap: 1rem;");
			
			var saveGTFSFavouriteButton = document.createElement("button");
			saveGTFSFavouriteButton.setAttribute("type", "submit");
			saveGTFSFavouriteButton.setAttribute("value", "confirm");
			saveGTFSFavouriteButton.setAttribute("form", this.#EDIT_GTFS_FAVOURITE_FORM_NAME);
			saveGTFSFavouriteButton.setAttribute("style", "margin-top: 0px; flex: 1;");
			saveGTFSFavouriteButton.textContent = "Save";
			
			var deleteGTFSFavouriteButton = document.createElement("button");
			deleteGTFSFavouriteButton.setAttribute("type", "submit");
			deleteGTFSFavouriteButton.setAttribute("value", "delete");
			deleteGTFSFavouriteButton.setAttribute("form", this.#EDIT_GTFS_FAVOURITE_FORM_NAME);
			deleteGTFSFavouriteButton.setAttribute("formnovalidate", "");
			deleteGTFSFavouriteButton.setAttribute("style", "margin-top: 0px; flex: 1;");
			deleteGTFSFavouriteButton.textContent = "Delete";
			
			actionBarWrapperElement.append(saveGTFSFavouriteButton);
			actionBarWrapperElement.append(deleteGTFSFavouriteButton);
			
			this.append(gtfsFavouriteNameLabelElement);
			this.append(actionBarWrapperElement);
			this.append(editGTFSFavouriteFormElement);
			
			//??? at risk of INP failures because there is no UI update mechanism here and there are long tasks to PersistentStorage
			editGTFSFavouriteFormElement.addEventListener("submit", e => {
				var submitterButtonElement = window.bestEffort_GetFormSubmitter(e);
				
				var submitActionType = submitterButtonElement && submitterButtonElement.getAttribute("value");
				
				switch (submitActionType.toLowerCase()) {
					case "confirm":
						; (() => {
							try {
								var gtfsFavouriteName = this.#targetGTFSFavouriteName;
								
								var namespacedGTFSFavouriteName = this.#formatKeyWithStorageNamespace(gtfsFavouriteName);
								
								var targetGTFSFavouriteURLString = PersistentStorage.getItem(namespacedGTFSFavouriteName);
								
								var targetGTFSFavouriteURL = targetGTFSFavouriteURLString && new URL(targetGTFSFavouriteURLString, document.location.origin);
								
								//GUARD: do nothing if there is no Favourite URL
								if (getType(targetGTFSFavouriteURL) !== getType.url) {
									return;
								}
								
								var targetForm = e.target;
								
								var targetFormFields = targetForm && targetForm.elements;
								
								var gtfsFavouriteNameInputElement = targetFormFields && targetFormFields["curFavouriteName"];  //??? is there any way to unhardcode?
								
								var newGTFSFavouriteName = gtfsFavouriteNameInputElement && gtfsFavouriteNameInputElement.value;
								
								//??? GUARD: what do we do if we can't find the new GTFS Favourite Name in the UI?
								
								var namespacedNewGTFSFavouriteName = this.#formatKeyWithStorageNamespace(newGTFSFavouriteName);
								
								//??? "PersistentStorage.mjs" should be updated to support "hasItem"...
								var newGTFSFavouriteURLString = PersistentStorage.getItem(namespacedNewGTFSFavouriteName);  
								
								//GUARD: do nothing if the new Favourite name is already used
								//??? is this really correct behavior or should we show an error message to the user?
								if (getType(newGTFSFavouriteURLString) !== getType.undefined) {
									return;
								}
								
								PersistentStorage.setItem(namespacedNewGTFSFavouriteName, targetGTFSFavouriteURLString);
								PersistentStorage.removeItem(namespacedGTFSFavouriteName);  //??? why am I making this call right here?  shouldn't I be calling the a general helper since this is exactly what the "delete" path does?
								
								//??? is it always appropriate to close the popup immediately?
								var parentDialogElement = this.closest("dialog");
								parentDialogElement && parentDialogElement.close();
								
								var updatedGTFSFavouriteEvent = new CustomEvent("change-gtfs-favourite", {
									detail: {
										old: namespacedGTFSFavouriteName
										, new: namespacedNewGTFSFavouriteName
									}
									, bubbles: true
									, cancelable: true
								});
								
								this.dispatchEvent(updatedGTFSFavouriteEvent);
							} catch (error) {
								console.error(error);
								
								//??? do we close the dialog if there is an error?
							}
						})();
						
						break;
					case "delete":
						; (() => {
							var gtfsFavouriteName = this.#targetGTFSFavouriteName;
							
							var namespacedGTFSFavouriteName = this.#formatKeyWithStorageNamespace(gtfsFavouriteName);
							
							var deletedGTFSFavouriteName = PersistentStorage.removeItem(namespacedGTFSFavouriteName);
							
							if (getType(deletedGTFSFavouriteName) === getType.undefined) {
								//??? added error logging because an undefined return value means nothing was deleted
							}
							
							var parentDialogElement = this.closest("dialog");
							parentDialogElement && parentDialogElement.close();
							
							var deletedGTFSFavouriteEvent = new CustomEvent("delete-gtfs-favourite", {
								detail: namespacedGTFSFavouriteName
								, bubbles: true
								, cancelable: true
							});
							
							this.dispatchEvent(deletedGTFSFavouriteEvent);
						})();
						
						break;
					default:
						; (() => {
							//??? add error logging?
						})();
						
						break;
				}
				
				e.preventDefault();
				return false;
			});
		};
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			//??? need to show some sort of error/loading message?
			
			//delete the content every time the element is off-screen, so we don't see the previous session's data.
			var isOnscreenObserver = new IntersectionObserver(entries => {
				entries.forEach(entry => {
					if (entry.intersectionRatio > 0) {
						this.#render();
					} else {
						window.deleteAllChildNodes && window.deleteAllChildNodes(this);
						
						//??? add "loading" message here so you see it on next open?
					}
				});
			});
			
			isOnscreenObserver.observe(this);
			
			this.#render();
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-target-gtfs-favourite":
					; (() => {
						this.#targetGTFSFavouriteName = curValue;  //??? validate?
						
						this.#render();
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script type="module" class="mygtfsfavourites">
	import { getType } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { PersistentStorage } from "https://tlweblibs.translink.ca/PersistentStorage-2.0.1.mjs";
	
	customElements.define("my-gtfs-favourites", class MyGTFSFavourites extends HTMLElement {
		static get observedAttributes() {
			return [];
		}
		
		#STORAGE_NAMESPACE = "V3GTFSFavourites";
		
		#render() {
			window.deleteAllChildNodes && window.deleteAllChildNodes(this);
			
			var allFavouriteElements = PersistentStorage.getAllKeys()
			.filter(curKey => {
				if (curKey.startsWith(this.#STORAGE_NAMESPACE) === true) {
					return true;
				}
				
				return false;
			})
			.map(curFavouriteName => {
				try {
					var targetFavouriteURLString = PersistentStorage.getItem(curFavouriteName);
					
					var targetFavouriteURL = targetFavouriteURLString && new URL(targetFavouriteURLString, document.location.origin);
					
					//GUARD: do nothing if there is no Favourite URL
					if (getType(targetFavouriteURL) !== getType.url) {
						return;
					}
					
					/*
						REGEX
						
						replaceAll(`${this.#STORAGE_NAMESPACE}.`, "") - remove the storage namespace key 
						replace(/\//g, "/&#8203;"); - insert a ZERO WIDTH SPACE after every "/" as a line-break
						
					*/
					
					var formattedCurFavouriteName = curFavouriteName
					.replaceAll(`${this.#STORAGE_NAMESPACE}.`, "")
					.replace(/\//g, "/&#8203;");
					
					var favouriteElement = document.createElement("li");
					favouriteElement.setAttribute("class", "useButton");
					favouriteElement.setAttribute("style", "margin-top: 1rem !important;");
					
					var favouriteElementContent = document.createElement("a");
					favouriteElementContent.setAttribute("href", targetFavouriteURL);
					favouriteElementContent.setAttribute("class", "verticallyCenteredItem");
					favouriteElementContent.setAttribute("style", "width: fit-content;");
					favouriteElementContent.innerHTML = formattedCurFavouriteName;  //??? need to stop using innerHTML
					
					var favouriteElementEditButton = document.createElement("button");
					favouriteElementEditButton.setAttribute("type", "button");
					favouriteElementEditButton.setAttribute("data-infowindow", "Edit Favourite");  //??? we need to unhardcode "Edit Favourite"
					favouriteElementEditButton.setAttribute("data-no-infowindow-icon", "");
					favouriteElementEditButton.setAttribute("class", "topAlignedItem");
					favouriteElementEditButton.setAttribute("style", "margin-top: 0px;");
					favouriteElementEditButton.textContent = "Edit";
					
					favouriteElement.append(favouriteElementContent);
					favouriteElement.append(favouriteElementEditButton);
					
					favouriteElementEditButton.addEventListener("click", e => {
						var targetEditFavouriteModal = document.querySelector('dialog[data-infowindow-name="Edit Favourite"]');  //??? we need to unhardcode "Edit Favourite"
						
						//GUARD: do nothing if there is no Edit Favourite modal
						if (!targetEditFavouriteModal) {
							return;
						}
						
						var targetFavouriteEditor = targetEditFavouriteModal.querySelector("gtfs-favourite-manager");
						
						//GUARD: do nothing if there is no Favourite Editor
						if (!targetFavouriteEditor) {
							return;
						}
						
						targetFavouriteEditor.setAttribute("data-target-gtfs-favourite", formattedCurFavouriteName);
					});
					
					return favouriteElement;
				} catch (error) {
					console.error(error);
				}
			});
			
			if (allFavouriteElements.length > 0) {
				var addMoreFavouritesMessageElement = document.createElement("p");
				addMoreFavouritesMessageElement.textContent = `Select the "Edit" button to delete or rename a favourite. Add additional favourites by searching for a mode or bus route name/number. Once you've located the service you're looking for, you may add it as a favourite from the specific page for that service.`;
				
				var favouriteElementsContainer = document.createElement("ul");
				favouriteElementsContainer.setAttribute("style", "margin: 0px; padding: 0px;");
				
				allFavouriteElements.forEach(curFavouriteElement => {
					favouriteElementsContainer.append(curFavouriteElement);
				});
				
				this.append(addMoreFavouritesMessageElement);
				this.append(favouriteElementsContainer);
			} else {
				var noFavouritesMessageElement = document.createElement("p");
				noFavouritesMessageElement.textContent = "Oops, it looks like you don't have any favourites. Add favourites by searching for a mode or bus route name/number. Once you've located the service you're looking for, you may add it as a favourite from the specific page for that service.";
				
				this.append(noFavouritesMessageElement);
			}
		};
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			this.#render();
			
			//??? attached a event listener for a custom "favourites_changed" event and call 'this.#render()'
			
			window.addEventListener("change-gtfs-favourite", e => {
				this.#render();
			});
			
			window.addEventListener("delete-gtfs-favourite", e => {
				this.#render();
			});
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {}
	});
</script><script type="module" class="jobPostings">
	import { isValidDate } from "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
	import { buildDashDelimitedDateStringFromDateString } from "https://tlweblibs.translink.ca/DateTimeStringHelpers-1.1.0.mjs";
		const JOB_POSTINGS_MODULE_URL_STRING = "https://tlweblibs.translink.ca/jobPostings-1.0.0.mjs";
	
	customElements.define("job-postings", class JobPostings extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-operating-company"
				, "data-replaceable-closing-date-strings"
				, "data-include-job-ids"
			];
		}
		
		#operatingCompanyAliases = new Map();
		
		#operatingCompany;
		#replaceableClosingDateStrings = [];
		#includedJobIDs;
		
		#defaultClosingDateString = "Open until filled";
		
		constructor() {
			super();
			
			this.#operatingCompanyAliases.set("tl", "001");
			this.#operatingCompanyAliases.set("cmbc", "BCT");
			this.#operatingCompanyAliases.set("bcrtc", "BCR");
			this.#operatingCompanyAliases.set("wce", "WCE");
			this.#operatingCompanyAliases.set("tp", "TSM");
		}
		
		async connectedCallback() {
			try {
				var jobPostingsModuleURL = JOB_POSTINGS_MODULE_URL_STRING && new URL(JOB_POSTINGS_MODULE_URL_STRING);
				
				var { fetchAllJobPostings } = jobPostingsModuleURL && await import(jobPostingsModuleURL);
				
				var allJobPostings = fetchAllJobPostings && await fetchAllJobPostings;
				
				//GUARD: do nothing if there are no jobPostings
				if (Array.isArray(allJobPostings) === false) {
					return;
				}
				
				var todayDate = new Date();
				todayDate.setHours(6);
				todayDate.setMinutes(0);
				todayDate.setSeconds(0);
				todayDate.setMilliseconds(0);
				
				allJobPostings = allJobPostings
				.filter(curJobPosting => {
					var curJobPostingOperatingCompany = curJobPosting.company;
					
					return curJobPostingOperatingCompany === this.#operatingCompany;
				})
				.filter(curJobPosting => {
					/*
						We will only show a job posting if the start and end dates meet all of the following rules:
						
						- there must be a start Date
						- the current date must be on or after that start Date
						- the current date must be on or before the end Date (if there is an end Date)
					*/
					
					var curJobPostingStartDate = new Date(curJobPosting.startDate);
					
					if (isValidDate(curJobPostingStartDate) === false) {
						return false;
					}
					
					curJobPostingStartDate.setUTCHours(10);
					curJobPostingStartDate.setUTCMinutes(0);
					curJobPostingStartDate.setUTCSeconds(0);
					curJobPostingStartDate.setUTCMilliseconds(0);
					
					if (todayDate < curJobPostingStartDate) {
						return false;
					}
					
					var curJobPostingEndDate = new Date(curJobPosting.endDate);
					
					if (isValidDate(curJobPostingEndDate) === true) {
						curJobPostingEndDate.setUTCHours(16);
						curJobPostingEndDate.setUTCMinutes(0);
						curJobPostingEndDate.setUTCSeconds(0);
						curJobPostingEndDate.setUTCMilliseconds(0);
						
						if (todayDate > curJobPostingEndDate) {
							return false;
						}
					}
					
					return true;
				});
				
				if (this.#includedJobIDs && this.#includedJobIDs.length > 0) {
					allJobPostings = allJobPostings.filter(curJobPosting => {
						var curJobPostingURLString = curJobPosting.url;  //??? check if it is a string?  //??? use URL Object Pattern
						var curJobPostingURL = curJobPostingURLString && new URL(curJobPostingURLString);
						
						var curJobPostingID = curJobPostingURL && curJobPostingURL.searchParams.get("JobOpeningId");
						
						return curJobPostingID && this.#includedJobIDs.includes(curJobPostingID) === true;
					});
				}
				
				//GUARD: do nothing if there are no job postings
				if (allJobPostings.length === 0) {
					return;
				}
				
				var memoizedDates = new Map();  //??? this should be refactored out so these objects can be reused
				
				allJobPostings.sort((lhs, rhs) => {
					if (!lhs.startDate && !rhs.startDate) {
						return 0;
					} else if (!lhs.startDate) {
						return 1;
					} else if (!rhs.startDate) {
						return -1;
					}
					
					var lhsDate = memoizedDates.get(lhs.startDate) || new Date(lhs.startDate);
					var rhsDate = memoizedDates.get(rhs.startDate) || new Date(rhs.startDate);
					
					//GUARD: do nothing is lhsDate is not valid
					if (isValidDate(lhsDate) === false) {
						return 0;
					}
					
					memoizedDates.set(lhs.startDate, lhsDate);
					
					//GUARD: do nothing is rhsDate is not valid
					if (isValidDate(rhsDate) === false) {
						return 0;
					}
					
					memoizedDates.set(rhs.startDate, rhsDate);
					
					if (lhsDate === rhsDate) {
						return 0;
					} else if (lhsDate < rhsDate) {
						return 1;
					} else if (lhsDate > rhsDate) {
						return -1;
					}
					
					return 0; //NOTE: this should never run, but returning a 'default value' for safety
				});
				
				//create and store <table> element
				var jobPostingsTableElement = document.createElement("table");
				
				var jobPostingsTableHeaderElement = document.createElement("thead");
				
				var jobPostingsTableHeadersWrapperElement = document.createElement("tr");
				
				var jobPostingsJobTitleHeaderElement = document.createElement("th");
				jobPostingsJobTitleHeaderElement.textContent = "Job Title";  //??? remove hardcoding
				
				var jobPostingsPostedDateHeaderElement = document.createElement("th");
				jobPostingsPostedDateHeaderElement.textContent = "Posted Date";  //??? remove hardcoding
				
				var jobPostingsClosingDateHeaderElement = document.createElement("th");
				jobPostingsClosingDateHeaderElement.textContent = "Closing Date";  //??? remove hardcoding
				
				jobPostingsTableHeadersWrapperElement.append(jobPostingsJobTitleHeaderElement);
				jobPostingsTableHeadersWrapperElement.append(jobPostingsPostedDateHeaderElement);
				jobPostingsTableHeadersWrapperElement.append(jobPostingsClosingDateHeaderElement);
				
				jobPostingsTableHeaderElement.append(jobPostingsTableHeadersWrapperElement);
				
				var jobPostingsTableBodyElement = document.createElement("tbody");
				
				jobPostingsTableElement.append(jobPostingsTableHeaderElement);
				jobPostingsTableElement.append(jobPostingsTableBodyElement);
				
				allJobPostings.forEach(curJobPosting => {
					var jobTitle = curJobPosting.title;
					jobTitle = jobTitle && jobTitle.trim();
					
					var jobLink = curJobPosting.url;  //??? replace with URL Object Pattern
					
					var postedDateDashDelimitedDateString = curJobPosting.startDate && buildDashDelimitedDateStringFromDateString(curJobPosting.startDate);
					var closingDateString = curJobPosting.endDate;
					closingDateString = closingDateString && closingDateString.trim();
					var closingDate = closingDateString && memoizedDates.get(closingDateString);
					
					var jobPostingElement = document.createElement("tr");
					
					var jobPostingLinkElementWrapper = document.createElement("td");
					
					var jobPostingLinkElement = document.createElement("a");
					jobPostingLinkElement.setAttribute("href", jobLink);  //??? replace with URL Object Pattern
					jobPostingLinkElement.setAttribute("title", `Link to '${jobTitle}' job description on careers.translink.bc.ca - opens in a new window`);
					jobPostingLinkElement.setAttribute("target", "_blank");
					jobPostingLinkElement.textContent = jobTitle;
					
					jobPostingLinkElementWrapper.append(jobPostingLinkElement);
					
					var jobPostingPostedDateElementWrapper = document.createElement("td");
					
					var jobPostingPostedDateElement = document.createElement("time");
					jobPostingPostedDateElement.setAttribute("datetime", postedDateDashDelimitedDateString);
					jobPostingPostedDateElement.setAttribute("style", "white-space: nowrap;");
					jobPostingPostedDateElement.textContent = postedDateDashDelimitedDateString;
					
					jobPostingPostedDateElementWrapper.append(jobPostingPostedDateElement);
					
					var jobPostingClosingDateElementWrapper = document.createElement("td");
					
					var jobPostingClosingDateElement;
					
					if (closingDate && isValidDate(closingDate) === true) {
						var formattedClosingDateString = buildDashDelimitedDateStringFromDateString(closingDate.toString());
						
						jobPostingClosingDateElement = document.createElement("time");
						jobPostingClosingDateElement.setAttribute("datetime", formattedClosingDateString);
						jobPostingClosingDateElement.setAttribute("style", "white-space: nowrap;");
						jobPostingClosingDateElement.textContent = formattedClosingDateString;
					} else {
						jobPostingClosingDateElement = document.createElement("span");
						jobPostingClosingDateElement.setAttribute("style", "white-space: nowrap;");
						jobPostingClosingDateElement.textContent = this.#replaceableClosingDateStrings.includes(closingDateString) === false && closingDateString || this.#defaultClosingDateString.trim();
					}
					
					jobPostingClosingDateElement && jobPostingClosingDateElementWrapper.append(jobPostingClosingDateElement);
					
					jobPostingElement.append(jobPostingLinkElementWrapper);
					jobPostingElement.append(jobPostingPostedDateElementWrapper);
					jobPostingElement.append(jobPostingClosingDateElementWrapper);
					
					jobPostingsTableBodyElement.append(jobPostingElement);
				});
				
				window.deleteAllChildNodes && window.deleteAllChildNodes(this);
				
				this.append(jobPostingsTableElement);  //??? maybe only append on lazyload?
			} catch (error) {
				console.error(error);
			}
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-operating-company":
					; (() => {
						this.#operatingCompany = this.#operatingCompanyAliases.get(curValue) || curValue; //??? resolve alias mapping here
					})();
					
					break;
				case "data-replaceable-closing-date-strings":
					; (() => {
						this.#replaceableClosingDateStrings = curValue.split(",");
					})();
					
					break;
				case "data-include-job-ids":
					; (() => {
						this.#includedJobIDs = curValue.split(",");
					})();
					
					break;
				case "data-default-closing-date":
					; (() => {
						this.#defaultClosingDateString = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="aria-polyfill-106">
	; (() => {
		var convertKeyPressToClick = e => {
			var target = e.target;
			
			if (e.keyCode === KEYCODE.ENTER && target.tagName !== "BUTTON" || e.keyCode === KEYCODE.SPACE && target.tagName !== "BUTTON") {
				target.click();
			}
		};
		
		var args = [convertKeyPressToClick];
		
		; (convertKeyPressToClick => {
			var bodyElement = document.querySelector("body");
			
			//GUARD: do nothing if the body element wasn't found
			if (!bodyElement) {
				return;
			}
			
			var targetSelector = [
				".no-details summary[aria-expanded]"
				, "*:not(summary)[aria-expanded]"
				, "[aria-selected]"
			].join(", ");
			
			targetSelector.length > 0 && bodyElement.addEventListener("keydown", e => {
				var target = e.target;
				
				var isTargetAMatch = target.matches(targetSelector);
				
				if (isTargetAMatch === true) {
					convertKeyPressToClick && convertKeyPressToClick(e);
				}
			});
		}).apply(null, args);
	})();
	
	; (() => {
		var toggleAriaExpanded = target => {
			if (target.getAttribute("aria-expanded") === "false") {
				target.setAttribute("aria-expanded", true);
			} else {
				target.setAttribute("aria-expanded", false);
			}
		};
		
		var toggleAriaExpandedOnClick = e => {
			toggleAriaExpanded(e.target);
		};
		
		var args = [toggleAriaExpandedOnClick];
		
		; (toggleAriaExpandedOnClick => {
			var bodyElement = document.querySelector("body");
			
			//GUARD: do nothing if the body element wasn't found
			if (!bodyElement) {
				return;
			}
			
			var targetSelector = [
				"[aria-expanded]"
			].join(", ");
			
			targetSelector.length > 0 && bodyElement.addEventListener("click", e => {
				var target = e.target;
				
				var isTargetAMatch = target.matches(targetSelector);
				
				if (isTargetAMatch === true) {
					toggleAriaExpandedOnClick && toggleAriaExpandedOnClick(e);
				}
			});
		}).apply(null, args);
	})();
	
	; (() => {
		var toggleAriaSelected = target => {
			//for tabs, set all tab siblings to false
			if (target.getAttribute("role") === "tab") {
				var tabListContainer = target.closest('[role="tablist"]');
				var tabListChildren = tabListContainer && tabListContainer.querySelectorAll('[role="tab"]');
				var tabPanels = (() => {
					var output = [];
					
					var nextCandidateTabPanel = tabListContainer.nextElementSibling;
					
					while (nextCandidateTabPanel && nextCandidateTabPanel.hasAttribute("role") && nextCandidateTabPanel.getAttribute("role") === "tabpanel") {
						output.push(nextCandidateTabPanel);
						
						nextCandidateTabPanel = nextCandidateTabPanel.nextElementSibling;
					}
					
					return output;
				})();
				
				tabListChildren && tabListChildren.forEach(curTabListChild => {
					curTabListChild.setAttribute("aria-selected", false);
				});
				
				tabPanels && tabPanels.forEach(curTabPanel => {
					curTabPanel.setAttribute("hidden", "");
				});
				
				makeAriaControlTabbable(target);
			}
			
			if (target.tagName === "OPTION") {
				//??? could this be replaced by fieldsync??
				var tabListContainer = target.closest("select");
				var tabListChildren = tabListContainer && tabListContainer.querySelectorAll("option");
				
				tabListChildren && tabListChildren.forEach(curTabListChild => {
					curTabListChild.setAttribute("aria-selected", false);
				});
				
				target.parentElement.selectedIndex = target.index;  //set target as the selected option
			}
			//??? END of REQUEST TO REFACTOR
			
			target.setAttribute("aria-selected", true);
		};
		
		var updateAriaControlsTarget = target => {
			//GUARD: stop immediately if no control target was found
			if (!target) {
				return;
			}
			
			target.setAttribute("tabindex", 0);
			target.removeAttribute("hidden");
		};
		
		var updateAriaSelectedControl = target => {
			var controlTargetID = target.hasAttribute("aria-controls") && target.getAttribute("aria-controls");
			
			//GUARD: stop immediately if no control target ID was found
			if (!controlTargetID || controlTargetID === "") {
				return;
			}
			
			var targetControllers = document.querySelectorAll(`[aria-controls="${controlTargetID}"]`);
			
			var targetControllersLength = targetControllers.length;
			for (var p = 0; p < targetControllersLength; p++) {
				toggleAriaSelected(targetControllers[p]);
			}
			
			var controlTarget = document.getElementById(controlTargetID);
			
			updateAriaControlsTarget(controlTarget);
		};
		
		var makeAriaControlTabbable = target => {
			//for tabs, set all tab siblings to false
			if (target.getAttribute("role") === "tab") {
				var tabListContainer = target.closest('[role="tablist"]');
				var tabListChildren = tabListContainer && tabListContainer.querySelectorAll('[role="tab"]');
				
				tabListChildren && tabListChildren.forEach(curTabListChild => {
					curTabListChild.setAttribute("tabindex", -1);
				});
			}
			//??? END of REQUEST TO REFACTOR
			
			target.setAttribute("tabindex", 0);
			target.focus();
		};
		
		var toggleAriaSelectedOnClick = e => {
			updateAriaSelectedControl(e.target);
		};
		
		var toggleAriaSelectedOnSelection = e => {
			var target = e.target;
			
			var targetOption = target.selectedOptions[0];
			
			targetOption && updateAriaSelectedControl(targetOption);
		};
		
		var toggleTabbableOnKeypress = e => {
			var target = e.target;
			var targetSibling;
			
			var tabListContainer = target.closest('[role="tablist"]');
			var tabListChildren = tabListContainer && tabListContainer.querySelectorAll('[role="tab"]');
			var tabListChildrenLength = tabListChildren && tabListChildren.length;
			
			var targetIndex = [...tabListContainer.children].indexOf(target.parentElement);
			
			var keycode = e.which;
			
			switch (keycode) {
				case KEYCODE.LEFT_ARROW:
				case KEYCODE.UP_ARROW:
					; (() => {
						//GUARD: do not accept any top arrow key presses unless this widget is in vertical mode
						if (keycode === KEYCODE.UP_ARROW && tabListContainer.hasAttribute("aria-orientation") && tabListContainer.getAttribute("aria-orientation") !== "vertical") {
							return;
						}
						
						if (targetIndex > 0) {
							targetSibling = tabListChildren[targetIndex - 1];
						}
						
						if (targetSibling && tabListChildrenLength > 0) {
							makeAriaControlTabbable(targetSibling);
						}
					})();
					
					e.stopPropagation();
					return false;
					
					break;
				case KEYCODE.RIGHT_ARROW:
				case KEYCODE.DOWN_ARROW:
					; (() => {
						//GUARD: do not accept any bottom arrow key presses unless this widget is in vertical mode
						if (keycode === KEYCODE.DOWN_ARROW && tabListContainer.hasAttribute("aria-orientation") && tabListContainer.getAttribute("aria-orientation") !== "vertical") {
							return;
						}
						
						if (targetIndex < tabListChildrenLength) {
							targetSibling = tabListChildren[targetIndex + 1];
						}
						
						if (targetSibling) {
							makeAriaControlTabbable(targetSibling);
						}
						
						e.stopPropagation();
					})();
					
					return false;
					
					break;
				default:
					; (() => {
						
					})();
					
					break;
			}
		};
		
		var args = [toggleAriaSelectedOnClick, toggleAriaSelectedOnSelection, toggleTabbableOnKeypress];
		
		; ((toggleAriaSelectedOnClick, toggleAriaSelectedOnSelection, toggleTabbableOnKeypress) => {
			var bodyElement = document.querySelector("body");
			
			//GUARD: do nothing if the body element wasn't found
			if (!bodyElement) {
				return;
			}
			
			/* toggleAriaSelectedOnClick */
			var ariaSelectedOnClickTargetSelector = [
				'[aria-selected="false"][aria-controls]:not([aria-controls=""])'
			].join(", ");
			
			ariaSelectedOnClickTargetSelector.length > 0 && bodyElement.addEventListener("click", e => {
				var target = e.target;
				
				var isTargetAMatch = target.matches(ariaSelectedOnClickTargetSelector);
				
				if (isTargetAMatch === true) {
					toggleAriaSelectedOnClick && toggleAriaSelectedOnClick(e);
				}
			});
			/* END OF toggleAriaSelectedOnClick */
			
			/* toggleAriaSelectedOnSelection */
			var ariaSelectedOnSelectionTargetSelector = [
				".Tabs > select"
			].join(", ");
			
			ariaSelectedOnSelectionTargetSelector.length > 0 && bodyElement.addEventListener("change", e => {
				var target = e.target;
				
				var isTargetAMatch = target.matches(ariaSelectedOnSelectionTargetSelector);
				
				if (isTargetAMatch === true) {
					toggleAriaSelectedOnSelection && toggleAriaSelectedOnSelection(e);
				}
			});
			/* END OF toggleAriaSelectedOnSelection */
			
			/* toggleTabbableOnKeypress */
			var toggleTabbableOnKeypressTargetSelector = [
				'[role="tab"][tabindex="0"]'
			].join(", ");
			
			toggleTabbableOnKeypressTargetSelector.length > 0 && bodyElement.addEventListener("keydown", e => {
				var target = e.target;
				
				var isTargetAMatch = target.matches(toggleTabbableOnKeypressTargetSelector);
				
				if (isTargetAMatch === true) {
					toggleTabbableOnKeypress && toggleTabbableOnKeypress(e);
				}
			});
			/* END OF toggleTabbableOnKeypress */
		}).apply(null, args);
	})();
</script><script class="aria-polyfill-shame">
	; (() => {
		document.documentElement.addEventListener("click", e => {
			var target = e.target;
			
			var isAriaChecked = target.hasAttribute("aria-checked") && target.getAttribute("aria-checked");
			
			if (isAriaChecked === "true") {
				target.setAttribute("aria-checked", false);
			} else if (isAriaChecked === "false") {
				target.setAttribute("aria-checked", true);
			}
		});
		
		document.documentElement.addEventListener("click", e => {
			var target = e.target;
			
			var isAriaPressed = target.hasAttribute("aria-pressed") && target.getAttribute("aria-pressed");
			
			var hasPopup = target.hasAttribute("aria-haspopup") && target.getAttribute("aria-haspopup");
			
			//GUARD: do nothing if there is a popup because the popup's confirmation prompt will need to set aria-pressed
			if (hasPopup === "true") {
				return;
			}
			
			if (isAriaPressed === "true") {
				target.setAttribute("aria-pressed", false);
			} else if (isAriaPressed === "false") {
				target.setAttribute("aria-pressed", true);
			}
		});
		
		document.documentElement.addEventListener("click", e => {
			var target = e.target;
			
			var isButton = target.tagName === "BUTTON";
			var hasAriaControls = target.hasAttribute("aria-controls");
			var hasAriaExpanded = target.hasAttribute("aria-expanded");
			var hasAriaHasPopup = target.hasAttribute("aria-haspopup");
			
			if (isButton && hasAriaControls === true && hasAriaExpanded === true && hasAriaHasPopup === false) {
				var targetContentElementIDs = target.getAttribute("aria-controls").split(" ");
				
				targetContentElementIDs.forEach(curID => {
					var foundTarget = document.getElementById(curID);
					
					//GUARD: do nothing if the target is a <dialog> because it already controls its own visibility
					if (foundTarget.tagName === "DIALOG") {
						return;
					}
					
					foundTarget && foundTarget.toggleAttribute && foundTarget.toggleAttribute("hidden");
				});
			}
		});
		
		document.documentElement.addEventListener("keydown", e => {
			var target = e.target;
			
			var isLink = target && target.tagName === "A";
			
			var hasButtonRole = target && target.hasAttribute("role") && target.getAttribute("role").toLowerCase() === "button";
			
			if (isLink && hasButtonRole && event.keyCode === KEYCODE.SPACE) {
				target.click();
				e.preventDefault();
			}
		});
	})();
</script><script class="popper-upper">
	customElements.define("popper-upper", class PopperUpper extends HTMLElement {
		static get observedAttributes() {
			return [
				"data-for"
			];
		}
		
		#parentElementID = "";
		
		constructor() {
			super();
		}
		
		connectedCallback() {
			//GUARD: do nothing if there is no parent element id
			if (!this.#parentElementID) {
				return;
			}
			
			var parentElement = document.getElementById(this.#parentElementID);
			
			//GUARD: do nothing if there is no parent element
			if (!parentElement) {
				return;
			}
			
			var popperUpperID;
			
			var hasExistingPopperUpperID = this.hasAttribute("id");
			
			if (hasExistingPopperUpperID === true) {
				popperUpperID = this.getAttribute("id");
			} else {
				popperUpperID = `${this.#parentElementID}_popper_upper`;
				
				this.setAttribute("id", popperUpperID);
			}
			
			this.setAttribute("role", "listbox");
			//this.setAttribute("tabindex", -1);  //??? temporarily disabled until we figure out how to add proper support for <a> in a listbox
			
			parentElement.setAttribute("aria-autocomplete", "list");
			parentElement.setAttribute("aria-controls", popperUpperID);  //??? update to simply append because this attribute is a comma-separated list of IDs?
			parentElement.setAttribute("aria-haspopup", "listbox");
			parentElement.setAttribute("aria-owns", popperUpperID);  //??? update to simply append because this attribute is a comma-separated list of IDs?
			parentElement.setAttribute("aria-activedescendant", popperUpperID);  //??? update to simply append because this attribute is a comma-separated list of IDs?
			
			this.addEventListener("focusout", e => {
				window.setTimeout(() => {
					if (this.contains(document.activeElement) === false) {
						this.style.left = "";
						this.querySelectorAll("a").forEach(curLink => {
							curLink.setAttribute("tabindex", -1);
						});
					}
				}, 0);  //??? is this a code smell?  shold we use requestAnimationFrame instead?
			});
			
			//??? technically, this popup isn't just for text-input-autosuggest right?  it's for dropdowns as well, so we need to detect click-on-dropdowns, not just input-into-searchboxes
			parentElement.addEventListener("input", e => {
				var targetInput = e.target;
				
				if (targetInput.value === "") {
					this.style.left = "";
					this.querySelectorAll("a").forEach(curLink => {
						curLink.setAttribute("tabindex", -1);
					});
				} else {
					this.style.left = "unset";  //??? shouldn't we also check if there are any suggestions?
					this.querySelectorAll("a").forEach(curLink => {
						curLink.removeAttribute("tabindex");
					});
					
					//close popper-upper on page scroll
					window.addEventListener("scroll", e => {  //??? there can be a bunch of "orphaned" callbacks if many popper-uppers are opened, but no scroll events ever run; consider refactoring this callback to also be removed on accordion-close by using AbortControllers
						this.style.left = "";
						this.querySelectorAll("a").forEach(curLink => {
							curLink.setAttribute("tabindex", -1);
						});
					}, { 
						once: true
						, passive: true
					});
				}
			});
			
			parentElement.addEventListener("focusout", e => {
				window.setTimeout(() => {
					if (this.contains(document.activeElement) === false) {
						this.style.left = "";
						this.querySelectorAll("a").forEach(curLink => {
							curLink.setAttribute("tabindex", -1);
						});
					}
				}, 0);  //??? is this a code smell?  shold we use requestAnimationFrame instead?
			});
			
			parentElement.addEventListener("keydown", e => {
				if (e.keyCode === window.KEYCODE.ENTER) {
					this.style.left = "";
					this.querySelectorAll("a").forEach(curLink => {
						curLink.setAttribute("tabindex", -1);
					});
				}
			});
			
			var popperUpperOpeningListener = new IntersectionObserver(entries => {
				entries.forEach(entry => {
					var target = entry.target;
					
					var overlapAmount = entry.intersectionRatio;
					
					//GUARD: do nothing if the element has left the observed region
					if (overlapAmount === 0) {
						return;
					}
					
					const minListboxHeight = 200;  //??? refactor this into a init-variable
					const viewportMargin = 18;  //??? refactor this into a init-variable
					
					var minSpaceBelowPicker = minListboxHeight + viewportMargin;
					
					var spaceBelowPickerInPX = (() => {
						var output = 0;
						
						var viewportHeight = document.documentElement.clientHeight;
						var pickerYCoord = parentElement.getBoundingClientRect().y;
						var pickerHeight = parentElement.offsetHeight;
						
						output = viewportHeight - (pickerYCoord + pickerHeight);
						
						return output;
					})();
					
					var isSmallViewport = window.matchMedia("not all and (min-width: 48em)").matches === true &&  window.matchMedia("(pointer: coarse)").matches === true;
					
					if (isSmallViewport === true) {
						spaceBelowPickerInPX = spaceBelowPickerInPX - (window.innerHeight * 0.5);
					}
					
					var isRenderingUpwards = spaceBelowPickerInPX <= minSpaceBelowPicker;  //??? isn't this calculation wrong?  should we always render in whichever bottom or top area has more space?  this logic issue actually probably starts above this point....
					
					var curHeightInPX = this.offsetHeight;
					var newHeightInPX = 0;
					var newHeightInPXAsString = "";
					
					if (isRenderingUpwards === true) {
						var totalUpwardsSpaceInPX = parentElement.getBoundingClientRect().y;
						var pickerHeight = parentElement.offsetHeight;
						
						newHeightInPX = Math.min(totalUpwardsSpaceInPX - pickerHeight - viewportMargin, this.scrollHeight + 2);
						
						newHeightInPXAsString = `${newHeightInPX}px`;
						
						var newTransformInString = `translateY(calc(-100% + ${pickerHeight * -1}px))`;
						
						this.style.maxHeight = newHeightInPXAsString;
						this.setAttribute("style", `${this.getAttribute("style")}; transform: ${newTransformInString};`);  //NOTE: for some reason, style.transform does not work as a setter, so manually setting the style using setAttribute() instead.  //??? doing .getAttribute() is not great because it could be undefined (in this case, it probably wouldn't happen, but still bad coding practice)
					} else {
						newHeightInPX = Math.min(spaceBelowPickerInPX - viewportMargin, this.scrollHeight + 2);
						newHeightInPXAsString = `${newHeightInPX}px`;
						
						this.style.maxHeight = newHeightInPXAsString;
					}
					
					this.style.opacity = "1";
				});
			});
			
			popperUpperOpeningListener.observe(this);
		}
		
		attributeChangedCallback(attributeName, prevValue, curValue) {
			switch (attributeName) {
				case "data-for":
					; (() => {
						this.#parentElementID = curValue;
					})();
					
					break;
				default:
					; (() => {
						console.error(`An unhandled attribute "${attributeName}" was changed from "${prevValue}" to "${curValue}"`);
					})();
					
					break;
			}
		}
	});
</script><script class="dialog-polyfill-200">
	; (() => {
		var hasNativeDialog = typeof HTMLDialogElement === "function";
		
		var initDialog = dialog => {
			dialogPolyfill.registerDialog(dialog);
			
			dialog.setAttribute("data-is-inited-dialog", true);
		};
		
		var args = [hasNativeDialog, initDialog];
		
		; ((hasNativeDialog, initDialog) => {
			if (hasNativeDialog === true) {
				document.documentElement.classList.add("dialog");
			} else {
				window.injectHTMLTemplateContentInPlace && window.injectHTMLTemplateContentInPlace("dialog-polyfill");
				
				document.documentElement.classList.add("no-dialog");
				
				/* init dialog polyfill */
				!function () { var e = window.CustomEvent; function t(e) { for (; e;) { if ("dialog" === e.localName) return e; e = e.parentElement } return null } function o(e) { e && e.blur && e !== document.body && e.blur() } function i(e, t) { for (var o = 0; o < e.length; ++o)if (e[o] === t) return !0; return !1 } function n(e) { return !(!e || !e.hasAttribute("method")) && "dialog" === e.getAttribute("method").toLowerCase() } function a(e) { if (this.dialog_ = e, this.replacedStyleTop_ = !1, this.openAsModal_ = !1, e.hasAttribute("role") || e.setAttribute("role", "dialog"), e.show = this.show.bind(this), e.showModal = this.showModal.bind(this), e.close = this.close.bind(this), "returnValue" in e || (e.returnValue = ""), "MutationObserver" in window) { new MutationObserver(this.maybeHideModal.bind(this)).observe(e, { attributes: !0, attributeFilter: ["open"] }) } else { var t, o = !1, i = function () { o ? this.downgradeModal() : this.maybeHideModal(), o = !1 }.bind(this), n = function (n) { if (n.target === e) { var a = "DOMNodeRemoved"; o |= n.type.substr(0, a.length) === a, window.clearTimeout(t), t = window.setTimeout(i, 0) } };["DOMAttrModified", "DOMNodeRemoved", "DOMNodeRemovedFromDocument"].forEach(function (t) { e.addEventListener(t, n) }) } Object.defineProperty(e, "open", { set: this.setOpen.bind(this), get: e.hasAttribute.bind(e, "open") }), this.backdrop_ = document.createElement("div"), this.backdrop_.className = "backdrop", this.backdrop_.addEventListener("click", this.backdropClick_.bind(this)) } e && "object" != typeof e || ((e = function (e, t) { t = t || {}; var o = document.createEvent("CustomEvent"); return o.initCustomEvent(e, !!t.bubbles, !!t.cancelable, t.detail || null), o }).prototype = window.Event.prototype), a.prototype = { get dialog() { return this.dialog_ }, maybeHideModal: function () { this.dialog_.hasAttribute("open") && document.body.contains(this.dialog_) || this.downgradeModal() }, downgradeModal: function () { this.openAsModal_ && (this.openAsModal_ = !1, this.dialog_.style.zIndex = "", this.replacedStyleTop_ && (this.dialog_.style.top = "", this.replacedStyleTop_ = !1), this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_), r.dm.removeDialog(this)) }, setOpen: function (e) { e ? this.dialog_.hasAttribute("open") || this.dialog_.setAttribute("open", "") : (this.dialog_.removeAttribute("open"), this.maybeHideModal()) }, backdropClick_: function (e) { if (this.dialog_.hasAttribute("tabindex")) this.dialog_.focus(); else { var t = document.createElement("div"); this.dialog_.insertBefore(t, this.dialog_.firstChild), t.tabIndex = -1, t.focus(), this.dialog_.removeChild(t) } var o = document.createEvent("MouseEvents"); o.initMouseEvent(e.type, e.bubbles, e.cancelable, window, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget), this.dialog_.dispatchEvent(o), e.stopPropagation() }, focus_: function () { var e = this.dialog_.querySelector("[autofocus]:not([disabled])"); if (!e && this.dialog_.tabIndex >= 0 && (e = this.dialog_), !e) { var t = ["button", "input", "keygen", "select", "textarea"].map(function (e) { return e + ":not([disabled])" }); t.push('[tabindex]:not([disabled]):not([tabindex=""])'), e = this.dialog_.querySelector(t.join(", ")) } o(document.activeElement), e && e.focus() }, updateZIndex: function (e, t) { if (e < t) throw new Error("dialogZ should never be < backdropZ"); this.dialog_.style.zIndex = e, this.backdrop_.style.zIndex = t }, show: function () { this.dialog_.open || (this.setOpen(!0), this.focus_()) }, showModal: function () { if (this.dialog_.hasAttribute("open")) throw new Error("Failed to execute 'showModal' on dialog: The element is already open, and therefore cannot be opened modally."); if (!document.body.contains(this.dialog_)) throw new Error("Failed to execute 'showModal' on dialog: The element is not in a Document."); if (!r.dm.pushDialog(this)) throw new Error("Failed to execute 'showModal' on dialog: There are too many open modal dialogs."); (function (e) { for (; e && e !== document.body;) { var t = window.getComputedStyle(e), o = function (e, o) { return !(void 0 === t[e] || t[e] === o) }; if (t.opacity < 1 || o("zIndex", "auto") || o("transform", "none") || o("mixBlendMode", "normal") || o("filter", "none") || o("perspective", "none") || "isolate" === t.isolation || "fixed" === t.position || "touch" === t.webkitOverflowScrolling) return !0; e = e.parentElement } return !1 })(this.dialog_.parentElement) && console.warn("A dialog is being shown inside a stacking context. This may cause it to be unusable. For more information, see this link: https://github.com/GoogleChrome/dialog-polyfill/#stacking-context"), this.setOpen(!0), this.openAsModal_ = !0, r.needsCentering(this.dialog_) ? (r.reposition(this.dialog_), this.replacedStyleTop_ = !0) : this.replacedStyleTop_ = !1, this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling), this.focus_() }, close: function (t) { if (!this.dialog_.hasAttribute("open")) throw new Error("Failed to execute 'close' on dialog: The element does not have an 'open' attribute, and therefore cannot be closed."); this.setOpen(!1), void 0 !== t && (this.dialog_.returnValue = t); var o = new e("close", { bubbles: !1, cancelable: !1 }); this.dialog_.dispatchEvent(o) } }; var r = {}; if (r.reposition = function (e) { var t = document.body.scrollTop || document.documentElement.scrollTop, o = t + (window.innerHeight - e.offsetHeight) / 2; e.style.top = Math.max(t, o) + "px" }, r.isInlinePositionSetByStylesheet = function (e) { for (var t = 0; t < document.styleSheets.length; ++t) { var o = document.styleSheets[t], n = null; try { n = o.cssRules } catch (e) { } if (n) for (var a = 0; a < n.length; ++a) { var r = n[a], l = null; try { l = document.querySelectorAll(r.selectorText) } catch (e) { } if (l && i(l, e)) { var s = r.style.getPropertyValue("top"), d = r.style.getPropertyValue("bottom"); if (s && "auto" !== s || d && "auto" !== d) return !0 } } } return !1 }, r.needsCentering = function (e) { return "absolute" === window.getComputedStyle(e).position && (!("auto" !== e.style.top && "" !== e.style.top || "auto" !== e.style.bottom && "" !== e.style.bottom) && !r.isInlinePositionSetByStylesheet(e)) }, r.forceRegisterDialog = function (e) { if ((window.HTMLDialogElement || e.showModal) && console.warn("This browser already supports <dialog>, the polyfill may not work correctly", e), "dialog" !== e.localName) throw new Error("Failed to register dialog: The element is not a dialog."); new a(e) }, r.registerDialog = function (e) { e.showModal || r.forceRegisterDialog(e) }, r.DialogManager = function () { this.pendingDialogStack = []; var e = this.checkDOM_.bind(this); this.overlay = document.createElement("div"), this.overlay.className = "_dialog_overlay", this.overlay.addEventListener("click", function (t) { this.forwardTab_ = void 0, t.stopPropagation(), e([]) }.bind(this)), this.handleKey_ = this.handleKey_.bind(this), this.handleFocus_ = this.handleFocus_.bind(this), this.zIndexLow_ = 1e5, this.zIndexHigh_ = 100150, this.forwardTab_ = void 0, "MutationObserver" in window && (this.mo_ = new MutationObserver(function (t) { var o = []; t.forEach(function (e) { for (var t, i = 0; t = e.removedNodes[i]; ++i)t instanceof Element && ("dialog" === t.localName && o.push(t), o = o.concat(t.querySelectorAll("dialog"))) }), o.length && e(o) })) }, r.DialogManager.prototype.blockDocument = function () { document.documentElement.addEventListener("focus", this.handleFocus_, !0), document.addEventListener("keydown", this.handleKey_), this.mo_ && this.mo_.observe(document, { childList: !0, subtree: !0 }) }, r.DialogManager.prototype.unblockDocument = function () { document.documentElement.removeEventListener("focus", this.handleFocus_, !0), document.removeEventListener("keydown", this.handleKey_), this.mo_ && this.mo_.disconnect() }, r.DialogManager.prototype.updateStacking = function () { for (var e, t = this.zIndexHigh_, o = 0; e = this.pendingDialogStack[o]; ++o)e.updateZIndex(--t, --t), 0 === o && (this.overlay.style.zIndex = --t); var i = this.pendingDialogStack[0]; i ? (i.dialog.parentNode || document.body).appendChild(this.overlay) : this.overlay.parentNode && this.overlay.parentNode.removeChild(this.overlay) }, r.DialogManager.prototype.containedByTopDialog_ = function (e) { for (; e = t(e);) { for (var o, i = 0; o = this.pendingDialogStack[i]; ++i)if (o.dialog === e) return 0 === i; e = e.parentElement } return !1 }, r.DialogManager.prototype.handleFocus_ = function (e) { if (!this.containedByTopDialog_(e.target) && document.activeElement !== document.documentElement && (e.preventDefault(), e.stopPropagation(), o(e.target), void 0 !== this.forwardTab_)) { var t = this.pendingDialogStack[0]; return t.dialog.compareDocumentPosition(e.target) & Node.DOCUMENT_POSITION_PRECEDING && (this.forwardTab_ ? t.focus_() : e.target !== document.documentElement && document.documentElement.focus()), !1 } }, r.DialogManager.prototype.handleKey_ = function (t) { if (this.forwardTab_ = void 0, 27 === t.keyCode) { t.preventDefault(), t.stopPropagation(); var o = new e("cancel", { bubbles: !1, cancelable: !0 }), i = this.pendingDialogStack[0]; i && i.dialog.dispatchEvent(o) && i.dialog.close() } else 9 === t.keyCode && (this.forwardTab_ = !t.shiftKey) }, r.DialogManager.prototype.checkDOM_ = function (e) { this.pendingDialogStack.slice().forEach(function (t) { -1 !== e.indexOf(t.dialog) ? t.downgradeModal() : t.maybeHideModal() }) }, r.DialogManager.prototype.pushDialog = function (e) { var t = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1; return !(this.pendingDialogStack.length >= t) && (1 === this.pendingDialogStack.unshift(e) && this.blockDocument(), this.updateStacking(), !0) }, r.DialogManager.prototype.removeDialog = function (e) { var t = this.pendingDialogStack.indexOf(e); -1 !== t && (this.pendingDialogStack.splice(t, 1), 0 === this.pendingDialogStack.length && this.unblockDocument(), this.updateStacking()) }, r.dm = new r.DialogManager, r.formSubmitter = null, r.useValue = null, void 0 === window.HTMLDialogElement) { var l = document.createElement("form"); if (l.setAttribute("method", "dialog"), "dialog" !== l.method) { var s = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, "method"); if (s) { var d = s.get; s.get = function () { return n(this) ? "dialog" : d.call(this) }; var c = s.set; s.set = function (e) { return "string" == typeof e && "dialog" === e.toLowerCase() ? this.setAttribute("method", e) : c.call(this, e) }, Object.defineProperty(HTMLFormElement.prototype, "method", s) } } document.addEventListener("click", function (e) { if (r.formSubmitter = null, r.useValue = null, !e.defaultPrevented) { var o = e.target; if (o && n(o.form)) { if (!("submit" === o.type && ["button", "input"].indexOf(o.localName) > -1)) { if ("input" !== o.localName || "image" !== o.type) return; r.useValue = e.offsetX + "," + e.offsetY } t(o) && (r.formSubmitter = o) } } }, !1); var u = HTMLFormElement.prototype.submit; HTMLFormElement.prototype.submit = function () { if (!n(this)) return u.call(this); var e = t(this); e && e.close() }, document.addEventListener("submit", function (e) { var o = e.target; if (n(o)) { e.preventDefault(); var i = t(o); if (i) { var a = r.formSubmitter; a && a.form === o ? i.close(r.useValue || a.value) : i.close(), r.formSubmitter = null } } }, !0) } r.forceRegisterDialog = r.forceRegisterDialog, r.registerDialog = r.registerDialog, "function" == typeof define && "amd" in define ? define(function () { return r }) : "object" == typeof module && "object" == typeof module.exports ? module.exports = r : window.dialogPolyfill = r }();
				
				document.querySelectorAll("dialog:not([data-is-inited-dialog])").forEach(targetDialog => {
					initDialog(targetDialog);
				});
				
				window.findDynamicComponent && window.findDynamicComponent({
					parentContainer: "body"
					, targetSelector: "dialog:not([data-is-inited-dialog])"
					, callbackFunction: initDialog
				});
			}
			
			window.addEventListener("DOMContentLoaded", () => { 
				var isLikelyDesktop = document.documentElement.classList.contains("hasMouseCursor");
				
				//NOTE: we are using inline-styles instead of a class in order to maximize the CSS specificity
				var HTMLElementPageLockStyleString;
				var HTMLElementPageLockStyleDeleteString1;
				var HTMLElementPageLockStyleDeleteString2;
				var bodyElementPageLockStyleStringTemplate;
				var bodyElementPageLockStyleString;
				var bodyElementPageLockStyleDeleteString;
				
				if (isLikelyDesktop === true) {
					HTMLElementPageLockStyleString = "overflow: hidden !important;";
					HTMLElementPageLockStyleDeleteString1 = "overflow: hidden !important";
					HTMLElementPageLockStyleDeleteString2 = HTMLElementPageLockStyleDeleteString1;  //NOTE: this second variation is not needed since there is only rule, but we still need to init it to keep the rest of the code functional
					bodyElementPageLockStyleStringTemplate = HTMLElementPageLockStyleString;
					bodyElementPageLockStyleString = bodyElementPageLockStyleStringTemplate;
					bodyElementPageLockStyleDeleteString = bodyElementPageLockStyleString;
				} else {
					HTMLElementPageLockStyleString = "; box-sizing: border-box !important; height: calc(var(--windowInnerHeight) - 1px) !important; overflow: hidden !important;";
					HTMLElementPageLockStyleDeleteString1 = "box-sizing: border-box !important; height: calc(var(--windowInnerHeight) - 1px) !important; overflow: hidden !important;";
					HTMLElementPageLockStyleDeleteString2 = "box-sizing: border-box !important; height: calc(var(--windowInnerHeight) - 1px)  !important; overflow: hidden !important;";  //NOTE: for some reason the HTML element removes the leading "; " in the pagelockstyle  //NOTE: for some reason, in some browsers, the <html> style attribute adds an extra space in front of !important
					bodyElementPageLockStyleStringTemplate = "; box-sizing: border-box !important; height: calc(var(--windowInnerHeight) - 1px) !important; overflow: hidden !important;";
					bodyElementPageLockStyleString = bodyElementPageLockStyleStringTemplate;
					bodyElementPageLockStyleDeleteString = bodyElementPageLockStyleString;
				}
				
				var isPageScrollLocked = () => {
					var HTMLElement = document.documentElement;
					var bodyElement = document.querySelector("body");
					
					var HTMLElementStyle = HTMLElement.hasAttribute("style") === true ? HTMLElement.getAttribute("style") : "";
					var bodyElementStyle = bodyElement.hasAttribute("style") === true ? bodyElement.getAttribute("style") : "";
					
					return HTMLElementStyle.includes(HTMLElementPageLockStyleDeleteString1) && bodyElementStyle.includes(bodyElementPageLockStyleDeleteString) || HTMLElementStyle.includes(HTMLElementPageLockStyleDeleteString2) && bodyElementStyle.includes(bodyElementPageLockStyleDeleteString);
				};
				
				var togglePageScrolling = () => {
					var HTMLElement = document.documentElement;
					var bodyElement = document.querySelector("body");
					
					var HTMLElementStyle = HTMLElement.hasAttribute("style") === true ? HTMLElement.getAttribute("style") : "";
					var bodyElementStyle = bodyElement.hasAttribute("style") === true ? bodyElement.getAttribute("style") : "";
					
					if (isPageScrollLocked() === true) {
						HTMLElement.setAttribute("style", HTMLElementStyle.replaceAll(HTMLElementPageLockStyleDeleteString1, "").replaceAll(HTMLElementPageLockStyleDeleteString2, ""));
						bodyElement.setAttribute("style", bodyElementStyle.replaceAll(bodyElementPageLockStyleDeleteString, ""));
					} else {
						HTMLElement.setAttribute("style", HTMLElementStyle + HTMLElementPageLockStyleString);
						bodyElement.setAttribute("style", bodyElementStyle + bodyElementPageLockStyleString);
					}
				};
				
				window.findDynamicComponent && window.findDynamicComponent({
					parentContainer: "body"
					, targetSelector: "dialog[open]"
					, callbackFunction: targetDialog => {
						targetDialog && targetDialog.focus && targetDialog.focus();
						
						var dialogForm = targetDialog.querySelectorAll("form")[0];
						
						if (dialogForm && dialogForm.hasAttribute("target") === false && dialogForm.hasAttribute("action") === false && dialogForm.hasAttribute("method") === false) {
							dialogForm.setAttribute("method", "dialog");
						}
						
						var scrollPositionBeforeModalOpen = window.scrollY;
						var dialogOpenedAbortController = new AbortController(); 
						
						if (isPageScrollLocked() === false) {
							togglePageScrolling();
							
							isLikelyDesktop === false && document.querySelector("main").setAttribute("style", `transform: translateY(-${scrollPositionBeforeModalOpen}px);`);
							isLikelyDesktop === false && document.querySelector("body > nav").setAttribute("style", `transform: translateY(-${scrollPositionBeforeModalOpen}px);`);
						}
						
						//set inner window height and update on resize (includes when mobile browser UI 'minimizes'/pops up)
						document.documentElement.style.setProperty("--windowInnerHeight", `${window.innerHeight}px`);
						
						window.addEventListener("resize", e => {
							document.documentElement.style.setProperty("--windowInnerHeight", `${window.innerHeight}px`);
						}, {
							signal: dialogOpenedAbortController.signal
						});
						
						window.addEventListener("pointermove", e => {  //NOTES: "pointermove" for iOS15 support
							try {
								e.preventDefault && e.preventDefault();
							} catch (error) {
								console.error(error);
							} finally {
								return false;
							}
						}, {
							signal: dialogOpenedAbortController.signal
						});
						
						window.addEventListener("touchmove", e => {  //NOTES: "touchmove" for iOS14 support
							try {
								e.preventDefault && e.preventDefault();
							} catch (error) {
								console.error(error);
							} finally {
								return false;
							}
						}, {
							signal: dialogOpenedAbortController.signal
						});
						
						targetDialog.addEventListener("close", e => {
							if (isPageScrollLocked() === true) {
								togglePageScrolling();
								document.querySelector("main").removeAttribute("style"); //??? HACK
								document.querySelector("body > nav").removeAttribute("style"); //??? same HACK
							}
							
							if (isLikelyDesktop === false) {
								bodyElementPageLockStyleString = bodyElementPageLockStyleStringTemplate;
								bodyElementPageLockStyleDeleteString = bodyElementPageLockStyleString;
							}
							
							var activeModalOpenerButton = document.querySelector('[aria-haspopup="true"][aria-expanded="true"]');
							
							if (activeModalOpenerButton) {
								activeModalOpenerButton.setAttribute("aria-expanded", false);
								activeModalOpenerButton.focus();
							}
							
							if (isLikelyDesktop === false) {
								window.requestAnimationFrame && window.requestAnimationFrame(() => {
									if (scrollPositionBeforeModalOpen && scrollPositionBeforeModalOpen > 0) {  //NOTE: for some reason, iOS throws an additional close event, where the value is 0px; the 1st close event has the correct value
										if (hasNativeDialog === true) {  //NOTE: needed because Android Chrome will follow the CSS scroll-behavior instead of the options-argument for scrollTo()
											document.documentElement.setAttribute("style", "scroll-behavior: auto;");  //??? this should be rewritten to be more safe incase something else is setting style on <html>
										}
										
										window.scrollTo(0, scrollPositionBeforeModalOpen);
										
										if (hasNativeDialog === true) {  //NOTE: needed because Android Chrome will follow the CSS scroll-behavior instead of the options-argument for scrollTo()
											document.documentElement.removeAttribute("style");
										}
									}
								});
							}
							
							dialogOpenedAbortController && dialogOpenedAbortController.abort && dialogOpenedAbortController.abort();
						}, {
							signal: dialogOpenedAbortController.signal
						});
						
					}
				});
			});
		}).apply(null, args);
	})();
</script><script class="Multiselector-100">
	; (() => {
		const NAMESPACE = "Multiselector";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var targetSelector;
			var onlyShowWhenMouseIsAvailableClass;
			var onlyShowWhenMouseIsNotAvailableClass;
			var targetedOptionClass;
			var renderPicker;
			var renderListbox;
			var openListbox;
			var closeListbox;
			var selectOption;
			
			/*  */
			var setTargetedOptionClass = (targetListBox, newTargetedOptionElement) => {
				//GUARD: do nothing if there is no target listbox or target option
				if (!targetListBox || !newTargetedOptionElement) {
					return;
				}
				
				//set aria-activedescendant on the picker
				var newActiveDescendantID = newTargetedOptionElement.getAttribute("id");
				
				newActiveDescendantID && targetListBox.setAttribute("aria-activedescendant", newActiveDescendantID);
				
				//set and remove targeted option class
				var allOptionElements = targetListBox.querySelectorAll('[role="option"]');
				
				allOptionElements.forEach(curOption => {
					curOption.classList.remove(targetedOptionClass);
				});
				
				newTargetedOptionElement.classList.add(targetedOptionClass);
				
				//scroll into view
				newTargetedOptionElement.scrollIntoView && newTargetedOptionElement.scrollIntoView({
					block: "nearest"
					, inline: "center"
				});
			};
			
			/*  */
			var getTargetedOptionIndex = listbox => {
				const DEFAULT_OUTPUT = 0;
				var curSelectionIdx;
				
				var curTargetedOptionID = listbox.hasAttribute("aria-activedescendant") && listbox.getAttribute("aria-activedescendant");
				
				if (curTargetedOptionID) {
					var allOptionElements = listbox.querySelectorAll('[role="option"]');
					
					curSelectionIdx = Array.from(allOptionElements).findIndex(curOption => {
						var curOptionID = curOption.getAttribute("id");
						
						return curOptionID === curTargetedOptionID;
					});
				}
				
				return curSelectionIdx || DEFAULT_OUTPUT;
			};
			
			/*  */
			var setTargetedOption = (pickerElement, listbox, targetIndex, doNotWrapAround) => {
				//GUARD: do nothing if there is no list box
				if (!listbox) {
					return;
				}
				
				//move focus cursor to the listbox for accessibility
				listbox.focus({
					preventScroll: true
				});
				
				/* SET TARGETED OPTION */
				var allOptionElements = listbox.querySelectorAll('[role="option"]');
				
				var numOptions = allOptionElements.length;
				
				//find the next target item if no specific option has been requested
				if (targetIndex === undefined) {
					var curSelectionIdx = getTargetedOptionIndex(listbox);
					
					//select the first option if the active descendant cannot be found for any reason
					targetIndex = (curSelectionIdx) ? curSelectionIdx + 1 : 0;
				}
				
				//wrap around the target index (
				if (targetIndex >= numOptions) {
					targetIndex = (doNotWrapAround) ? numOptions - 1 : 0;
				} else if (targetIndex < 0) {
					targetIndex = (doNotWrapAround) ? 0 : numOptions - 1;
				}
				
				var newActiveDescendant = allOptionElements[targetIndex];
				
				listbox && newActiveDescendant && setTargetedOptionClass(listbox, newActiveDescendant);
				/* end of SET TARGETED OPTION */
			};
			
			/*  */
			var setNextTargetedOption = (pickerElement, listbox) => {
				var curTargetedOptionIndex = getTargetedOptionIndex(listbox)
				
				var targetIndex = parseInt(curTargetedOptionIndex, 10);
				
				if (Number.isNaN(targetIndex) === false) {
					setTargetedOption(pickerElement, listbox, targetIndex + 1);
				}
			};
			
			/*  */
			var setPrevTargetedOption = (pickerElement, listbox) => {
				var curTargetedOptionIndex = getTargetedOptionIndex(listbox)
				
				var targetIndex = parseInt(curTargetedOptionIndex, 10);
				
				if (Number.isNaN(targetIndex) === false) {
					setTargetedOption(pickerElement, listbox, targetIndex - 1);
				}
			};
			
			var printPickerText = numElements => {
				var output = "";
				
				switch (numElements) {
					case 0:
						; (() => {
							output = "No options selected";
						})();
						
						break;
					case 1:
						; (() => {
							output = "1 option selected";
						})();
						
						break;
					default:
						; (() => {
							output = `${numElements} options selected`;
						})();
						
						break;
				}
				
				return output;
			};
			
			var updatePickerText = (pickerElement, listbox) => {
				var allSelectedOptionElements = listbox.querySelectorAll('[role="option"][aria-selected="true"]');
				
				var numSelectedOptionElements = allSelectedOptionElements.length;
				
				var firstSelectedOption = allSelectedOptionElements && allSelectedOptionElements.length > 0 && allSelectedOptionElements[0];
				
				var newPickerLabelText = numSelectedOptionElements === 1 ? firstSelectedOption && firstSelectedOption.textContent : printPickerText(numSelectedOptionElements);
				
				newPickerLabelText && pickerElement.setAttribute("aria-label", newPickerLabelText);
			};
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				targetSelector = options.targetSelector;
				onlyShowWhenMouseIsAvailableClass = options.onlyShowWhenMouseIsAvailableClass;
				onlyShowWhenMouseIsNotAvailableClass = options.onlyShowWhenMouseIsNotAvailableClass;
				targetedOptionClass = options.targetedOptionClass;
				renderPicker = options.renderPicker;
				renderListbox = options.renderListbox;
				openListbox = options.openListbox;
				closeListbox = options.closeListbox;
				selectOption = options.selectOption;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				var allMultiselectorElements = targetSelector && document.querySelectorAll(targetSelector);
				
				allMultiselectorElements.forEach(curMultiselector => {
					/* BUILD AND INSERT HTML ELEMENTS */
					var curMultiselectorParent = curMultiselector.closest("label");
					
					//GUARD: do nothing if there is no parent for the multiselector
					if (!curMultiselectorParent) {
						return;
					}
					
					var newMultiselectorParent = curMultiselectorParent && curMultiselectorParent.cloneNode(true);
					newMultiselectorParent.style.maxWidth = "100%"
					
					newMultiselectorParent.classList.add(onlyShowWhenMouseIsAvailableClass);
					curMultiselectorParent.classList.add(onlyShowWhenMouseIsNotAvailableClass);
					
					var pickerElement = renderPicker && renderPicker(curMultiselector);
					var listboxElement = renderListbox && renderListbox(curMultiselector.getAttribute("name"), curMultiselector.querySelectorAll("option"), targetedOptionClass);
					
					//replace the cloned selector input with the custom multiselector version, but keep all current labels
					var targetSelect = newMultiselectorParent.querySelector(targetSelector);
					
					var targetSelectStyles = targetSelect.hasAttribute("style") && targetSelect.getAttribute("style");
					targetSelectStyles && pickerElement.setAttribute("style", targetSelectStyles);
					
					targetSelect.replaceWith(pickerElement);
					pickerElement.after(listboxElement);
					
					//...then insert...
					curMultiselectorParent.after(newMultiselectorParent)
					/* end of BUILD AND INSERT HTML ELEMENTS */
					
					/* HANDLE FORM RESET EVENTS */
					var formElement = curMultiselector.form;
					
					formElement && formElement.tagName === "FORM" && formElement.addEventListener("reset", () => {
						//rebuild all option elements
						window.deleteAllChildNodes && window.deleteAllChildNodes(listboxElement);
						
						var newListboxElement = renderListbox && renderListbox(curMultiselector.getAttribute("name"), curMultiselector.querySelectorAll("option"), targetedOptionClass, true);
						
						var newOptionElements = Array.from(newListboxElement.children);
						
						newOptionElements && newOptionElements.forEach(newOptionElement => {
							listboxElement.append(newOptionElement);
						});
						
						//update picker label
						updatePickerText && updatePickerText(pickerElement, listboxElement);
					});
					/* end of HANDLE FORM RESET EVENTS */
					
					/* KEEP OPTIONS SYNCED AFTER INIT */
					var originalSelectMutationObserver = new MutationObserver(() => {
						//??? replace references to picker with mutationObserver's "target" variable instead? to reduce the number of global references
						
						var updatedListbox = renderListbox && renderListbox(curMultiselector.getAttribute("name"), curMultiselector.querySelectorAll("option"), targetedOptionClass);
						
						window.deleteAllChildNodes && window.deleteAllChildNodes(pickerElement);  //NOTE: we need to add the text of each "<option>" from the listbox into the picker so the picker can set itself to the width of the widest "<option>"; that matches the native behavior of <select>
						window.deleteAllChildNodes && window.deleteAllChildNodes(listboxElement);
						
						var allUpdatedListboxOptions = updatedListbox.querySelectorAll('[role="option"]');
						
						allUpdatedListboxOptions.forEach((curUpdatedListboxOption, idx) => {
							listboxElement.append(curUpdatedListboxOption.cloneNode(true));
							
							//??? should this be replaced with a class?
							var pickerSizerElement = document.createElement("span");
							pickerSizerElement.setAttribute("aria-hidden", true);
							pickerSizerElement.setAttribute("style", "display: block; height: 0px !important; pointer-events: none; -ms-user-select: none; -moz-user-select: none; -webkit-user-select: none; user-select: none; overflow: hidden !important;");
							pickerSizerElement.textContent = curUpdatedListboxOption.textContent;
							
							var curOptionCountSizerElement = document.createElement("span");
							curOptionCountSizerElement.setAttribute("aria-hidden", true);
							curOptionCountSizerElement.setAttribute("style", "display: block; height: 0px !important; pointer-events: none; -ms-user-select: none; -moz-user-select: none; -webkit-user-select: none; user-select: none; overflow: hidden !important;");
							curOptionCountSizerElement.textContent = printPickerText && printPickerText(idx);
							
							pickerElement.append(pickerSizerElement);
							curOptionCountSizerElement && pickerElement.append(curOptionCountSizerElement);
						});
						
						updatePickerText && updatePickerText(pickerElement, updatedListbox);
						
						//sync common global HTML attributes
						curMultiselector.hasAttribute("hidden") === true && pickerElement.setAttribute("hidden", "");
						curMultiselector.hasAttribute("hidden") === false && pickerElement.removeAttribute("hidden");
						
						curMultiselector.hasAttribute("readonly") === true && pickerElement.setAttribute("readonly", "");
						curMultiselector.hasAttribute("readonly") === false && pickerElement.removeAttribute("readonly");
						
						curMultiselector.hasAttribute("disabled") === true && pickerElement.setAttribute("disabled", "");
						curMultiselector.hasAttribute("disabled") === false && pickerElement.removeAttribute("disabled");
					});
					
					originalSelectMutationObserver.observe(curMultiselector, {
						subtree: true
						, childList: true
						, attributes: true
						, characterData: true
					});
					/* end of UPDATE OPTIONS AFTER INIT*/
					
					/* HANDLE LISTBOX SIZING AND POSITIONING */
					// update the width of the listbox everytime the picker changes width
					var pickerResizeListener = new ResizeObserver(entries => {
						for (let entry of entries) {
							listboxElement.style.width = `${entry.borderBoxSize[0].inlineSize}px`;
						}
						
						var isExpanded = pickerElement.getAttribute("aria-expanded");
						
						var isResizingPickerBlocked = pickerElement.hasAttribute("data-prevent-next-picker-resize");
						
						if (isResizingPickerBlocked === false && isExpanded === "true") {
							pickerElement.click();
						}
						
						isResizingPickerBlocked === true && pickerElement.removeAttribute("data-prevent-next-picker-resize");
					});
					
					pickerResizeListener.observe(pickerElement);
					
					// update size of listbox and place above or below picker 
					var popupOpeningListener = new IntersectionObserver(entries => {
						entries.forEach(entry => {
							var target = entry.target;
							
							var overlapAmount = entry.intersectionRatio;
							
							//GUARD: do nothing if the element has left the observed region
							if (overlapAmount === 0) {
								return;
							}
							
							var minListboxHeight = 200;  //??? refactor this into a init-variable
							var viewportMargin = 18;  //??? refactor this into a init-variable
							var minSpaceBelowPicker = minListboxHeight + viewportMargin;
							
							var spaceBelowPickerInPX = (() => {
								var output = 0;
								
								var viewportHeight = document.documentElement.clientHeight;
								var pickerYCoord = pickerElement.getBoundingClientRect().y;
								var pickerHeight = pickerElement.offsetHeight;
								
								output = viewportHeight - (pickerYCoord + pickerHeight);
								
								return output;
							})();
							
							var isRenderingUpwards = spaceBelowPickerInPX <= minSpaceBelowPicker;
							
							var curHeightInPX = listboxElement.offsetHeight;
							var newHeightInPX;
							var newHeightInString;
							
							if (isRenderingUpwards === true) {
								var totalUpwardsSpaceInPX = target.getBoundingClientRect().y;
								var pickerHeight = pickerElement.offsetHeight;
								
								newHeightInPX = totalUpwardsSpaceInPX - pickerHeight - 18;  //??? refactor 1rem/18px for spacing
								
								newHeightInString = `${Math.min(curHeightInPX, newHeightInPX)}px`;
								
								var newTransformInString = `translateY(calc(-100% + ${pickerHeight * -1}px))`;
								
								listboxElement.style.height = newHeightInString; 
								
								/* HACK: for some reason, style.transform does not work as a setter, so manually setting the style using setAttribute() instead.
								
								//listboxElement.style.transform = newTransformInString;
								*/
								
								listboxElement.setAttribute("style", `${listboxElement.getAttribute("style")}; transform: ${newTransformInString}`);  //??? why does this not have a trailing semicolon?
							} else {
								if (curHeightInPX + viewportMargin >= spaceBelowPickerInPX) {
									newHeightInPX = spaceBelowPickerInPX - viewportMargin;
									newHeightInString = `${newHeightInPX}px`;
									
									listboxElement.style.height = newHeightInString;
								}
							}
							
							listboxElement.style.opacity = "1";
						});
					});
					
					popupOpeningListener.observe(listboxElement);
					/* end of HANDLE LISTBOX SIZING AND POSITIONING */
					
					/* HANDLE PICKER MOUSE INTERACTIONS */
					// open listbox when clicking, tapping, and pressing enter/space
					pickerElement && pickerElement.addEventListener("click", e => {
						var target = e.currentTarget;
						
						var isAccordion = target.hasAttribute("aria-expanded");
						
						//GUARD: do nothing if the selector is not an accordion
						if (isAccordion === false) {
							return;
						}
						
						var isExpanded = target.getAttribute("aria-expanded");
						
						if (isExpanded === "true") {
							closeListbox && closeListbox(target, listboxElement);
						} else {
							openListbox && openListbox(target);
						}
					});
					/* end of HANDLE PICKER MOUSE INTERACTIONS */
					
					/* HANDLE PICKER KEYBOARD INTERACTIONS */
					//enable basic arrow-key navigation of the listbox
					pickerElement && pickerElement.addEventListener("keydown", e => {
						var keycode = e.which;
						
						//NOTE: no need to handle 'press enter/space to open' because that is default <button> behavior and is handled by the 'click' event
						switch (keycode) {
							case KEYCODE.UP_ARROW:
							case KEYCODE.DOWN_ARROW:
								; (() => {
									if (keycode === KEYCODE.UP_ARROW) {
										setPrevTargetedOption(pickerElement, listboxElement);
									}
									
									if (keycode === KEYCODE.DOWN_ARROW) {
										setNextTargetedOption(pickerElement, listboxElement);
									}
									
									pickerElement && pickerElement.click();
								})();
								
								//break; //PASSTHROUGH
							case KEYCODE.RIGHT_ARROW:  //prevent horizontal page scrolling
							case KEYCODE.LEFT_ARROW:  //prevent horizontal page scrolling
								; (() => {
									
								})();
								
								e.preventDefault();
								e.stopPropagation();
								return false;
								
								break;
							default:
								; (() => {
									
								})();
								
								break;
						}
					});
					
					//enable searching for options by typing the first letter of the option
					pickerElement && pickerElement.addEventListener("keypress", e => {
						var targetCharacter = e.key.toLowerCase();
						
						var allMatches = optionsTextSearchHashMap[targetCharacter];
						
						if (allMatches && allMatches.length > 0) {
							var targetIndex = 0;
							
							var targetedMatch = allMatches.findIndex(curMatch => {
								return curMatch.matches(`.${targetedOptionClass}`);
							});
							
							if (targetedMatch !== undefined) {
								targetIndex = (targetedMatch + 1) % allMatches.length;
							}
							
							var newTargetedOption = allMatches[targetIndex];
							
							setTargetedOptionClass(listboxElement, newTargetedOption);
							
							pickerElement.click(); //click to open the listbox
						}
					});
					/* end of HANDLE PICKER KEYBOARD INTERACTIONS */
					
					/* HANDLE LISTBOX OPTIONS MOUSE AND KEYBOARD INTERACTIONS */
					var optionsTextSearchHashMap = {};
					
					var allOptions = listboxElement.querySelectorAll('[role="option"]');
					
					allOptions.forEach(curOption => {
						//index current option for text search
						var curOptionFirstChar = curOption.textContent[0].toLowerCase();
						
						var curOptionHashMapContainer = optionsTextSearchHashMap[curOptionFirstChar];
						
						if (!curOptionHashMapContainer) {
							 optionsTextSearchHashMap[curOptionFirstChar] = [curOption];
						} else {
							curOptionHashMapContainer.push(curOption);
						}
						
						//set targeted option when hovering over an option
						curOption.addEventListener("mouseover", e => {
							var newActiveDescendant = e.currentTarget;
							
							setTargetedOptionClass(listboxElement, newActiveDescendant);
						});
					});
					/* end of HANDLE LISTBOX OPTIONS MOUSE AND KEYBOARD INTERACTIONS */
					
					/* HANDLE LISTBOX MOUSE INTERACTIONS */
					//enable clicking to select an option
					listboxElement && listboxElement.addEventListener("click", e => {
						var target = e.target;
						
						//GUARD: do nothing if this click event came from a label because this callback will action on the input's click event instead (prevents this callback from running twice for a single click)
						//??? this comment is completely wrong now.  update ASAP
						if (target.tagName !== "INPUT") {
							return;
						}
						
						var curSelectionElement = target.closest('[role="option"]');
						
						if (curSelectionElement) {
							setTargetedOptionClass(listboxElement, curSelectionElement);
							
							pickerElement.setAttribute("data-prevent-next-picker-resize", "");  //??? hacky?
							selectOption && selectOption(pickerElement, listboxElement, curSelectionElement, curMultiselector);
							updatePickerText && updatePickerText(pickerElement, listboxElement);
						}
					});
					/* end of HANDLE LISTBOX MOUSE INTERACTIONS */
					
					/* HANDLE LISTBOX KEYBOARD INTERACTIONS */
					listboxElement && listboxElement.addEventListener("focusout", e => { 
						var clickTarget = e.relatedTarget;
						
						//NOTE: do not close the listbox if the user is still interacting with it:  running keyboard actions on it, clicking its child elements, or clicking the picker 
						if (document.activeElement !== listboxElement && listboxElement.contains(clickTarget) === false && clickTarget !== pickerElement) {
							pickerElement && closeListbox && closeListbox(pickerElement, listboxElement);
							pickerElement.click();
						}
					});
					
					listboxElement && listboxElement.addEventListener("keydown", e => {
						var listbox = e.currentTarget;
						
						var targetIndex;
						
						var keycode = e.which;
						
						switch (keycode) {
							case KEYCODE.RIGHT_ARROW:  //prevent horizontal page scrolling
							case KEYCODE.LEFT_ARROW:  //prevent horizontal page scrolling
								; (() => {
									
								})();
								
								e.preventDefault();
								e.stopPropagation();
								return false;
								
								break;  //NOTE: yes, this is obviously unreachable code; keeping here for code consistency sake
							case KEYCODE.ESC:  //close dropdown
								; (() => {
									pickerElement && closeListbox && closeListbox(pickerElement, listbox);
									pickerElement.click();
								})();
								
								break;
							case KEYCODE.ENTER:  //select/deselect option
							case KEYCODE.SPACE:  //select/deselect option
								; (() => {
									var curSelectionID = listbox.hasAttribute("aria-activedescendant") && listbox.getAttribute("aria-activedescendant");
									
									if (curSelectionID) {
										var curSelectionElement = document.getElementById(curSelectionID);
										
										selectOption && selectOption(pickerElement, listbox, curSelectionElement, curMultiselector);
										updatePickerText && updatePickerText(pickerElement, listboxElement);
										
										e.preventDefault();
										e.stopPropagation();
										return false;
									}
								})();
								
								break;
							case KEYCODE.HOME:
							case KEYCODE.PAGE_UP:
								; (() => {
									setTargetedOption(pickerElement, listbox, 0, true);
								})();
								
								e.preventDefault();
								e.stopPropagation();
								return false;
								
								break;  //NOTE: yes, this is obviously unreachable code; keeping here for code consistency sake
							case KEYCODE.END:
							case KEYCODE.PAGE_DOWN:
								; (() => {
									setTargetedOption(pickerElement, listbox, Number.MAX_SAFE_INTEGER, true);  //HACK: to always select the last option, set the target index to an impossibly high value so setTargetedOption() will change it to the highest possible value value (AKA the last option)
								})();
								
								e.preventDefault();
								e.stopPropagation();
								return false;
								
								break;  //NOTE: yes, this is obviously unreachable code; keeping here for code consistency sake
							case KEYCODE.UP_ARROW:
								; (() => {
									setPrevTargetedOption(pickerElement, listbox);
								})();
								
								e.preventDefault();
								e.stopPropagation();
								return false;
								
								break;  //NOTE: yes, this is obviously unreachable code; keeping here for code consistency sake
							case KEYCODE.DOWN_ARROW:
								; (() => {
									setNextTargetedOption(pickerElement, listbox);
								})();
								
								e.preventDefault();
								e.stopPropagation();
								return false;
								
								break;  //NOTE: yes, this is obviously unreachable code; keeping here for code consistency sake
							default:
								; (() => {
									
								})();
								
								break;
						}
					});
				
					listboxElement && listboxElement.addEventListener("keypress", e => {
						var targetCharacter = e.key.toLowerCase();
						
						var allMatches = optionsTextSearchHashMap[targetCharacter];
						
						if (allMatches && allMatches.length > 0) {
							var targetIndex = 0;
							
							var targetedMatch = allMatches.findIndex(curMatch => {
								return curMatch.matches(`.${targetedOptionClass}`);
							});
							
							if (targetedMatch !== undefined) {
								targetIndex = (targetedMatch + 1) % allMatches.length;
							}
							
							var newTargetedOption = allMatches[targetIndex];
							
							setTargetedOptionClass(listboxElement, newTargetedOption);
						}
					});
					/* end of HANDLE LISTBOX KEYBOARD INTERACTIONS */
				});
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="virtualCursor-102">
	; (() => {
		const NAMESPACE = "virtualCursor";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		var KEYCODE = window.KEYCODE;
		
		var args = [ns, NAMESPACE, KEYCODE];
		
		; ((ns, NAMESPACE, KEYCODE) => {
			var self = ns;
			
			self.isInited = false;
			
			var focusableElementsSelector;
			var focusableContainerClass;
			var focusableContainerSelector;
			var noFocusClass;
			var noFocusSelector;
			var showFocusClass;
			
			self.init = options => {
				//GUARD: only allow this library to be initialized once
				if (self.isInited) {
					return false;
				}
				
				focusableElementsSelector = options.focusableElementsSelector;
				focusableContainerClass = options.focusableContainerClass;
				noFocusClass = options.noFocusClass;
				showFocusClass = options.showFocusClass;
				
				focusableContainerSelector = `.${focusableContainerClass}`;
				noFocusSelector = `.${noFocusClass}`;
				
				var root = document.documentElement;
				var body = document.querySelector("body");
				
				window.addEventListener("focus", e => {
					root.classList.remove(noFocusClass);
				});
				
				var hasFirstFocusEventFired = false;
				
				body.addEventListener("focusin", e => {
					//we only load virtual-cursor stylesheets after the user has they have a keyboard or are otherwise able to interact with interactable elements
					if (hasFirstFocusEventFired === false) {
						hasFirstFocusEventFired = true;
						
						window.injectHTMLTemplateContentInPlace && window.injectHTMLTemplateContentInPlace("virtualcursor");
					}
					
					var target = e.currentTarget;
					
					//GUARD: do nothing if the target is not whitelisted
					if (target.matches(focusableContainerSelector) !== true) {
						return;
					}
					
					//GUARD: do nothing is a target container cannot be found
					if (!target) {
						return;
					}
					
					target.classList.add(showFocusClass);
				});
				
				body.addEventListener("focusout", e => {
					var target = e.currentTarget;
					
					//GUARD: do nothing if the target is not whitelisted
					if (target.matches(focusableContainerSelector) !== true) {
						return;
					}
					
					//GUARD: do nothing is a target container cannot be found
					if (!target) {
						return;
					}
					
					target.classList.remove(showFocusClass);
				});
				
				body.addEventListener("click", e => {
					var target = e.currentTarget;
					
					//GUARD: do nothing if the target is not whitelisted
					if (target.matches(focusableContainerSelector) !== true) {
						return;
					}
					
					//GUARD: do nothing is a target container cannot be found
					if (!target) {
						return;
					}
					
					target.classList.remove(showFocusClass);
				});
				
				body.addEventListener("keydown", e => {
					//GUARD: do nothing if the target is not whitelisted
					if (document.activeElement.matches(focusableElementsSelector) !== true) {
						return;
					}
					
					if (e.keyCode === KEYCODE.TAB) {
						root.classList.remove(noFocusClass);
					}
				});
				
				//tracking the mouse position is required because IE11 throws a mousemove event when tabbing to an <a>
				//if there is a mousemove event, but the mouse hasn't changed position, then we assume it was a tab-press in all browsers
				var prevMouseX;
				var prevMouseY;
				
				body.addEventListener("mousemove", e => {
					if (e.pageX !== prevMouseX || e.pageY !== prevMouseY) {
						prevMouseX = e.pageX;
						prevMouseY = e.pageY;
						
						root.classList.add(noFocusClass);
					}
				});
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="AutoIDGenerator">
	; (() => {
		const NAMESPACE = "AutoIDGenerator";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		var updateID = (target, newID, overwrites) => {
			var output = false;
			
			var targetCurID = target.hasAttribute("id") && target.getAttribute("id");
			var overwrites = overwrites || {};
			
			if (overwrites.forceOverwrite || !targetCurID || targetCurID === "") {
				if (newID === undefined || newID === "") {
					target.hasAttribute("id") === true && target.removeAttribute("id");
				} else {
					target && target.setAttribute && target.setAttribute("id", newID);
				}
				
				output = true;
			}
			
			return output;
		};
		
		var args = [ns, NAMESPACE, updateID];
		
		; ((ns, NAMESPACE, updateID) => {
			var self = ns;
			
			self.generateIDsForTabs = () => {
				var allTabLists = document.querySelectorAll('[role="tablist"]');
				
				allTabLists.forEach(target => {
					var targetTabs = target.querySelectorAll('[role="tab"]');
					var targetTabPanels = (() => {
						var output = [];
						
						var nextCandidateTabPanel = target.nextElementSibling;
						
						while (nextCandidateTabPanel && nextCandidateTabPanel.hasAttribute("role") && nextCandidateTabPanel.getAttribute("role") === "tabpanel") {
							output.push(nextCandidateTabPanel);
							
							nextCandidateTabPanel = nextCandidateTabPanel.nextElementSibling;
						}
						
						return output;
					})();
					
					targetTabPanels && targetTabPanels.length > 0 && targetTabs && targetTabs.forEach((curTab, curTabIdx) => {
						var curTabCopy = curTab.textContent;
						var newCurTabID = sanitizeID(curTabCopy);
						
						updateID(curTab, `${newCurTabID}_tab`);
						
						var targetTabPanel = targetTabPanels[curTabIdx];
						
						updateID(targetTabPanel, newCurTabID);
					});
				});
			};
			
			self.generateIDsForAccordions = () => {
				var allAccordions = Array.from(document.querySelectorAll("details"));
				var allNestedAccordions = Array.from(document.querySelectorAll("details details"));
				var allUnnestedAccordions = (() => {
					if (allAccordions.length === 0 || allNestedAccordions.length === 0) {
						return allAccordions;
					} else {
						return allAccordions.filter(curAccordion => {
							return allNestedAccordions.indexOf(curAccordion) === -1;
						});
					}
				})();
				
				allUnnestedAccordions.forEach(curAccordion => {
					var relatedHeader = curAccordion.parentElement.querySelector("h1, h2, h3, h4, h5, h6");
					var relatedHeaderID = relatedHeader && relatedHeader.getAttribute && relatedHeader.getAttribute("id");
					
					if (relatedHeaderID) {
						var targetSummary = window.getDirectChildrenByTag(curAccordion, "SUMMARY")[0];
						
						var formattedID = `${relatedHeaderID}-${targetSummary.getAttribute("id")}`;  //??? should do targetSummary.hasAttribute("id")
						
						updateID(targetSummary, formattedID);
					}
				});
				
				allNestedAccordions && allNestedAccordions.forEach(curAccordion => {
					var parentPrefixes = "";
					
					var parentAccordions = getAllParentsByTag(curAccordion, "details");
					parentAccordions && parentAccordions.forEach(curParentAccordion => {
						parentPrefixes = `${parentPrefixes}-${window.getDirectChildrenByTag(curParentAccordion, "SUMMARY")[0].getAttribute("id")}`;  //??? should do .hasAttribute("id")
					});
					
					parentPrefixes = parentPrefixes.substring(1);
					
					var curAccordionHeader = window.getDirectChildrenByTag(curAccordion, "SUMMARY")[0];
					var newAccordionID = `${parentPrefixes}-${sanitizeID(curAccordionHeader.textContent)}`;
					
					updateID(curAccordionHeader, newAccordionID);
				});
				
				var allHeadingsExceptSummaryHeadingQuerySelectors = [
					"*:not(summary) > h1"
					, "> h1"
					, "*:not(summary) > h2"
					, "> h2"
					, "*:not(summary) > h3"
					, "> h3"
					, "*:not(summary) > h4"
					, "> h4"
					, "*:not(summary) > h5"
					, "> h5"
					, "*:not(summary) > h6"
					, "> h6"
				];
				
				var allHeadingsExceptSummaryHeadings = [];
				
				allAccordions && allAccordions.forEach(curAccordion => {
					allHeadingsExceptSummaryHeadingQuerySelectors && allHeadingsExceptSummaryHeadingQuerySelectors.forEach(curSelector => {
						allHeadingsExceptSummaryHeadings && allHeadingsExceptSummaryHeadings.concat(window.getDirectChildrenByTag(curAccordion, curSelector));
					});
					
				});
				
				allHeadingsExceptSummaryHeadings && allHeadingsExceptSummaryHeadings.forEach(target => {
					var curTargetID = target.getAttribute("id");
					
					var parentAccordion = window.getNearestParentByTag(target, "details");
					
					var parentPrefixes = window.getDirectChildrenByTag(parentAccordion, "SUMMARY")[0].getAttribute("id");
					
					updateID(target, `${parentPrefixes}-${curTargetID}`);
				});
			};
			
			self.generateIDsForDialogs = () => {
				var allDialogs = document.querySelectorAll("dialog");
				
				Array.from(allDialogs).forEach(curDialog => {
					const DIALOG_ID_SELECTOR = "h1, h2, h3, h4, h5, h6";
					
					var curDialogIDContainer = curDialog.querySelector(DIALOG_ID_SELECTOR);
					
					//GUARD: do not proceed if this dialog is malformed and missing a header
					if (!curDialogIDContainer) {
						return;
					}
					
					var curDialogID = curDialogIDContainer.textContent;
					var formattedDialogID = sanitizeID(curDialogID);
					
					updateID(curDialog, `${formattedDialogID}_dialog`);
				});
			};
			
			self.generateIDsForArticleContent = () => {
				var allArticles = document.querySelectorAll("article");
				
				Array.from(allArticles).forEach(curArticle => {
					const ARTICLE_ID_SELECTOR = "h1, h2, h3, h4, h5, h6";
					
					var curArticleIDContainer = curArticle.querySelector(ARTICLE_ID_SELECTOR);
					
					//GUARD: do not proceed if this article is malformed and missing a header
					if (!curArticleIDContainer) {
						return;
					}
					
					var curArticleID = curArticleIDContainer.textContent;
					var formattedArticleID = sanitizeID(curArticleID);
					
					updateID(curArticle, formattedArticleID);
					
					Array.from(curArticle.querySelectorAll("[id]"))
					.filter(target => {
						return target !== curArticleIDContainer;
					})
					.forEach(target => {
						var targetID = target.getAttribute("id");
						
						var formattedTargetID = sanitizeID(targetID);
						
						updateID(target, `${formattedArticleID}-${formattedTargetID}`, { forceOverwrite: true });
					});
				});
			};
			
			self.generateIDsForFormContent = () => {
				var allForms = document.querySelectorAll("form");
				
				allForms.forEach(curForm => {
					var curFormID = curForm.hasAttribute("name") && curForm.getAttribute("name");
					
					//GUARD: do nothing if there is no form name
					if (!curFormID) {
						return;
					}
					
					var formattedFormID = sanitizeID(curFormID);
					
					updateID(curForm, formattedFormID);
					
					//??? should we convert this to use form.elements; it doesn't do it because this was written before form.elements
					curForm.querySelectorAll("input[name], textarea[name], select[name]").forEach(curInput => {
						var curInputType = curInput.hasAttribute("type") && curInput.getAttribute("type");
						curInputType = curInputType && curInputType.toLowerCase();
						
						var curInputName = curInput.hasAttribute("name") && curInput.getAttribute("name");
						
						var formattedCurInputName = curInputName && sanitizeID(curInputName);
						
						var newCurInputID;
						
						if (curInputType === "radio") {
							var targetInputValue = curInput.hasAttribute("value") && curInput.getAttribute("value");
							
							var formattedTargetInputValue = targetInputValue && sanitizeID(targetInputValue);
							
							newCurInputID = `${formattedFormID}-${formattedCurInputName}-${formattedTargetInputValue}`;
						} else {
							newCurInputID = `${formattedFormID}-${formattedCurInputName}`;
						}
						
						newCurInputID && updateID(curInput, newCurInputID, { forceOverwrite: true });
					});
				});
			};
			
			self.generateIDsForFormlessInputs = () => {
				var allFormlessInputs = document.querySelectorAll("input[form][name], textarea[form][name], select[form][name]");
				
				allFormlessInputs && allFormlessInputs.forEach(curInput => {
					var targetFormID = curInput.getAttribute("form");
					
					var curForm = document.getElementById(targetFormID);
					
					//GUARD: do nothing if there is no form
					if (!curForm) {
						return;
					}
					
					var curFormName = curForm.hasAttribute("id") && curForm.getAttribute("id");
					
					//GUARD: do nothing if there is no form id
					if (!curFormName) {
						return;
					}
					
					var formattedFormID = sanitizeID(curFormName);
					
					var formattedInputID = sanitizeID(curInput.getAttribute("name"));
					
					updateID && updateID(curInput, `${formattedFormID}-${formattedInputID}`, { forceOverwrite: false });
				});
			};
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				var simpleSelectors = options.simpleSelectors;
				var simpleFilters = options.simpleFilters
				var complexSelectors = options.complexSelectors;
				
				var allSimpleElements = Array.from(document.querySelectorAll(simpleSelectors));
				var allSimpleFilteredElements = Array.from(document.querySelectorAll(simpleFilters));
				
				var targetedSimpleElements = (() => {
					if (allSimpleElements.length === 0 || allSimpleFilteredElements.length === 0) {
						return allSimpleElements;
					} else {
						return allSimpleElements.filter(targetElement => {
							return allSimpleFilteredElements.indexOf(targetElement) === -1;
						});
					}
				})();
				
				targetedSimpleElements && targetedSimpleElements.forEach(curTarget => {
					var targetCopy = curTarget.textContent;
					
					updateID(curTarget, sanitizeID(targetCopy));
				});
				
				complexSelectors && complexSelectors.forEach(curSelector => {
					window.getType(curSelector) === window.getType.function && curSelector();
				});
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="accessibleforms-100">
	; (() => {
		const NAMESPACE = "AccessibleForms";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		var getMatchingSibling = (target, matchingSelector) => {
			var output = target.parentNode.querySelector(matchingSelector);
			
			return output;
		};  //??? should be global helper?
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE, getMatchingSibling];
		
		; ((ns, NAMESPACE, getMatchingSibling) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var targetSelector;
			var errorMessageContainerSuffix;
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				targetSelector = options.targetSelector;
				errorMessageContainerSuffix = options.errorMessageContainerSuffix;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				
				var allInitedInputs = new Set();
				
				targetSelector && window.findDynamicComponent({
					parentContainer: "body"
					, targetSelector: targetSelector
					, callbackFunction: curInput => {
						//GUARD: do nothing if this input has been inited already
						if (allInitedInputs.has(curInput) === true) {
							return;
						}
						
						allInitedInputs.add(curInput);
						
						var targetErrorMessageContainer;
						
						var curInputType = curInput.hasAttribute("type") && curInput.getAttribute("type");
						
						if (curInputType === "radio") {
							var fieldsetContainer = curInput;
							
							do {
								fieldsetContainer = fieldsetContainer.parentElement;
								
								if (fieldsetContainer.tagName === "FIELDSET") {
									break;
								}
							} while (fieldsetContainer.parentElement);
							
							targetErrorMessageContainer = fieldsetContainer.querySelector('[role="alert"]');
						} else {
							var siblingErrorMessageContainer = getMatchingSibling(curInput, '[role="alert"]');
							
							if (siblingErrorMessageContainer) {
								targetErrorMessageContainer = siblingErrorMessageContainer;
							} else {
								var referencedErrorMessageContainerID = curInput.hasAttribute("aria-errormessage") && curInput.getAttribute("aria-errormessage");
								
								if (referencedErrorMessageContainerID) {
									var referencedErrorMessageContainer = document.getElementById(referencedErrorMessageContainerID);
									
									targetErrorMessageContainer = referencedErrorMessageContainer;
								} else {
									curInput.removeAttribute("aria-errormessage");
								}
							}
						}
						
						//GUARD: do nothing if no error message container is found
						if (!targetErrorMessageContainer) {
							return;
						}
						
						var curInputID = curInput.hasAttribute("id") === true && curInput.getAttribute("id");
						var curInputName = curInput.hasAttribute("name") === true && curInput.getAttribute("name");
						var curInputFormID = curInput.form && curInput.form.hasAttribute("id") === true && curInput.form.getAttribute("id");
						
						var formattedInputID = curInputID || curInputFormID && curInputName && `${curInputFormID}-${curInputName}`;
						formattedInputID = formattedInputID && window.sanitizeID(formattedInputID);
						
						//GUARD: do nothing if no ID is found
						if (!formattedInputID) {
							return;
						}
						
						curInput.setAttribute("id", formattedInputID);
						
						var targetErrorMessageContainerID = `${formattedInputID}_${errorMessageContainerSuffix}`;
						var targetErrorMessageContainerAriaControlsValue = targetErrorMessageContainer.hasAttribute("aria-controls") && targetErrorMessageContainer.getAttribute("aria-controls") || "";  //NOTE: we need to append to aria-controls, not overwrite; 
						
						targetErrorMessageContainer.hasAttribute("id") === false && targetErrorMessageContainer.setAttribute("id", targetErrorMessageContainerID);
						targetErrorMessageContainer.setAttribute("aria-controls", `${targetErrorMessageContainerAriaControlsValue} ${formattedInputID}`.trim());
						
						curInput.hasAttribute("aria-describedby") === false && curInput.setAttribute("aria-describedby", targetErrorMessageContainerID);
						curInput.hasAttribute("aria-errormessage") === false && curInput.setAttribute("aria-errormessage", targetErrorMessageContainerID);
						
						//NOTE: do not set aria-invalid if the input element has a value on pageload because we do not show input errors until the user has interacted with it; unless the input is radio button, then always set to aria-invalid=false
						if (!curInput.value || curInputType === "radio") {
							curInput.setAttribute("aria-invalid", false);
						}
						
						/*
						
						NOTE: Generally, radio buttons are either required and have one radio button selected on pageload OR have nothing set and are not required at all.
						
						The code below handles the case where a radio button is required, but none of the radio buttons are set on pageload.
						
						*/
						if (curInputType === "radio") {
							//since you cannot remove the selected radio button after selecting one in a group, we immediately remove all validation from all radio buttons once one of them is selected
							curInput.addEventListener("click", e => {
								var targetInput = e.target;
								
								var targetInputName = targetInput.hasAttribute("name") && targetInput.getAttribute("name");
								
								//GUARD: do nothing if this input element does not have a name
								if (!targetInputName) {
									return;
								}
								
								var targetInputForm = targetInput.form;
								
								//GUARD: do nothing if this input element does not have a parent form
								if (!targetInputForm) {
									return;
								}
								
								var allRelatedRadioButtons = targetInputForm.elements[targetInputName];
								allRelatedRadioButtons = allRelatedRadioButtons && Array.from(allRelatedRadioButtons) || [];
								
								allRelatedRadioButtons.forEach(curRelatedRadioButton => {
									curRelatedRadioButton.removeAttribute("required");  //NOTE: remove 'required' because that is the only possible validation requirement for radio buttons
									
									curRelatedRadioButton.removeAttribute("required");
									curRelatedRadioButton.setCustomValidity("");
									
									curRelatedRadioButton.setAttribute("aria-invalid", false);  //NOTE: we must explicitly set aria-invalid to false, because otherwise it would only be set to false after the user clicks on it (even though it is technically valid once any of the other radio buttons in the group were clicked)
								});
							}, { once: true });
						}
					}
				});
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="formimmediatevalidator-100">
	; (() => {
		const NAMESPACE = "FormImmediateValidator";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			var allInputsWithValidatorSelectors;
			var fieldSpecificErrorMessages;
			var labelSpecificErrorMessages;
			var inputTypeSpecificErrorMessages;
			var buildErrorMessage;
			var buildErrorIcon;
			var getLabelTextForInput;
			
			var findCustomizedFormInputErrorMessage = (errorAttribute, customErrorMessages, targetLabel, targetType) => {
				var output;
				
				if (!output && customErrorMessages && errorAttribute) {
					output = customErrorMessages[errorAttribute];
				}
				
				if (!output && labelSpecificErrorMessages && targetLabel && errorAttribute) {
					output = labelSpecificErrorMessages[targetLabel] && labelSpecificErrorMessages[targetLabel][errorAttribute];
				}
				
				if (!output && inputTypeSpecificErrorMessages && targetType && errorAttribute) {
					output = inputTypeSpecificErrorMessages[targetType] && inputTypeSpecificErrorMessages[targetType][errorAttribute];
				}
				
				return output;
			};
			
			var getCustomizedFormInputErrorMessage = target => {
				var output;
				
				var validityData = target.validity;
				
				var targetName = target.hasAttribute("name") && target.getAttribute("name");
				
				var customErrorMessages = fieldSpecificErrorMessages[targetName];
				var targetLabel = getLabelTextForInput(target);
				var targetType = target.hasAttribute("type") && target.getAttribute("type");
				
				if (validityData.valueMissing) {
					output = findCustomizedFormInputErrorMessage("required", customErrorMessages, targetLabel, targetType);
				} else if (validityData.rangeUnderflow) {
					output = findCustomizedFormInputErrorMessage("min", customErrorMessages, targetLabel, targetType);
				} else if (validityData.rangeOverflow) {
					output = findCustomizedFormInputErrorMessage("max", customErrorMessages, targetLabel, targetType);
				} else if (validityData.tooShort) {
					output = findCustomizedFormInputErrorMessage("minlength", customErrorMessages, targetLabel, targetType);
				} else if (validityData.tooLong) {
					output = findCustomizedFormInputErrorMessage("maxlength", customErrorMessages, targetLabel, targetType);
				} else if (validityData.typeMismatch) {
					output = target.hasAttribute("title") && target.getAttribute("title");
				} else if (validityData.patternMismatch) {
					output = target.hasAttribute("title") && target.getAttribute("title");
				}
				
				return output;
			};
			
			var getFormInputErrorMessage = target => {
				var output = "";
				
				//use the default error message if there are no valid custom messages
				output = getCustomizedFormInputErrorMessage(target) || target.validationMessage;
				
				return output;
			};
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				allInputsWithValidatorSelectors = options.allInputsWithValidatorSelectors;
				fieldSpecificErrorMessages = options.fieldSpecificErrorMessages;
				labelSpecificErrorMessages = options.labelSpecificErrorMessages;
				inputTypeSpecificErrorMessages = options.inputTypeSpecificErrorMessages;
				buildErrorMessage = options.buildErrorMessage;
				buildErrorIcon = options.buildErrorIcon;
				getLabelTextForInput = options.getLabelTextForInput;
				
				var allInitedInputs = new Set();
				
				allInputsWithValidatorSelectors && window.findDynamicComponent({
					parentContainer: "body"
					, targetSelector: allInputsWithValidatorSelectors
					, callbackFunction: curInput => {
						//GUARD: do nothing if this input has been inited already
						if (allInitedInputs.has(curInput) === true) {
							return;
						}
						
						allInitedInputs.add(curInput);
						
						curInput.addEventListener("blur", () => {
							//set the input into a valid state...
							curInput.setAttribute("aria-invalid", false);
							curInput.setCustomValidity("");
							
							var targetErrorMsgContainer = document.getElementById(curInput.getAttribute("aria-errormessage"));
							
							if (targetErrorMsgContainer) {
								targetErrorMsgContainer.setAttribute("hidden", "");
								
								window.deleteAllChildNodes && window.deleteAllChildNodes(targetErrorMsgContainer);
								
								curInput.setCustomValidity("");
							}
							
							//...then convert it into an invalid state if needed
							curInput.checkValidity();
						});
						
						curInput.addEventListener("input", () => {
							//NOTE: we need to constantly trim, so the user can't try to validate a whitespace-only string which actually passes the 'required' validation
							//NOTE: there is no reason to trim <select>s because they do not accept user input
							var isSelectDropdown = curInput.tagName === "SELECT";
							var isRadioButton = curInput.tagName === "INPUT" && curInput.hasAttribute("type") && curInput.getAttribute("type").toLowerCase() === "radio";
							var isCheckbox = curInput.tagName === "INPUT" && curInput.hasAttribute("type") && curInput.getAttribute("type").toLowerCase() === "checkbox";
							
							if (isSelectDropdown === false && isRadioButton === false && isCheckbox === false) {
								var curInputValue = curInput.value;
								var trimmedInputValue = curInputValue.trimStart();
								
								if (curInputValue !== trimmedInputValue) {
									curInput.value = trimmedInputValue;
								}
							}
							
							curInput.setAttribute("aria-invalid", false);
							
							var targetErrorMsgContainerID = curInput.hasAttribute("aria-errormessage") && curInput.getAttribute("aria-errormessage");
							
							var targetErrorMsgContainer = targetErrorMsgContainerID && document.getElementById(targetErrorMsgContainerID);
							
							if (targetErrorMsgContainer) {
								targetErrorMsgContainer.setAttribute("hidden", "");
								
								window.deleteAllChildNodes && window.deleteAllChildNodes(targetErrorMsgContainer);
								
								curInput.setCustomValidity("");
							}
						});
						
						curInput.addEventListener("invalid", e => {
							curInput.setAttribute("aria-invalid", true);
							
							var targetErrorMsgContainerID = curInput.hasAttribute("aria-errormessage") && curInput.getAttribute("aria-errormessage");
							
							var targetErrorMsgContainer = targetErrorMsgContainerID && document.getElementById(targetErrorMsgContainerID);
							
							if (targetErrorMsgContainer) {
								var errorMessage = getFormInputErrorMessage && getFormInputErrorMessage(e.target) || curInput.validationMessage;
								
								if (errorMessage) {
									var errorIcon = buildErrorIcon && buildErrorIcon();
									
									var errorMessageWrapper = buildErrorMessage && buildErrorMessage(errorMessage, errorIcon);
									
									if (errorMessageWrapper) {
										window.deleteAllChildNodes && window.deleteAllChildNodes(targetErrorMsgContainer);
										
										targetErrorMsgContainer.append(errorMessageWrapper);
										targetErrorMsgContainer.removeAttribute("hidden");
										
										curInput.setCustomValidity(errorMessage);
										
										e.preventDefault();
									}
								}
							}
						});
					}
				});
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="expandoAccordion-100">
	; (() => {
		const NAMESPACE = "expandoAccordion";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			var largeViewportMediaQuery;
			var smallViewportMediaQuery;
			var expandoAccordionSelector;
			var expandoAccordionContainerSelector;
			var disableAccordionCollapsingClass;
			
			var isLargeViewport;
			
			var setLargeViewportState = targets => {
				targets.forEach(curTarget => {
					curTarget.setAttribute("open", "");
					
					window.getDirectChildrenByTag(curTarget, "SUMMARY").forEach(curSummary => {
						curSummary.classList.add(disableAccordionCollapsingClass);
					});
				});
			};
			
			var setSmallViewportState = targets => {
				targets.forEach(curTarget => {
					curTarget.removeAttribute("open");
					
					window.getDirectChildrenByTag(curTarget, "SUMMARY").forEach(curSummary => {
						curSummary.classList.remove(disableAccordionCollapsingClass);
					});
				});
			};
			
			var setExpandoAccordionViewportState = () => {
				var allExpandoAccordions = document.querySelectorAll(`${expandoAccordionContainerSelector} ${expandoAccordionSelector}`);
				
				if (window.matchMedia(largeViewportMediaQuery).matches === true && !isLargeViewport) {
					isLargeViewport = true;
					
					setLargeViewportState(allExpandoAccordions);
				} else if (window.matchMedia(smallViewportMediaQuery).matches === true && isLargeViewport) {
					isLargeViewport = false;
					
					setSmallViewportState(allExpandoAccordions);
				}
			};
			
			var setInitialViewportStart = (targets, largeMediaQuery) => {
				if (window.matchMedia(largeMediaQuery).matches === true) {
					isLargeViewport = true;
					
					setLargeViewportState(targets);
				} else {
					isLargeViewport = false;
					
					setSmallViewportState(targets);
				}
			};
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: only allow this library to be initialized once
				if (self.isInited) {
					return false;
				}
				
				largeViewportMediaQuery = options.largeViewportMediaQuery;
				smallViewportMediaQuery = options.smallViewportMediaQuery;
				expandoAccordionSelector = options.expandoAccordionSelector;
				expandoAccordionContainerSelector = options.expandoAccordionContainerSelector;
				disableAccordionCollapsingClass = options.disableAccordionCollapsingClass;
				
				var allExpandoAccordions = document.querySelectorAll(`${expandoAccordionContainerSelector} ${expandoAccordionSelector}`);
				
				setInitialViewportStart(allExpandoAccordions, largeViewportMediaQuery);
				
				window.addEventListener("resize", setExpandoAccordionViewportState);
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="TabsWidget">
	; (() => {
		const NAMESPACE = "Tabs";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var hitboxSizing;
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				hitboxSizing = options.hitboxSizing;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				var allTabLists = document.querySelectorAll('[role="tablist"]');
				
				allTabLists.forEach(curTabList => {
					var tabsContainer = curTabList.parentElement;
					
					var targetTabs = curTabList.querySelectorAll('[role="tab"]');
					
					var targetTabPanels = (() => {
						var output = [];
						
						var nextCandidateTabPanel = curTabList.nextElementSibling;
						
						while (nextCandidateTabPanel && nextCandidateTabPanel.hasAttribute("role") && nextCandidateTabPanel.getAttribute("role") === "tabpanel") {
							output.push(nextCandidateTabPanel);
							
							nextCandidateTabPanel = nextCandidateTabPanel.nextElementSibling;
						}
						
						return output;
					})();
					
					//setup attributes for tabpanels
					targetTabPanels.forEach((targetTabPanel, idx) => {
						//enabled tabbing for all tabpanels
						!targetTabPanel.hasAttribute("tabindex") && targetTabPanel.setAttribute("tabindex", 0);
						
						//set all tabpanels except the first to be hidden
						if (idx > 0) {
							targetTabPanel.setAttribute("hidden", "");
						}
					});
					
					var useTabSelector = targetTabPanels && targetTabPanels.length > 2;
					
					var tabPicker;
					
					if (useTabSelector) {
						tabPicker = document.createElement("select");
					}
					
					//setup attributes for tabs and init mobile tabpicker
					targetTabs.forEach((curTab, idx) => {
						var curTabID = curTab.hasAttribute("id") && curTab.getAttribute("id");
						
						var curTabPanel = targetTabPanels[idx];
						var curTabPanelID = curTabPanel && curTabPanel.hasAttribute("id") && curTabPanel.getAttribute("id");
						
						if (useTabSelector) {
							var curTabSelector = document.createElement("option");
							curTabSelector.textContent = curTab.textContent;
							curTabSelector.setAttribute("value", curTabSelector.textContent);
						}
						
						//sync up 'aria-labelledby' and 'aria-controls' between tabs and tabpanels 
						if (curTabPanelID && curTabPanelID !== "") {
							!curTab.hasAttribute("aria-controls") && curTab.setAttribute("aria-controls", curTabPanelID);
							useTabSelector && curTabSelector.setAttribute("aria-controls", curTabPanelID);
							!curTabPanel.hasAttribute("aria-labelledby") && curTabPanel.setAttribute("aria-labelledby", curTabID);
						}
						
						//only set the first tab to be selected
						if (idx === 0) {
							curTab.setAttribute("aria-selected", true);
							curTab.setAttribute("tabindex", 0);
							useTabSelector && curTabSelector.setAttribute("aria-selected", true);
						} else {
							curTab.setAttribute("aria-selected", false);
							curTab.setAttribute("tabindex", -1);
							useTabSelector && curTabSelector.setAttribute("aria-selected", false);
						}
						
						useTabSelector && tabPicker.append(curTabSelector);
					});
					
					if (useTabSelector && tabsContainer) {
						tabsContainer.classList += " useDropdown";
						tabsContainer.prepend(tabPicker);
					}
				});
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="infowindow-100">
	; (() => {
		const NAMESPACE = "InfoWindow";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			var infoWindowButtonSelector;
			var getInfoWindow;
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				infoWindowButtonSelector = options.infoWindowButtonSelector;
				getInfoWindow = options.getInfoWindow;
				
				window.findDynamicComponent && window.findDynamicComponent({
					parentContainer: "main"
					, targetSelector: infoWindowButtonSelector
					, callbackFunction: curInfoWindowButton => {
						//GUARD: the InfoWindow button must be a <button>
						if (curInfoWindowButton.tagName !== "BUTTON") {
							return;
						}
						
						var targetInfoWindow = getInfoWindow && getInfoWindow(curInfoWindowButton);
						
						//GUARD: the InfoWindow button must be a <dialog>
						if (!targetInfoWindow || targetInfoWindow && targetInfoWindow.tagName !== "DIALOG") {
							curInfoWindowButton.remove();
							
							return;
						}
						
						//GUARD: if the button already has aria-expanded, assume that button is already initialized and escape immediately to prevent re-initing italics
						//NOTE: each of the setAttribute() below will cause a mutation 'event' to be thrown and this GUARD is needed to prevent the click() handler from being added multiple times.
						if (curInfoWindowButton.hasAttribute("aria-expanded") === true) {
							return;
						}
						
						var isButtonType = curInfoWindowButton.hasAttribute("type") && curInfoWindowButton.getAttribute("type") === "button";
						
						var isInfoWindowIcon = curInfoWindowButton.hasAttribute("data-no-infowindow-icon") === true ? false : true;
						
						var renderAsButton = isButtonType === true && isInfoWindowIcon === false;
						
						var targetInfoWindowID = targetInfoWindow.hasAttribute("id") && targetInfoWindow.getAttribute("id");
						
						curInfoWindowButton.setAttribute("type", "button");
						renderAsButton === false && curInfoWindowButton.setAttribute("data-type", "unstyledButton");
						targetInfoWindowID && curInfoWindowButton.setAttribute("aria-describedby", targetInfoWindowID);
						curInfoWindowButton.setAttribute("aria-expanded", false);
						curInfoWindowButton.setAttribute("aria-haspopup", true);
						targetInfoWindowID && curInfoWindowButton.setAttribute("aria-controls", targetInfoWindowID);
						
						curInfoWindowButton.addEventListener("click", e => {
							var curInfoWindowButton = e.target;
							
							targetInfoWindow && targetInfoWindow.showModal();
						});
					}
				});
			};
		}).apply(null, args);
	})();
</script><script class="autocomplete-100">
	; (() => {
		const NAMESPACE = "Autocomplete";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var searchTermMinLength;
			var numberOfResults;
			var suggesterPaths;
			
			var profiles = {};
			var curSearchTerm;
			
			self.useMockAPI;
			
			self.getSearchSuggestions = async (searchTerm, profileName) => {
				var curProfile = profiles[profileName];
				
				//GUARD: do nothing if there is no profile
				if (!curProfile) {
					return;
				}
				
				var populateSuggestions = self.populateSuggestions; //??? /*self.populateSuggestions.curry(suggestionsList, null)*/;
				
				if (self.useMockAPI) {
					/* debug mode */ 
				} else {
					//??? need to make MJS version of TemporaryStorage
					var cacheJSONString = window.TemporaryStorage && window.TemporaryStorage.getItem(curProfile.storageKey);
					var cache = cacheJSONString && JSON.parse(cacheJSONString);
					var cachedSuggestions = cache && cache[searchTerm];
					
					if (cachedSuggestions) {
						populateSuggestions(cachedSuggestions, profileName);
					} else {
						if (curProfile.searchProxy && curProfile.querySearchProxy) {
							try {
								const JS_TYPES_HELPER_MODULE_URL_STRING = "https://tlweblibs.translink.ca/JSTypesHelpers-1.2.0.mjs";
								
								var jsTypesHelperModuleURL = JS_TYPES_HELPER_MODULE_URL_STRING && new URL(JS_TYPES_HELPER_MODULE_URL_STRING);
								
								var { getType } = jsTypesHelperModuleURL && await import(jsTypesHelperModuleURL);
								
								if (getType(curProfile.searchProxy) === getType.asyncFunction) {
									//??? I should cache the searchProxy object instead of recreating it everytime right?
									var foundSearchProxy = curProfile.searchProxy && await curProfile.searchProxy();
									
									foundSearchProxy && curProfile.querySearchProxy(foundSearchProxy, searchTerm, curProfile.numberOfResults, populateSuggestions, profileName)
								} else {
									curProfile.querySearchProxy(curProfile.searchProxy, searchTerm, curProfile.numberOfResults, populateSuggestions, profileName)
								}
							} catch (error) {
								console.error(error);
							}
						} else if (curProfile.apiURL) {
							//??? validate 'curProfile.apiURL' as real URL?
							var searchQueryURL = curProfile.buildSearchQueryURL(curProfile.apiURL, searchTerm, curProfile.queryCount, curProfile.suggesterPaths);  //??? refactor into context?
							
							try {
								var response = searchQueryURL && await fetch(searchQueryURL);
								var results = response && response.ok === true && response.json && await response.json();
								
								//GUARD: do nothing if there are no results from the API
								if (!results) {
									return;
								}
								
								var output = curProfile.filterSearchQueryResults && curProfile.filterSearchQueryResults(searchTerm, results) || results;
								
								if (output && populateSuggestions) {
									curProfile.injectSearchQueryResults && curProfile.injectSearchQueryResults(output);
									
									populateSuggestions(output, profileName);
								}
							} catch (error) {
								console.error(error);
							}
						}
					}
				}
			};
			
			self.clearSuggestions = suggestionsContainer => {
				window.deleteAllChildNodes && window.deleteAllChildNodes(suggestionsContainer);
			};
			
			self.populateSuggestions = (suggestions, profileName) => {
				var curProfile = profiles[profileName];
				
				self.clearSuggestions(curProfile.suggestionsList);
				
				var validSuggestions = curProfile.parseSearchQueryResults(suggestions, curSearchTerm);
				
				curProfile.sortSuggestions && validSuggestions.sort(curProfile.sortSuggestions);
				
				validSuggestions
				.slice(0, curProfile.numberOfResults)
				.forEach(curSuggestion => {
					var curSuggestionItem = curProfile.createSuggestion && curProfile.createSuggestion(curSuggestion) || self.createSuggestion(curSuggestion);
					
					curProfile.suggestionsList.append(curSuggestionItem);
				});
				
				//add to cache
				if (curProfile.storageKey && curSearchTerm && curSearchTerm.length >= curProfile.searchTermMinLength) {
					var cacheJSONString = window.TemporaryStorage && window.TemporaryStorage.getItem(curProfile.storageKey);
					var curSuggestionsList = cacheJSONString && JSON.parse(cacheJSONString) || {};
					
					if (!curProfile.doesSearchQueryResultsHaveErrors || curProfile.doesSearchQueryResultsHaveErrors(suggestions) === false) {
						curSuggestionsList[curSearchTerm] = suggestions;
						
						window.TemporaryStorage && window.TemporaryStorage.setItem(curProfile.storageKey, JSON.stringify(curSuggestionsList));
					}
				}
			};
			
			self.createSuggestion = curSuggestion => {
				var suggestionItem = document.createElement("option");
				suggestionItem.setAttribute("value", curSuggestion);
				suggestionItem.textContent = curSuggestion;
				
				return suggestionItem;
			};
			
			self.load = (profileName, options) => {
				//??? should check that profileName is a string?
				profiles[profileName] = profiles[profileName] || {};
				
				var curProfile = profiles[profileName];
				
				curProfile.apiURL = options.apiURL;
				curProfile.searchProxy = options.searchProxy;
				curProfile.buildSearchQueryURL = options.buildSearchQueryURL;
				curProfile.filterSearchQueryResults = options.filterSearchQueryResults;
				curProfile.querySearchProxy = options.querySearchProxy;
				curProfile.injectSearchQueryResults = options.injectSearchQueryResults;
				curProfile.parseSearchQueryResults = options.parseSearchQueryResults;
				curProfile.doesSearchQueryResultsHaveErrors = options.doesSearchQueryResultsHaveErrors;
				curProfile.sortSuggestions = options.sortSuggestions;
				curProfile.createSuggestion = options.createSuggestion;
				curProfile.suggestionsListID = options.suggestionsListID;
				curProfile.onAfterBuildSuggestionsList = options.onAfterBuildSuggestionsList;
				curProfile.onFocus = options.onFocus;
				curProfile.searchTermMinLength = options.searchTermMinLength || searchTermMinLength;
				curProfile.numberOfResults = options.numberOfResults || numberOfResults;
				curProfile.queryCount = options.queryCount || curProfile.numberOfResults;
				curProfile.suggesterPaths = options.suggesterPaths || suggesterPaths;
				curProfile.storageKey = options.storageKey;
				
				var searchFieldSelector = `${options.searchFieldSelector}[list="${curProfile.suggestionsListID}"], ${options.searchFieldSelector}[data-list="${curProfile.suggestionsListID}"]`;
				
				window.findDynamicComponent({
					parentContainer: "body"
					, targetSelector: searchFieldSelector
					, callbackFunction: curSearchField => {
						curProfile.onFocus && curSearchField.addEventListener("focus", async e => {
							var target = e.target;
							
							curProfile.onFocus && target && curProfile.onFocus(target);
						});
						
						curSearchField.addEventListener("input", async e => {
							var target = e.target;
							
							curSearchTerm = target.value;
							
							//handle when the user types a search term
							if (curSearchTerm.length >= curProfile.searchTermMinLength) {
								self.getSearchSuggestions(target.value, profileName);
							} else {
								self.clearSuggestions(curProfile.suggestionsList);
							}
						});
					}
				});
				
				//create search datalist
				curProfile.suggestionsList = document.createElement("datalist");
				curProfile.suggestionsList.setAttribute("id", curProfile.suggestionsListID);
				
				document.documentElement.append(curProfile.suggestionsList);
				
				curProfile.onAfterBuildSuggestionsList && curProfile.onAfterBuildSuggestionsList(curProfile.suggestionsList, searchFieldSelector);
			};
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				searchTermMinLength = options.searchTermMinLength;
				numberOfResults = options.numberOfResults;
				suggesterPaths = options.suggesterPaths;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="tripplannersearch">
	; (() => {
		const NAMESPACE = "TripPlannerSearch";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var formID;
			var originFieldSelector;
			var destinationFieldSelector;
			var swapLocationsButtonSelector;
			var arriveOrDepartSelector;
			var tripPreferencesSelector;
			var routePreferencesSelector;
			var getTripDateTime;
			var buildForm;
			var buildRedirectURL;
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				formID = options.formID;
				originFieldSelector = `[form="${formID}"]${options.originFieldSelector}`;
				destinationFieldSelector = `[form="${formID}"]${options.destinationFieldSelector}`;
				swapLocationsButtonSelector = options.swapLocationsButtonSelector;
				
				buildForm = options.buildForm;
				buildRedirectURL = options.buildRedirectURL;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				var originField = document.querySelector(originFieldSelector);
				
				//GUARD: do nothing if any of the fields is missing
				if (!originField) {
					return; 
				}
				
				var destinationField = document.querySelector(destinationFieldSelector);
				
				if (!destinationField) {
					return; 
				}
				
				//init <form>
				var formElement = buildForm && buildForm(formID);
				
				//GUARD: do nothing if the form element wasn't created
				if (!formElement) {
					return;
				}
				
				formElement && document.documentElement.append(formElement);
				
				formElement && formElement.addEventListener("submit", e => {
					var origin = originField && originField.value;
					var destination = destinationField && destinationField.value;
					
					var redirectURL = buildRedirectURL && buildRedirectURL(origin, destination);
					
					if (redirectURL) {
						window.open(redirectURL, "_blank", "noopener");
					}
					
					e.preventDefault();
					return false;
				});
				
				//init origin/destination swap button
				var swapLocationsButton = document.querySelector(swapLocationsButtonSelector);
				
				swapLocationsButton && swapLocationsButton.addEventListener("click", () => {
					var originField = document.querySelector(originFieldSelector);
					var destinationField = document.querySelector(destinationFieldSelector);
					
					var swap = originField.value;
					
					originField.value = destinationField.value;
					destinationField.value = swap;
				});
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="nextbussearch-100">
	; (() => {
		var NAMESPACE = "NextBusSearch";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var apiURL;
			var formID;
			var buildForm;
			var buildRedirectURL;
			var useCurrentLocationButtonSelector;
			var searchBoxSelector;
			var getViewPreference;
			var getTimePreference;
			var onSearchTermChange;
			var onUseCurrentLocation;
			var onSubmit;
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				apiURL = options.apiURL;
				formID = options.formID;
				buildForm = options.buildForm;
				buildRedirectURL = options.buildRedirectURL;
				useCurrentLocationButtonSelector = `[form="${formID}"]${options.useCurrentLocationButtonSelector}`;
				searchBoxSelector = `[form="${formID}"]${options.searchBoxSelector}`;
				getViewPreference = options.getViewPreference;
				getTimePreference = options.getTimePreference;
				onSearchTermChange = options.onSearchTermChange;
				onUseCurrentLocation = options.onUseCurrentLocation;
				onSubmit = options.onSubmit;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				var searchBoxes = searchBoxSelector && document.querySelectorAll(searchBoxSelector);
				
				//GUARD: do nothing if there are no searchboxes
				if (!searchBoxes || searchBoxes.length === 0) {
					return;
				}
				
				var formElement = buildForm && buildForm(formID);
				
				//GUARD: do nothing if the form element wasn't created
				if (!formElement) {
					return;
				}
				
				document.documentElement.append(formElement);
				
				formElement.addEventListener("submit", onSubmit);
				
				searchBoxes && searchBoxes.forEach(curSearchBox => {
					curSearchBox.addEventListener("change", e => {
						var targetSearchBox = e.target;
						var viewPreference = getViewPreference && getViewPreference();
						var timePreference = getTimePreference && getTimePreference();
						
						onSearchTermChange && onSearchTermChange(formID, apiURL, targetSearchBox.value, viewPreference, timePreference);
					});
				});
				
				var currentLocationButtons = document.querySelectorAll(useCurrentLocationButtonSelector);
				
				currentLocationButtons && currentLocationButtons.forEach(curButton => {
					curButton.addEventListener("click", e => {
						var viewPreference = getViewPreference && getViewPreference();
						var timePreference = getTimePreference && getTimePreference();
						
						onUseCurrentLocation && onUseCurrentLocation(formID, apiURL, viewPreference, timePreference);
						
						e.preventDefault();
						return false;
					});
				});
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="favourites">
	; (() => {
		var NAMESPACE = "Favourites";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		var get = window.PersistentStorage.getItem;
		
		var set = window.PersistentStorage.setItem;
		
		var getAllKeys = window.PersistentStorage.getAllKeys;
		
		var remove = window.PersistentStorage.removeItem;
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE, get, set, getAllKeys, remove];
		
		; ((ns, NAMESPACE, get, set, getAllKeys, remove) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var displayListSelector;
			var storageNamespace;
			var gtfsContext;
			var getRouteStopName;
			var formatRouteStopName;
			var addDeleteFavouriteButtonSelector;
			var addFavourite;
			var deleteFavourite;
			var renderFavourite;
			var onAfterLoad;
			
			self.setGTFSContext = newGTFSContext => {
				gtfsContext = newGTFSContext;
			};
			
			self.setFavourite = (favouriteName, favouriteItem) => {
				//GUARD: handle the case where the user already has a favourite with the same name
				if (self.doesFavouriteExist(favouriteName)) {
					//??? do what?
					return false;
				}
				
				return set(storageNamespace + favouriteName, favouriteItem);
			};
			
			self.getFavourite = favouriteName => {
				return get(storageNamespace + favouriteName);
			};
			
			self.getAllFavouritesNames = () => {
				var output = getAllKeys(storageNamespace);
				
				//remove the namespace from the return key name
				output = output.filter(curName => {
					if (curName.startsWith(storageNamespace) === true) {
						return curName;
					}
				});
				
				output = output.map(curName => {
					return curName.replace(storageNamespace, "");
				});
				
				return output;
			};
			
			self.doesFavouriteExist = favouriteName => {
				//GUARD: do nothing if no favourite name was passed
				if (!favouriteName) {
					return;
				}
				
				//???migrate this logic to the base localStorage library; this 'null' check is errorprone and should be hidden in a library
				return get(favouriteName) !== undefined;
			};
			
			self.updateFavouriteName = (previousName, newName, allowOverwrite) => {
				//GUARD: do nothing if both the new name and the old name are the same
				if (previousName === newName) {
					return;
				}
				
				var previousItem = self.getFavourite(previousName);
				var isNewNameUsed = self.doesFavouriteExist(newName);
				
				//GUARD: do nothing if there is no previous item
				if (!previousItem) {
					return;
				}
				
				//GUARD: do nothing if the new name is already being used and overwriting is not allowed
				if (isNewNameUsed && !allowOverwrite) {
					return;
				}
				
				self.setFavourite(newName, previousItem)
				
				self.removeFavourite(previousName);
			};
			
			self.removeFavourite = favouriteName => {
				remove(storageNamespace + favouriteName);
			};
			
			self.getFavouriteItem = targetItem => {
				var output;
				
				output = self.getAllFavouritesNames().find(curName => {
					if (targetItem === self.getFavourite(curName)) {
						return true;
					}
				});
				
				return output;
			};
			
			self.doesFavouriteItemExist = targetItem => {
				var output;
				
				output = self.getAllFavouritesNames().some(curName => {
					if (targetItem === self.getFavourite(curName)) {
						return true;
					}
				});
				
				return output;
			};
			
			self.renderAllFavourites = () => {
				var displayList = document.querySelector(displayListSelector);
				
				//GUARD: do nothing if there is no display list
				if (!displayList) {
					return;
				}
				
				//always empty the display list before using it
				while (displayList.firstChild) {
					displayList.removeChild(displayList.firstChild);
				}
				
				self.getAllFavouritesNames().forEach(curName => {
					var favouriteItem = self.getFavourite(curName);
					
					//GUARD: do nothing if there is no item found
					if (!favouriteItem) {
						return;
					}
					
					var favouriteElement = renderFavourite(curName, favouriteItem);
					
					displayList.appendChild(favouriteElement);
				});
				
				onAfterLoad && window.getType(onAfterLoad) === window.getType.function && onAfterLoad();
			};
			
			var updateSetAddDelButton = () => {
				//set add/del button if the current page is an existing favourite
				var setAddDelButton = Favourites.doesFavouriteItemExist(window.location.href);
				
				var newAriaPressedValue = setAddDelButton ? "true" : "false";
				
				var allAddDelButtons = document.querySelectorAll(addDeleteFavouriteButtonSelector);
				
				allAddDelButtons.forEach(curAddDelButton => {
					curAddDelButton.setAttribute("aria-pressed", newAriaPressedValue);
					curAddDelButton.setAttribute("aria-expanded", newAriaPressedValue);
				});
			};
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				displayListSelector = options.displayListSelector;
				storageNamespace = options.storageNamespace;
				getRouteStopName = options.getRouteStopName;
				formatRouteStopName = options.formatRouteStopName;
				addDeleteFavouriteButtonSelector = options.addDeleteFavouriteButtonSelector;
				addFavourite = options.addFavourite;
				deleteFavourite = options.deleteFavourite;
				renderFavourite = options.renderFavourite;
				onAfterLoad = options.onAfterLoad;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				var allAddDelButtons = document.querySelectorAll(addDeleteFavouriteButtonSelector);
				
				allAddDelButtons.forEach(curAddDelButton => {
					curAddDelButton.addEventListener("click", e => {
						var target = e.target;
						
						//doDelete: if the button is pressed-down ([aria-pressed="true"]), that means it is currently a favourite.  So pressing it again should unfavourite it.
						var doDelete = target.hasAttribute("aria-pressed") && target.getAttribute("aria-pressed");
						
						if (doDelete === "true") {
							deleteFavourite && deleteFavourite(target);
						} else if (doDelete === "false") {
							addFavourite && addFavourite(target, getRouteStopName && getRouteStopName(gtfsContext, formatRouteStopName));
						}
					});
				});
				
				updateSetAddDelButton && updateSetAddDelButton();
				
				window.addEventListener("hashchange", updateSetAddDelButton);
				
				onAfterLoad && onAfterLoad();
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="nextbussettings-100">
	; (() => {
		const NAMESPACE = "NextBusSettings";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		var storage = window.PersistentStorage;
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE, storage];
		
		; ((ns, NAMESPACE, storage) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var storageNamespace;
			var settings;
			
			self.getSetting = settingName => {
				return storage.getItem(`${storageNamespace}.${settingName}`);
			};
			
			self.setSetting = (settingName, settingValue) => {
				return storage.setItem(`${storageNamespace}.${settingName}`, settingValue);
			};
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				storageNamespace = options.storageNamespace;
				settings = options.settings;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				//GUARD: do nothing if there are no settings to get or set
				if (!settings) {
					return;
				}
				
				settings.forEach(curSetting => {
					var curSettingSelector = `input[type="radio"][name="${curSetting}"]`;
					
					document.querySelectorAll(curSettingSelector).forEach(curInput => {
						curInput.addEventListener("input", e => {
							var target = e.target;
							
							var settingValue = target.value;
							
							self.setSetting(curSetting, settingValue);
						});
						
						if (curInput.value === self.getSetting(curSetting)) {
							curInput.setAttribute("checked", "");
						}
					});
				});
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="toc-script">
	; (() => {
		const NAMESPACE = "TableOfContents";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var headersSelector;
			var excludeHeadersSelector;
			var tableOfContentsContainerSelector;
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}

				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}

				/* PARSE CONFIGURATION */
				headersSelector = options.headersSelector;
				excludeHeadersSelector = options.excludeHeadersSelector;
				tableOfContentsContainerSelector = options.tableOfContentsContainerSelector;
				/* end of PARSE CONFIGURATION */

				/* RUN INIT */
				var tableOfContentsElements = document.querySelectorAll(tableOfContentsContainerSelector);

				//GUARD: do nothing if there are no containers
				if (tableOfContentsElements.length === 0) {
					return;
				}
				
				tableOfContentsElements.forEach(curContainer => {
					var curContainerIndex = Array.from(curContainer.closest("[data-block-name]").parentElement.children).indexOf(curContainer.closest("[data-block-name]"));  //??? HACKY
					
					if (curContainer.tagName === "SELECT") {
						var defaultLabel = curContainer.hasAttribute("data-label") && curContainer.getAttribute("data-label");
						
						if (defaultLabel) {
							var defaultLabelElement = document.createElement("option");
							defaultLabelElement.setAttribute("disabled", "");
							defaultLabelElement.setAttribute("selected", "");
							defaultLabelElement.textContent = defaultLabel;
							
							curContainer.append(defaultLabelElement);
						}
					}
					
					var targetHeaderSelector = curContainer.hasAttribute("data-target-header") && curContainer.getAttribute("data-target-header") || headersSelector;
					
					//GUARD: do nothing if there is no selector for the headers
					if (!targetHeaderSelector) {
						return;
					}
					
					var mainElement = document.querySelector("main");
					
					//GUARD: do nothing if there is no <main> element
					if (!mainElement) {
						return;
					}
					
					var allTargetedHeaderLinks = [];
					
					var allFilteredHeaderElements = ((allTargets, allFilteredTargets) => {
						allTargets = Array.from(allTargets);
						allFilteredTargets = Array.from(allFilteredTargets);
						
						if (allTargets.length === 0 || allFilteredTargets.length === 0) {
							return allTargets;
						} else {
							return allTargets.filter(targetElement => {
								return allFilteredTargets.indexOf(targetElement) === -1;
							});
						}
					})(mainElement.querySelectorAll(targetHeaderSelector), mainElement.querySelectorAll(excludeHeadersSelector));
					
					allFilteredHeaderElements.forEach(curHeadingElement => {
						var curHeadingElementIndex = Array.from(curHeadingElement.closest("[data-block-name]").parentElement.children).indexOf(curHeadingElement.closest("[data-block-name]"));  //??? HACKY
						
						//GUARD: do not display this heading if it appears before this TOC
						if (curHeadingElementIndex <= curContainerIndex) {
							return;
						}
						
						var headerText = curHeadingElement.textContent;
						
						if (headerText) {
							//NOTE: get the current element if it has an ID, otherwise assume it is inside an accordion and return the accordion ID element (<summary>)
							var curHeadingIDElement = curHeadingElement.hasAttribute("id") && curHeadingElement || curHeadingElement.closest("summary");
							
							var targetID = curHeadingIDElement && curHeadingIDElement.hasAttribute("id") && curHeadingIDElement.getAttribute("id");
							
							if (targetID) {
								var listItemElement = document.createElement("li");
								var textContainer = document.createElement("p");
								var linkElement = document.createElement("a");
								
								linkElement.setAttribute("href", `#${targetID}`);  //??? replace with URL Object???
								linkElement.setAttribute("title", `Link to '${headerText}' section on this page.`);
								linkElement.textContent = headerText;
								
								textContainer.append(linkElement);
								listItemElement.append(textContainer);
								allTargetedHeaderLinks.push(listItemElement);
							}
						}
					});
					
					//GUARD: do nothing if there are no header links
					if (allTargetedHeaderLinks.length === 0) {
						return;
					}
					
					allTargetedHeaderLinks.forEach(curHeaderLink => {
						if (curContainer.tagName === "SELECT") {
							var linkElement = curHeaderLink.querySelector("a");
							
							var linkURL = linkElement.hasAttribute("href") && linkElement.getAttribute("href");
							
							var linkText = linkElement.textContent;
							
							var listElement = document.createElement("option");
							listElement.setAttribute("value", linkURL);  //??? replace with URL Object Pattern
							listElement.textContent = linkText;
							
							curContainer.append(listElement);
							
							curContainer.addEventListener("change", e => {
								var target = e.target;
								
								window.location.hash = target.value;
							});
						} else {
							curHeaderLink.cloneNode && curContainer.append(curHeaderLink.cloneNode(true));
						}
					});
				});
				/* end of RUN INIT */

				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="fieldsync">
	; (() => {
		const NAMESPACE = "FieldSync";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var watches;
			
			self.add = watches => {
				//GUARD: do nothing if watches does not exist
				if (!watches || watches.length === 0) {
					return;
				}
				
				//if the passed argument isn't an array, then we can manually convert it to an array
				if (window.getType(watches) !== window.getType.array) {
					watches = [watches];
				}
				
				watches.forEach && watches.forEach(curWatch => {
					var targetSelector = curWatch.targetSelector;
					var targetEvent = curWatch.targetEvent;
					var isLazy = curWatch.isLazy;
					var action = curWatch.action;
					var callback = curWatch.callback;
					
					if (isLazy === true) {
						var allTargets = new Set();
						
						window.findDynamicComponent({
							parentContainer: "main"
							, targetSelector: targetSelector
							, callbackFunction: newTarget => {
								//GUARD: do nothing if the new target isn't valid
								if (!newTarget) {
									return;
								}
								
								if (allTargets.has(newTarget) === false) {
									newTarget.addEventListener(targetEvent, e => {
										action && action(e, allTargets);
										callback && callback(e, allTargets);
									});
									
									allTargets.add(newTarget);
								}
							}
						});
					} else {
						var targets = document.querySelectorAll(targetSelector);
						
						targets.forEach(curTarget => {
							curTarget.addEventListener(targetEvent, e => {
								action && action(e, targets);
								callback && callback(e, targets);
							});
						});
					}
				});
			};
			
			self.check = (e, targets) => {
				var isChecked = e.target && e.target.checked;
				
				targets.forEach(curTarget => {
					if (isChecked) {
						curTarget.checked = true;
					} else {
						curTarget.checked = false;
					}
				});
			};
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				watches = options.watches;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				watches && self.add(watches);
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="numbermasker-100">
	; (() => {
		const NAMESPACE = "NumberMasker";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		var maskNumber = (textString, mask, numberPlaceholder) => {
			var output = [];
			
			//GUARD: do nothing if there is no input or no mask
			if (!textString || !mask) {
				return output.join("");
			}
			
			//GUARD: do nothing if the mask does not contain any placeholders
			if (mask.indexOf(numberPlaceholder) === -1) {
				return output.join("");
			}
			
			var REGEX_FOR_ALL_NON_NUMERIC_CHARACTERS = /[^\d]/g;
			
			var allNumbers = textString.replace(REGEX_FOR_ALL_NON_NUMERIC_CHARACTERS, "").split("");
			
			//GUARD: do nothing if there are no numbers in the input
			if (!allNumbers) {
				return output.join("");
			}
			
			var maskLookup = mask.split("");
			
			var curNumberIndex = 0;
			
			var allNumbersLength = allNumbers.length;
			
			maskLookup.forEach((curCharacter, curIndex) => {
				//GUARD: do nothing if there are no more inputted numbers
				if (curNumberIndex >= allNumbersLength) {
					return;
				}
				
				if (curCharacter === numberPlaceholder) {
					output[curIndex] = allNumbers[curNumberIndex];
					curNumberIndex = curNumberIndex + 1;
				} else {
					output[curIndex] = curCharacter;
				}
			});
			
			return output.join("");
		};
		
		var args = [ns, NAMESPACE, maskNumber];
		
		; ((ns, NAMESPACE, maskNumber) => {
			var self = ns;
			
			self.maskNumber = maskNumber;
			
			self.isInited = false;

			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				var allNumberMasks = options.numberMasks;
				
				allNumberMasks && allNumberMasks.forEach && allNumberMasks.forEach(curNumberMask => {
					var targetSelector = curNumberMask.targetSelector;
					var mask = curNumberMask.mask;
					var numberPlaceholder = curNumberMask.numberPlaceholder || "0";
					
					//GUARD: do nothing if there is no target selector, mask, or number placeholder
					if (!targetSelector || !mask || !numberPlaceholder) {
						return;
					}
					
					window.findDynamicComponent && window.findDynamicComponent({
						parentContainer: "main"
						, targetSelector: targetSelector
						, callbackFunction: curTarget => {
							var curTargetPreviousValue = curTarget.value;
							
							curTarget.addEventListener("input", e => {
								var target = e.target;
								
								//NOTE: we need to track the position of the cursor so we can reset it to the same position after inserting the updated masked number
								var curCursorPos = target.selectionStart;
								
								var input = target.value;
								
								var maskedInput = self.maskNumber(input, mask, numberPlaceholder, "1");
								
								if (input !== maskedInput) {
									target.value = maskedInput;  //NOTE: after this runs, the cursor position will be shifted to the end of the textbox
									
									var newCursorIndex = curCursorPos;
									
									if (maskedInput.length > curTargetPreviousValue.length) {
										// user has added a character
										var maskStringAfterCursor = mask.slice(curCursorPos - 1); //NOTE: we need to use "- 1" because we need the position of the cursor BEFORE the input, in the case that the input added a value into a mask-char's position
										
										var numCharUntilNextPlaceholder = maskStringAfterCursor.indexOf(numberPlaceholder);
										
										if (numCharUntilNextPlaceholder > -1) {
											newCursorIndex = curCursorPos + numCharUntilNextPlaceholder;  //NOTE: "1" represents the single character the user added
										}
									}
									
									target.selectionStart = newCursorIndex;  //NOTE: if we don't reset the cursor position here, after every keypress in the middle of the textbox, their cursor will be moved back to the end of the textbox.  that means they would only be able to edit one character at a time in the middle of the textbox.
									target.selectionEnd = newCursorIndex;  //NOTE: we must also set the selectionEnd to the same cursor position to prevent a multiple character text selection
								}
								
								curTargetPreviousValue = maskedInput;
							});
						}
					});
				});
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="GTFSStopTimes">
	; (() => {
		const NAMESPACE = "GTFSStopTimes";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		var getDateObjectFromDateInput = window.getDateObjectFromDateInput || (dateInput => {
			var output;
			
			var dateInputValue = dateInput && dateInput.value;
			
			//GUARD: do nothing if there is no date input value
			if (!dateInputValue) {
				return output;
			}
			
			var dateInputValueParts = dateInputValue && dateInputValue.split("-");
			
			var dateYear = parseInt(dateInputValueParts[0], 10);
			var dateMonth = parseInt(dateInputValueParts[1], 10) - 1;
			var dateDate = parseInt(dateInputValueParts[2], 10);
			
			output = new Date(dateYear, dateMonth, dateDate);
			
			return output;
		});
		
		//??? should be tlHelper
		var bestAttemptGetFormEventSubmitterButton = window.bestAttemptGetFormEventSubmitterButton || (submitEvent => {
			var output;
			
			var target = submitEvent.target;
			
			var formName = target && target.getAttribute("id");
			
			output = submitEvent.submitter || document.querySelector(`[type="submit"][form="${formName}"], form[id="${formName}"] [type="submit"]`);
			
			return output;
		});
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE, getDateObjectFromDateInput, bestAttemptGetFormEventSubmitterButton];
		
		; ((ns, NAMESPACE, getDateObjectFromDateInput, bestAttemptGetFormEventSubmitterButton) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var apiURL;
			var sheetEndDateApiURL;
			var formID;
			var buildForm;
			var onAfterGetSheetEndDate;
			var routeLineNumber;
			var getRelatedGTFSPlaceURL;
			var getDateInputs;
			var restoreUserInputtedValues;
			var getStartTimeInput;
			var getEndTimeInput;
			var getDirectionInputs;
			var getCurrentDirectionValue;  //??? update this to replace "current" with "cur"
			var getOutputElements;
			var getNextDayInformationalMessageContainers;
			var onChangeDate;
			var onChangeDirection;
			var updateDirectionLabels;
			var enableToolbarButtons;
			var disableToolbarButtons;
			var showNextDayInformationalMessage;
			var createPersistentDatamodel;
			var createRenderableDatamodel;
			var isShowingLocationsWithoutStoptimes;
			var clearAllStops;
			var filterAllStopTimes;
			var buildAllStops;
			var renderNextStop;
			var onAfterRenderAllStops;
			
			var gtfsData = {};
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				apiURL = options.apiURL;
				sheetEndDateApiURL = options.sheetEndDateApiURL;
				routeLineNumber = options.routeLineNumber;
				getRelatedGTFSPlaceURL = options.getRelatedGTFSPlaceURL;
				formID = options.formID;
				buildForm = options.buildForm;
				onAfterGetSheetEndDate = options.onAfterGetSheetEndDate;
				getDateInputs = options.getDateInputs;
				restoreUserInputtedValues = options.restoreUserInputtedValues;
				getStartTimeInput = options.getStartTimeInput;
				getEndTimeInput = options.getEndTimeInput;
				getDirectionInputs = options.getDirectionInputs;
				getCurrentDirectionValue = options.getCurrentDirectionValue;
				getOutputElements = options.getOutputElements;
				getNextDayInformationalMessageContainers = options.getNextDayInformationalMessageContainers;
				onChangeDate = options.onChangeDate;
				onChangeDirection = options.onChangeDirection;
				updateDirectionLabels = options.updateDirectionLabels;
				enableToolbarButtons = options.enableToolbarButtons;
				disableToolbarButtons = options.disableToolbarButtons;
				showNextDayInformationalMessage = options.showNextDayInformationalMessage;
				createPersistentDatamodel = options.createPersistentDatamodel;
				createRenderableDatamodel = options.createRenderableDatamodel;
				isShowingLocationsWithoutStoptimes = options.isShowingLocationsWithoutStoptimes;
				clearAllStops = options.clearAllStops;
				filterAllStopTimes = options.filterAllStopTimes;
				buildAllStops = options.buildAllStops;
				renderNextStop = options.renderNextStop;
				onAfterRenderAllStops = options.onAfterRenderAllStops;
				
				var getScheduleSearchContext = () => {
					var context = {};
					
					context.apiURL = apiURL;
					context.formID = formID;
					context.dateInput = getDateInputs && getDateInputs()[0];
					context.directionInput = getDirectionInputs && getDirectionInputs()[0];
					context.outputElements = getOutputElements && getOutputElements();
					context.nextDayInformationalElements = getNextDayInformationalMessageContainers && getNextDayInformationalMessageContainers(SchedulesTimeFilterForm);
					context.getDateObjectFromDateInput = getDateObjectFromDateInput;
					
					return context;
				};
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				var SchedulesTimeFilterForm = buildForm && buildForm(apiURL);
				
				//GUARD: do nothing if the form element wasn't made
				if (!SchedulesTimeFilterForm) {
					return;
				}
				
				document.documentElement.append(SchedulesTimeFilterForm);
				
				//get SHEET END TIME
				sheetEndDateApiURL && fetch(sheetEndDateApiURL) 
				.then(response => {
					response.json()
					.then(result => {
						onAfterGetSheetEndDate && onAfterGetSheetEndDate(() => {
							return result;
						});
					});
				})
				.catch(error => {
					console.error(error);
					//??? temporary error handling when API fails
					var allDataContainers = document.querySelectorAll('div[data-infocard-name="Desktop Schedules"], .hideOnAPIFail'); 
					
					allDataContainers.forEach(curDataContainer => {
						curDataContainer.setAttribute("hidden", "");
					});
					
					var errorContainer = document.querySelector('div[data-infocard-name="Error Messaging"]');
					
					errorContainer.classList.remove("hidden");
					errorContainer.removeAttribute("hidden");
				});
				
				//apply PREDICTIVE PREFETCHING on date inputs
				var allScheduleDateInputs = getDateInputs && getDateInputs();
				
				allScheduleDateInputs && allScheduleDateInputs.forEach(curScheduleDateInput => {
					curScheduleDateInput.addEventListener("keydown", e => {
						e.target.setAttribute("data-disable-predictive-prefetching-until-blur", "");  //??? remove e.target
					});
					
					curScheduleDateInput.addEventListener("blur", e => {
						e.target.hasAttribute("data-disable-predictive-prefetching-until-blur") === true && e.target.removeAttribute("data-disable-predictive-prefetching-until-blur");
						
						var isValid = e.target.checkValidity();
						
						isValid === true && onChangeDate && onChangeDate(getScheduleSearchContext);
					});
					
					curScheduleDateInput.addEventListener("change", e => {
						if (e.target.hasAttribute("data-disable-predictive-prefetching-until-blur") === false) { //??? remove magic string
							//NOTE: input must be valid to minimize API predictive prefetching calls
							//??? this is a hack? might prevent future stuff from working?
							var isValid = e.target.checkValidity();
							
							isValid === true && onChangeDate && onChangeDate(getScheduleSearchContext);
						}
					});
				});
				
				//apply PREDICTIVE PREFETCHING on direction inputs
				var allScheduleDirectionInputs = getDirectionInputs && getDirectionInputs();
				
				allScheduleDirectionInputs && allScheduleDirectionInputs.forEach(curScheduleDirectionInput => {
					curScheduleDirectionInput.addEventListener("change", e => {
						onChangeDirection && onChangeDirection(e, curScheduleDirectionInput, getScheduleSearchContext);
					});
					
					updateDirectionLabels && window.findDynamicComponent && window.findDynamicComponent({
						parentContainerNode: curScheduleDirectionInput
						, targetSelector: "option"
						, callbackFunction: () => {
							updateDirectionLabels && updateDirectionLabels(curScheduleDirectionInput);
						}
					});
				});
				
				var startTimeInput = getStartTimeInput && getStartTimeInput();
				var endTimeInput = getEndTimeInput && getEndTimeInput();
				
				//restore user-inputted values from this session (if they exist)
				restoreUserInputtedValues !== false && window.addEventListener("DOMContentLoaded", () => {  //??? this needs to be replaced with the helper function that detects if DOMContentLoaded has already run or not
					var allScheduleInputs = [startTimeInput, endTimeInput, ...allScheduleDateInputs, ...allScheduleDirectionInputs];
					
					allScheduleInputs.forEach(curScheduleInput => {
						var curScheduleInputName = curScheduleInput && curScheduleInput.getAttribute("name");
						
						var targetKey = `SchedulesTimeFilter-${curScheduleInputName}`; //??? illegal hardcoded key suffix
						var curValue = curScheduleInput.value;
						
						//initialized stored values on pageload
						var prevValue = window.TemporaryStorage.getItem(targetKey);
						
						if (prevValue !== undefined && prevValue !== null && curValue !== prevValue) {
							//??? validate direction + startDate fields
							curScheduleInput.value = prevValue;
						}
						
						//setup handlers to update these stored values
						curScheduleInput.addEventListener("change", e => {
							var newValue = e.target && e.target.value;
							
							//GUARD: do nothing if there is no target value or name
							if (!curScheduleInputName || !newValue) {
								return;
							}
							
							window.TemporaryStorage.setItem(targetKey, newValue);
						});
					});
				});
				
				//init 'stale data' warnings
				var allFormElements = Array.from(SchedulesTimeFilterForm.elements);  //??? is this really the best place for this?
				
				var staleDataPromptElement = SchedulesTimeFilterForm.elements["staleDataPrompt"];
				
				staleDataPromptElement && allFormElements.forEach(curFormInputElement => {
					var inputChangedEventName = "ApplePaySession" in window && curFormInputElement.tagName === "SELECT" ? "blur" : "change";
					
					switch (curFormInputElement.tagName) {
						case "SELECT":
						case "INPUT":
							; (() => {
								curFormInputElement.addEventListener(inputChangedEventName, () => {
									var atLeastOneValueHasChanged = allFormElements.some(curFormElement => {
										var output = false;
										
										switch (curFormElement.tagName) {
											case "SELECT":
											case "INPUT":
												; (() => {
													var prevValue = curFormElement.hasAttribute("value") && curFormElement.getAttribute("value") || curFormElement.hasAttribute("data-select-value") && curFormElement.getAttribute("data-select-value");  //??? this is part of a super hacky hardcoding...maybe we replace this entire 'detect if input is different that previous submit' with a way to compare formdata from previous submits
													var curValue = curFormElement.value;
													
													output = curValue !== undefined && curValue !== "undefined" && curValue !== prevValue;
												})();
											default:
												; (() => {
													
												})();
												
												break;
										}
										
										return output;
									});
									
									if (atLeastOneValueHasChanged === true) {
										staleDataPromptElement && staleDataPromptElement.removeAttribute("hidden");
									} else {
										staleDataPromptElement && staleDataPromptElement.setAttribute("hidden", "");
									}
								});
							})();
							
							break;
						default:
							; (() => {
								
							})();
							
							break;
					} 
				});
				
				//run search on submit
				var prevDirectionValue;
				var prevStartDate;
				
				startTimeInput && endTimeInput && SchedulesTimeFilterForm.addEventListener("submit", async e => {
					e.preventDefault();
					
					var submitterButton = bestAttemptGetFormEventSubmitterButton && bestAttemptGetFormEventSubmitterButton(e);
					var submitterOutputTargetID = submitterButton && submitterButton.hasAttribute("aria-controls") && submitterButton.getAttribute("aria-controls");
					
					//GUARD: do nothing if there is no found output target
					if (!submitterOutputTargetID) {
						return;
					}
					
					//update all label text on page to show the direction name
					updateDirectionLabels && updateDirectionLabels(allScheduleDirectionInputs[0]);
					
					//disable submit buttons to prevent spamming the API
					disableToolbarButtons && disableToolbarButtons();
					
					//delete all existing results data every time a new search is run
					var allOutputElements = getOutputElements && getOutputElements();
					
					allOutputElements && allOutputElements.forEach(curOutputElement => {
						window.deleteAllChildNodes && window.deleteAllChildNodes(curOutputElement);
					});
					
					var allNextDayInformationalMessageContainers = getNextDayInformationalMessageContainers && getNextDayInformationalMessageContainers(SchedulesTimeFilterForm);
					
					allNextDayInformationalMessageContainers && allNextDayInformationalMessageContainers.forEach(curNextDayInformationalMessageContainer => {
						window.deleteAllChildNodes && window.deleteAllChildNodes(curNextDayInformationalMessageContainer);
					});
					
					//remove 'stale data' warnings  //??? should be a list of staledataprompt elements?
					staleDataPromptElement && staleDataPromptElement.setAttribute("hidden", "");
					
					//??? clear the map stuff out, but how do i integrate this properly??? what kinda userland function do I need???  onClearResults???
					clearAllStops && clearAllStops();  //??? should I move that other output-clearing code into here???
					
					//get target datetime range
					var startTimeValue = startTimeInput && startTimeInput.value;
					var endTimeValue = endTimeInput && endTimeInput.value;
					
					//??? do we need a guard clause incase the start or end times are missing?
					
					var numberFormattedStartTimeValue = parseInt(startTimeValue.replace(":", ""), 10);
					var numberFormattedEndTimeValue = parseInt(endTimeValue.replace(":", ""), 10);
					
					//NOTE: if needed, show informational message describing how the endTime is one day after the startDate
					if (numberFormattedStartTimeValue > numberFormattedEndTimeValue) {
						showNextDayInformationalMessage && showNextDayInformationalMessage(getScheduleSearchContext);
					}
					
					//construct arguments to get data for target time range  //??? is there really no way this can be simplified  //??? instead of preparing all data for all 3 possible fetches waterfall style, should create helper function to build one fetch for one day at a time  //??? converting date-input into date-object is a lot of work.  consider putting it into a helper function
					var targetStartDateInput = allScheduleDateInputs && allScheduleDateInputs[0];
					
					var startDate = targetStartDateInput && getDateObjectFromDateInput(targetStartDateInput);
					
					var startDateValue = startDate && window.getDashDelimitedDateString(startDate);
					
					var prevDayDate = startDate && (new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() - 1));
					
					var prevDayValue = prevDayDate && window.getDashDelimitedDateString(prevDayDate);
					
					//NOTE: only construct the next day arguments if the target time range extends into the next day
					var nextDayValue;
					
					if (numberFormattedStartTimeValue > numberFormattedEndTimeValue) {
						var nextDayDate = startDate && (new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + 1));
						
						nextDayValue = nextDayDate && window.getDashDelimitedDateString(nextDayDate);
					}
					
					//only create fetches for data that is not already cached
					var isPrevDayCached;
					var isCurDayCached;
					var isNextDayCached;
					
					var directionValue = getCurrentDirectionValue && getCurrentDirectionValue(getScheduleSearchContext);
					
					if (gtfsData && gtfsData[directionValue] && gtfsData[directionValue][routeLineNumber]) {
						isPrevDayCached = gtfsData[directionValue][routeLineNumber][prevDayValue] !== undefined;
						isCurDayCached = gtfsData[directionValue][routeLineNumber][startDateValue] !== undefined;
						
						if (nextDayValue) {
							isNextDayCached = gtfsData[directionValue][routeLineNumber][nextDayValue] !== undefined;
						}
					}
					
					var allScheduleFetches = [];
					
					//??? update to follow URL Object format...
					//??? add error handling for fetch() gone wrong
					!isPrevDayCached && prevDayValue && allScheduleFetches.push(fetch(`${apiURL}/${routeLineNumber}/direction/${directionValue}/schedules/${prevDayValue}`));
					!isCurDayCached && startDateValue && allScheduleFetches.push(fetch(`${apiURL}/${routeLineNumber}/direction/${directionValue}/schedules/${startDateValue}`));
					!isNextDayCached && nextDayValue && allScheduleFetches.push(fetch(`${apiURL}/${routeLineNumber}/direction/${directionValue}/schedules/${nextDayValue}`));
					
					try {
						//fetch data for target time range
						var responses = allScheduleFetches && await Promise.all(allScheduleFetches);
						
						/* CONVERT API DATA INTO DATA MODEL */
						gtfsData[directionValue] = gtfsData[directionValue] || {};
						gtfsData[directionValue][routeLineNumber] = gtfsData[directionValue][routeLineNumber] || {};
						
						var readJSONPromises = responses.map(response => {
							return response && response.ok === true && response.json && response.json();
						});  //??? filter out 'rejected'/false values?
						
						var results = readJSONPromises && await Promise.all(readJSONPromises);
						
						if (!results) {
							results = [];
						}
						
						createPersistentDatamodel && createPersistentDatamodel(() => {
							var context = {};
							
							context.results = results;
							context.gtfsData = gtfsData;
							context.routeLineNumber = routeLineNumber;
							context.directionValue = directionValue;
							
							return context;
						});
						
						/* RESET STOPS SELECTION */
						var stopsFilterResetButton = document.querySelector('[type="reset"][form="FilterBusStops"]');
						
						stopsFilterResetButton && stopsFilterResetButton.click();
						
						/* UPDATE INFOMAP PDF LINKS */
						if (startDate) {
							const DATETIME_STRING_HELPERS_MODULE_URL_STRING = "https://tlweblibs.translink.ca/DateTimeStringHelpers-1.1.0.mjs";
							
							var datetimeStringHelpersModuleURL = DATETIME_STRING_HELPERS_MODULE_URL_STRING && new URL(DATETIME_STRING_HELPERS_MODULE_URL_STRING);
							
							var { buildDashDelimitedDateStringFromDateString } = datetimeStringHelpersModuleURL && await import(datetimeStringHelpersModuleURL);
							
							var startDateDashDelimitedDateString = startDate && buildDashDelimitedDateStringFromDateString(startDate.toString());
							
							var allInfomapsPDFLinkElements = document.querySelectorAll("infomaps-timetable-link, infomaps-routeline-map-link");
							
							startDateDashDelimitedDateString && allInfomapsPDFLinkElements.forEach(curInfomapsPDFLinkElement => {
								curInfomapsPDFLinkElement.setAttribute("data-target-date", startDateDashDelimitedDateString);
							});
						}
						
						/* RENDER SCHEDULES STOP TIMES */
						var allFormattedStopMetadata = [];
						var allFormattedStopTimes = [];
						
						var prevDayStops = gtfsData[directionValue][routeLineNumber][prevDayValue];
						var curDayStops = gtfsData[directionValue][routeLineNumber][startDateValue];
						var nextDayStops = gtfsData[directionValue][routeLineNumber][nextDayValue];
						
						/*
							NOTES:
							
							this datamodel sets the "0000" (24-hour-time) as the beginning of the PREVIOUS DAY.  The beginning of the CURRENT DAY is actually "2400" and NEXT DAY/tomorrow is "4800".  Therefore, if we want our stoptimes to be in proper chronological order, we need to add a "+2400" offset to all the stoptimes from CURRENT DAY and "+4800" (aka "2400" multiplied by 2) to NEXT DAY stoptimes.
							
						*/
						
						prevDayStops && createRenderableDatamodel(prevDayStops, allFormattedStopMetadata, allFormattedStopTimes, 0, isShowingLocationsWithoutStoptimes);
						curDayStops && createRenderableDatamodel(curDayStops, allFormattedStopMetadata, allFormattedStopTimes, 2400, isShowingLocationsWithoutStoptimes);
						nextDayStops && createRenderableDatamodel(nextDayStops, allFormattedStopMetadata, allFormattedStopTimes, 2400 * 2, isShowingLocationsWithoutStoptimes);
						
						var allFilteredStopTimes = filterAllStopTimes && filterAllStopTimes(() => {
							var context = {};
							
							context.submitterOutputTargetID = submitterOutputTargetID;
							
							context.allFormattedStopMetadata = allFormattedStopMetadata;
							context.allFormattedStopTimes = allFormattedStopTimes;
							
							context.numberFormattedStartTimeValue = numberFormattedStartTimeValue;
							context.numberFormattedEndTimeValue = numberFormattedEndTimeValue;
							
							context.renderNextStop = renderNextStop;
							context.onAfterRenderAllStops = onAfterRenderAllStops;
							
							return context;
						}); //??? need to set a default value if no filterAllStopTimes() exists....
						
						//??? HACK: this whole if block is running after filterAllStopTimes() which is currently mutating the headway sheet, but is technically not supposed to...we need to redevelop the API to officially allow a short circuit
						//??? we should wonder if this block of code is needed for maps?
						var schedulesTables = submitterOutputTargetID && document.getElementById(submitterOutputTargetID); 
						var schedulesTablesBody = schedulesTables && schedulesTables.querySelector("tbody");
						
						var canShowNextDayIfNeeded = (() => {
							var output = true;
							
							if (numberFormattedStartTimeValue > numberFormattedEndTimeValue && isNextDayCached === false) {
								output = false;  //return false because the user is requesting to see data from tomorrow and we do not have it cached.  Since it is not cached, we need to return false to disable the short-circuit so tomorrow's data can be downloaded and rendered.
							}
							
							return output;
						})();
						
						if (schedulesTablesBody && schedulesTablesBody.children.length > 0 && prevDirectionValue === directionValue && prevStartDate.getTime() === startDate.getTime() && canShowNextDayIfNeeded === true) {
							schedulesTables && schedulesTables.scroll && schedulesTables.scroll(0, 0);  //NOTE: always reset scroll position after data-refresh for best UX  //scrolling when the table is empty because there are no elements to repaint in this case
							
							onAfterRenderAllStops && onAfterRenderAllStops(schedulesTablesBody);
							
							return;
						} else {
							prevDirectionValue = directionValue;
							prevStartDate = startDate;
						}
						
						buildAllStops && buildAllStops(() => {
							var context = {};
							
							context.getRelatedGTFSPlaceURL = getRelatedGTFSPlaceURL;
							
							context.submitterOutputTargetID = submitterOutputTargetID;
							context.getOutputElements = getOutputElements;
							
							context.allFormattedStopMetadata = allFormattedStopMetadata;
							context.allFormattedStopTimes = allFilteredStopTimes;
							
							context.numberFormattedStartTimeValue = numberFormattedStartTimeValue;
							context.numberFormattedEndTimeValue = numberFormattedEndTimeValue;
							
							context.renderNextStop = renderNextStop;
							context.onAfterRenderAllStops = onAfterRenderAllStops;
							
							return context;
						});
						
						//??? should this be run in the catch?  I think not because the catch represents a table that did not render, so the currently displayed table still matches the input's prev values
						allFormElements && allFormElements.forEach(curFormInputElement => {
							switch (curFormInputElement.tagName) {
								case "SELECT":
									; (() => {
										curFormInputElement.setAttribute("data-select-value", curFormInputElement.value);
									})();
									
									break;
								case "INPUT":
									; (() => {
										curFormInputElement.setAttribute("value", curFormInputElement.value);
									})();
									
									break;
								default:
									; (() => {
										
									})();
									
									break;
							} 
						});
					} catch (error) {
						//???show error???
						console.error(error);
						
						enableToolbarButtons && enableToolbarButtons();
						//??? code review: is this the only place we should consider reenabling the search buttons?
					}
					
					return;
				});
				
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="GTFSPlaces">
	; (() => {
		const NAMESPACE = "GTFSPlaces";
		
		var ns = window[NAMESPACE] = window.defineNameSpace && window.defineNameSpace(NAMESPACE) || (window[NAMESPACE] || {});
		
		/* CREATE EXTERNAL HELPERS */
		/* end of CREATE EXTERNAL HELPERS */
		
		var args = [ns, NAMESPACE];
		
		; ((ns, NAMESPACE) => {
			var self = ns;
			
			/* DECLARE DATA MEMBERS */
			var apiURLString;
			var buildForm;
			var getSearchDateElement;
			var routesContainerSelector;
			var getRouteName;
			var getPlaceName;
			var buildRouteSchedule;
			var sortRouteSchedules;
			var isShowingLocationsWithoutStoptimes;
			var onAfterBuildRouteSchedule;
			var onAfterBuildAllRouteSchedules;
			/* end of DECLARE DATA MEMBERS */
			
			self.isInited = false;
			
			self.init = options => {
				//GUARD: do not allow a library to be initialized twice
				if (self.isInited) {
					return false;
				}
				
				//GUARD: do not allow a library to be initialized if the client hasn't passed a configuration
				if (!options) {
					return false;
				}
				
				/* PARSE CONFIGURATION */
				apiURLString = options.apiURL;
				buildForm = options.buildForm;
				getSearchDateElement = options.getSearchDateElement;
				routesContainerSelector = options.routesContainerSelector;
				getRouteName = options.getRouteName;
				getPlaceName = options.getPlaceName;
				buildRouteSchedule = options.buildRouteSchedule;
				sortRouteSchedules = options.sortRouteSchedules;
				isShowingLocationsWithoutStoptimes = options.isShowingLocationsWithoutStoptimes;
				onAfterBuildRouteSchedule = options.onAfterBuildRouteSchedule;
				onAfterBuildAllRouteSchedules = options.onAfterBuildAllRouteSchedules;
				/* end of PARSE CONFIGURATION */
				
				/* RUN INIT */
				var outputContainer = document.querySelector(routesContainerSelector);
				
				//GUARD: do nothing if there is no output container
				if (!outputContainer || outputContainer.length && outputContainer.length === 0) {
					return;
				}
				
				var gtfsLocationsSearchForm = buildForm && buildForm(apiURLString);
				
				//GUARD: do nothing if the form element wasn't made
				if (!gtfsLocationsSearchForm) {
					return;
				}
				
				document.documentElement.append(gtfsLocationsSearchForm);
				
				//??? this should be a tlhelper
				var submitButton = Array.from(gtfsLocationsSearchForm.elements).find(curElement => {
					return curElement.matches('[type="submit"]');
				});
				
				var targetSearchDateElement = getSearchDateElement && getSearchDateElement(gtfsLocationsSearchForm);
				
				gtfsLocationsSearchForm.addEventListener("submit", async e => {
					e.preventDefault();
					
					var targetSearchDate = targetSearchDateElement && window.getDateObjectFromDateInput(targetSearchDateElement);
					
					//??? replace isValidDate with MJS types helper
					//GUARD: do nothing if there is no valid target date
					if (window.isValidDate(targetSearchDate) === false) {
						return;
					}
					
					var tomorrowSearchDate = targetSearchDate && new Date(targetSearchDate);
					tomorrowSearchDate && tomorrowSearchDate.setDate(tomorrowSearchDate.getDate() + 1);
					
					//??? replace 'window.getDashDelimitedDateString' with MJS version
					var targetSearchDateAPIURLString = `${apiURLString}/${window.getDashDelimitedDateString(targetSearchDate)}`;
					var targetSearchDateAPIURL = targetSearchDateAPIURLString && new URL(targetSearchDateAPIURLString);
					
					//??? replace 'window.getDashDelimitedDateString' with MJS version
					var tomorrowSearchDateAPIURLString = `${apiURLString}/${window.getDashDelimitedDateString(tomorrowSearchDate)}`;
					var tomorrowSearchDateAPIURL = tomorrowSearchDateAPIURLString && new URL(tomorrowSearchDateAPIURLString);
					
					//GUARD: do nothing if either target or tomorrow API URLs are not valid
					if (!targetSearchDateAPIURL || !tomorrowSearchDateAPIURL) {
						return;
					}
					
					try {
						var allAPIQueries = [
							fetch(targetSearchDateAPIURL, { priority: "high" })
							, fetch(tomorrowSearchDateAPIURL, { priority: "high" })
						];
						
						var allAPIResponses = allAPIQueries && await Promise.all(allAPIQueries);
						//???merge API response bodies between the 2 dates?
						
						var allRouteElements = new Map();
						
						var firstMode;  //??? this variable needs to be renamed; it is fully inaccurate
						
						try {
							for (var curAPIResponse of allAPIResponses) {
								var result = curAPIResponse && curAPIResponse.ok === true && curAPIResponse.json && await curAPIResponse.json();
								
								//GUARD: do nothing if no API results were received
								if (!result) {
									break;
								}
								
								//??? BAD HACKY CODE to set firstmode to the 2nd API response...need to figure out how to do this properly
								if (!firstMode) {
									firstMode = result[0];
								}
								
								window.deleteAllChildNodes && window.deleteAllChildNodes(outputContainer);
								
								result && result.forEach && result.forEach(curMode => {
									var allGTFSRouteLines = curMode.r;
									
									//??? where is the reduce() comment?
									var allDeduplicatedGTFSRouteLines = allGTFSRouteLines && allGTFSRouteLines.reduce((output, curGTFSRouteLine) => {
										var curGTFSRouteLineFullName = `${curGTFSRouteLine.rs}_${curGTFSRouteLine.hs}`;
										
										var matchingRouteLine = output.get(curGTFSRouteLineFullName);
										
										if (matchingRouteLine) {
											var matchingRouteLineDirections = window.getType(matchingRouteLine.di) === window.getType.array ? matchingRouteLine.di : [matchingRouteLine.di];
											
											matchingRouteLineDirections = curGTFSRouteLine.di && matchingRouteLineDirections.concat(curGTFSRouteLine.di) || matchingRouteLineDirections;
											
											matchingRouteLine.di = matchingRouteLineDirections;
											
											var matchingRouteLineSchedule = matchingRouteLine.t || [];
											
											matchingRouteLine.t = matchingRouteLineSchedule.concat(curGTFSRouteLine.t).sort((lhs, rhs) => {
												var lhsTimestamp = lhs.ut;
												var rhsTimestamp = rhs.ut;
												
												if (!lhsTimestamp && !rhsTimestamp) {
													return 0;
												} else if (!lhsTimestamp) {
													return -1;
												} else if (!rhsTimestamp) {
													return 1;
												}
												
												if (lhsTimestamp === rhsTimestamp) {
													return 0;
												} else if (lhsTimestamp < rhsTimestamp) {
													return -1;
												} else if (lhsTimestamp > rhsTimestamp) {
													return 1;
												}
												
												return 0; //NOTE: this should never run, but returning a 'default value' for safety
											});
											
											output.set(curGTFSRouteLineFullName, matchingRouteLine);
										} else {
											output.set(curGTFSRouteLineFullName, curGTFSRouteLine);
										}
										
										return output;
									}, new Map());
									
									allDeduplicatedGTFSRouteLines && allDeduplicatedGTFSRouteLines.forEach(curGTFSRouteLine => {
										//??? convert to MJS version of 'getType'
										if (window.getType(curGTFSRouteLine.di) !== window.getType.array) {
											curGTFSRouteLine.di = [curGTFSRouteLine.di];
										}
										
										var gtfsRouteLineName = getRouteName && getRouteName(() => {
											var output = {};
											
											output = curGTFSRouteLine;
											output.id = curMode.id;
											output.sn = window.formatGTFSItemName(curMode.sn);
											output.la = curMode.la;
											output.lo = curMode.lo;
											
											return output;
										});
										
										var gtfsLocationName = getPlaceName && getPlaceName(() => {
											var output = {};
											
											output = curGTFSRouteLine;
											output.id = curMode.id;
											output.sn = window.formatGTFSItemName(curMode.sn);
											output.la = curMode.la;
											output.lo = curMode.lo;
											
											return output;
										});
										
										var allDestinations = new Map();
										
										curGTFSRouteLine.t.forEach(curStopTime => {
											var directionName = window.formatGTFSItemName(curStopTime.th);
											
											allDestinations.has(directionName) === false && allDestinations.set(directionName, []);
											
											allDestinations.get(directionName).push(curStopTime);
										});
										
										var numDestinations = allDestinations.size;
										
										//GUARD: do nothing if there are no valid destinations found and we are not showing trips without stoptimes
										if (numDestinations === 0 && isShowingLocationsWithoutStoptimes === false) {
											return;
										}
										
										var isGTFSRouteLineScheduleForToday = (() => {
											var output = false;
											
											var todayDate = new Date();
											
											var curScheduleDateDateTimeString = result[0].sd;
											var curScheduleDate = curScheduleDateDateTimeString && new Date(curScheduleDateDateTimeString);
											
											//GUARD: do nothing if the current schedule date is not a valid date
											if (!curScheduleDate || window.isValidDate(curScheduleDate) === false) {
												return;
											}
											
											output = todayDate.getDate() === curScheduleDate.getDate();
											
											return output;
										})();
										
										if (numDestinations > 0) {
											Array.from(allDestinations.keys()).forEach(curDestinationName => {
												//??? this current set of datetimes only includes 
												var curDestinationTimes = allDestinations.get(curDestinationName);
												
												//??? need to rename this, but to what?
												var gtfsRouteLineScheduleElement = buildRouteSchedule && buildRouteSchedule(gtfsRouteLineName, curGTFSRouteLine.rs, curGTFSRouteLine.rl, curGTFSRouteLine.di, gtfsLocationName, curMode.sc, curDestinationName, curDestinationTimes, isGTFSRouteLineScheduleForToday);
												
												//GUARD: do nothing if no route was created
												if (!gtfsRouteLineScheduleElement) {
													return;
												}
												
												allRouteElements.has(curDestinationName) === false && allRouteElements.set(curDestinationName, {
													routeData: curGTFSRouteLine
													, rendering: gtfsRouteLineScheduleElement
												});
												
												onAfterBuildRouteSchedule && onAfterBuildRouteSchedule(() => {
													var output = {};
													
													output = curGTFSRouteLine;
													output.id = curMode.id;
													output.sn = window.formatGTFSItemName(curMode.sn);
													output.la = curMode.la;
													output.lo = curMode.lo;
													
													return output;
												});
											});
										} else {
											var targetDestinationName = window.formatGTFSItemName(`${curMode.rs} ${curMode.sc}`);
											
											var gtfsRouteLineScheduleElement = buildRouteSchedule && buildRouteSchedule(gtfsRouteLineName, curGTFSRouteLine.rs, curGTFSRouteLine.rl, curGTFSRouteLine.di, gtfsLocationName, targetDestinationName, gtfsRouteLineName, [], isGTFSRouteLineScheduleForToday);
											
											//GUARD: do nothing if no route was created
											if (!gtfsRouteLineScheduleElement) {
												return;
											}
											
											allRouteElements.has(targetDestinationName) === false && allRouteElements.set(targetDestinationName, {
												routeData: curGTFSRouteLine
												, rendering: gtfsRouteLineScheduleElement
											});
											
											onAfterBuildRouteSchedule && onAfterBuildRouteSchedule(() => {
												var output = {};
												
												output = curGTFSRouteLine;
												output.id = curMode.id;
												output.sn = window.formatGTFSItemName(curMode.sn);
												output.la = curMode.la;
												output.lo = curMode.lo;
												
												return output;
											});
										}
									});
								});
							}
						} catch (error) {
							console.error(error);
							
							var noScheduledTripsTextElement = document.createElement("p");
							noScheduledTripsTextElement.textContent = "There are no schedules available.";  //??? find a way to unhardcode?
							
							window.deleteAllChildNodes && window.deleteAllChildNodes(outputContainer);
							outputContainer.append(noScheduledTripsTextElement);
						} finally {
							var allRenderableRouteElements = Array.from(allRouteElements.values());  //??? needs a better name
							
							if (allRenderableRouteElements && allRenderableRouteElements.length > 0) {
								sortRouteSchedules && allRenderableRouteElements.sort(sortRouteSchedules);
								
								allRenderableRouteElements.forEach(targetRoute => {
									outputContainer && outputContainer.append(targetRoute.rendering);
								});
							} else {
								var noScheduledTripsTextElement = document.createElement("p");
								noScheduledTripsTextElement.textContent = "There are no schedules available.";
								
								window.deleteAllChildNodes && window.deleteAllChildNodes(outputContainer);
								outputContainer.append(noScheduledTripsTextElement);
							}
							
							onAfterBuildAllRouteSchedules && onAfterBuildAllRouteSchedules(() => {
								//??? this function seems awkward...
								var output = {};
								
								var firstRoute = firstMode && firstMode.r;
								
								if (firstRoute) {
									output = firstRoute;
								}
								
								if (firstMode) {
									//??? where is the reduce() comment?
									output.id = firstMode.id;  //??? I think this doesn't serve an actual purpose and was mistakenly added because I thought it was the same as sc; added .sc now
									output.sc = window.GTFS.stationId || firstMode.sc;  //??? temporary reference to global?  either convert to userland variable or remove if the API stops returning platform numbers and replaces them with station numbers
									output.sn = window.formatGTFSItemName(firstMode.sn);
									output.la = firstMode.la;
									output.lo = firstMode.lo;
									output.hasRenderedSchedules = allRenderableRouteElements && allRenderableRouteElements.length > 0;
									output.allRenderedGTFSRouteLineNumbers = allRenderableRouteElements && allRenderableRouteElements
									.map(curRenderableRouteElement => {
										var curRenderableRouteElementRouteData = curRenderableRouteElement && curRenderableRouteElement.routeData;
										var curRenderableRouteElementGTFSRouteNumber = curRenderableRouteElementRouteData && curRenderableRouteElementRouteData.rs;
										
										return curRenderableRouteElementGTFSRouteNumber;
									})
									.filter(x => x) //NOTE: "filter(x => x)" to remove empty strings and other falsey values
									|| [];
									output.allRenderedGTFSDirectionNumbers = allRenderableRouteElements && allRenderableRouteElements
									.reduce((allDirectionNumbers, curRenderableRouteElement) => {
										var curRenderableRouteElementRouteData = curRenderableRouteElement && curRenderableRouteElement.routeData;
										var curRenderableRouteElementGTFSDirectionNumbers = curRenderableRouteElementRouteData && curRenderableRouteElementRouteData.di;
										
										curRenderableRouteElementGTFSDirectionNumbers.forEach(curDirectionNumber => {
											allDirectionNumbers.add(curDirectionNumber);
										});
										
										return allDirectionNumbers;
									}, new Set());
								}
								
								return output;
							});
						}
					} catch (error) {
						console.error(error);
						
						var noScheduledTripsTextElement = document.createElement("p");
						noScheduledTripsTextElement.textContent = "There are no schedules available.";  //??? find a way to unhardcode?
						
						window.deleteAllChildNodes && window.deleteAllChildNodes(outputContainer);
						outputContainer.append(noScheduledTripsTextElement);
					}
					
					return false;
				});
				
				targetSearchDateElement.addEventListener("change", () => {
					submitButton && submitButton.click();
				});
				
				submitButton && submitButton.click();
				/* end of RUN INIT */
				
				self.isInited = true;
			};
		}).apply(null, args);
	})();
</script><script class="inlined-driver">
	window.addEventListener("DOMContentLoaded", () => {
		window.startTimer && window.startTimer("init-js-inlined-driver-parsing-timer");
		
		window.Multiselector && window.Multiselector.init({
			targetSelector: "select[multiple]"
			, onlyShowWhenMouseIsAvailableClass: "mouseOnlyContent"
			, onlyShowWhenMouseIsNotAvailableClass: "noMouseOnlyContent"
			, targetedOptionClass: "target"
			, renderPicker: targetMultipicker => {
				var targetMultipickerName = targetMultipicker.getAttribute("name");
				
				var placeholderOption = targetMultipicker.querySelector("option[disabled][selected]");
				var placeholderText = placeholderOption && placeholderOption.textContent || "Choose an option";  //??? remove hardcoding?
				
				var output = document.createElement("button");
				output.setAttribute("type", "button");
				output.setAttribute("aria-haspopup", "listbox");
				output.setAttribute("aria-expanded", false);
				output.setAttribute("aria-controls", `${targetMultipickerName}-listbox`);
				output.setAttribute("aria-label", placeholderText);
				output.textContent = " ";  //NOTE: needed to make the picker appear during init phase because empty elements are hidden by WebLibs
				
				return output;
			}
			, renderListbox: (namePrefix, allOptions, targetedOptionClass, initFromHTMLAttributes) => {
				var output = document.createElement("ul");
				output.setAttribute("role", "listbox");
				output.setAttribute("id", `${namePrefix}-listbox`);
				output.setAttribute("class", "verticalMenu useFormFieldInfinitely");
				output.setAttribute("aria-multiselectable", true);
				output.setAttribute("tabindex", -1);
				
				allOptions && allOptions.forEach(curOption => {
					//GUARD: do nothing if this option doesn't have a value to submit
					if (curOption.hasAttribute("value") !== true) {
						return;
					}
					
					var curOptionSelectedValue = initFromHTMLAttributes ? curOption.hasAttribute("selected") : curOption.selected;
					
					var newOptionID = `${namePrefix}-${curOption.getAttribute("value").toLowerCase()}`;  //??? do .hasAttribute before .getAttribute
					
					var newOption = document.createElement("li");
					newOption.setAttribute("role", "option");
					newOption.setAttribute("id", newOptionID);
					newOption.setAttribute("aria-selected", curOptionSelectedValue);
					
					var newOptionLabel = document.createElement("label");
					
					var newOptionInput = document.createElement("input");
					newOptionInput.setAttribute("type", "checkbox");
					newOptionInput.setAttribute("value", curOption.getAttribute("value"));  //??? do .hasAttribute before .getAttribute
					curOptionSelectedValue === true && newOptionInput.setAttribute("checked", "");
					newOptionInput.setAttribute("tabindex", -1);
					
					var newOptionLabelTextWrapper = document.createElement("span");
					newOptionLabelTextWrapper.setAttribute("data-role", "p");
					
					var newOptionLabelText = document.createTextNode(curOption.textContent);
					
					newOptionLabelTextWrapper.append(newOptionLabelText);
					
					newOptionLabel.append(newOptionInput);
					newOptionLabel.append(newOptionLabelTextWrapper);
					newOption.append(newOptionLabel);
					output.append(newOption);
					
					if (output.hasAttribute("aria-activedescendant") === false) {
						output.setAttribute("aria-activedescendant", newOptionID);
						newOption.classList.add(targetedOptionClass);
					}
				});
				
				return output;
			}
			, openListbox: targetMultiselector => {
				//GUARD: do nothing if there is no target multiselector
				if (!targetMultiselector) {
					return;
				}
				
				var listbox = targetMultiselector.nextElementSibling;
				
				//GUARD: do nothing if the listbox cannot be found
				if (!listbox || listbox.hasAttribute("role") === false || listbox.getAttribute("role").toLowerCase() !== "listbox") {
					return;
				}
				
				listbox.style.left = "unset";
				
				//close listbox when switching to a new tab
				window.addEventListener("visibilitychange", () => {
					var isExpanded = targetMultiselector.getAttribute("aria-expanded");
					
					if (isExpanded === "true") {
						targetMultiselector.click();
					}
				}, { once: true });
				
				//close listbox when resizing the page
				window.addEventListener("resize", () => {
					var isExpanded = targetMultiselector.getAttribute("aria-expanded");
					
					if (isExpanded === "true") {
						targetMultiselector.click();
					}
				}, { once: true });
				
				//close listbox on page scroll
				window.requestAnimationFrame(() => {  //NOTE: this is needed because this expando is closed and its content is force-hidden by CSS until it's opened.  Waiting for the next animation frame will allow the expando to open and container to become visible so we can focus() it.
					listbox && listbox.focus({ preventScroll: true });
					//listbox && listbox.scrollIntoViewIfNeeded && listbox.scrollIntoViewIfNeeded();  //??? I want to do this, but it obviously causes a scroll event in the NEXT frame and triggers the scroll event.  I could use this if this function had a callback.  Maybe make my own version...
					
					window.requestAnimationFrame(() => {  //we are nesting request animation frames because the first animation frame renders the listbox (that causes a scroll event) and we don't want it to trigger the scroll event handler in this second animation frame
						window.addEventListener("scroll", e => {  //??? there can be a bunch of "orphaned" callbacks if many multiselectors are opened, but no scroll events ever run; consider refactoring this callback to also be removed on accordion-close
							var isAccordionOpen = targetMultiselector.getAttribute("aria-expanded");
							
							if (isAccordionOpen === "true") {
								targetMultiselector.click();
							}
						}, { once: true });  //??? make scroll passive?
					});
				});
			}
			, closeListbox: (targetMultiselector, targetListbox) => {
				targetMultiselector && targetMultiselector.focus();
				targetListbox && targetListbox.style.removeProperty("height");  //undo the resizing adjustments
				targetListbox && targetListbox.style.removeProperty("transform");  //undo the positioning adjustments
				targetListbox && targetListbox.style.removeProperty("left");  //undo the 'make visible' adjustments
				targetListbox && targetListbox.style.removeProperty("opacity");  //undo the 'make visible' adjustments
			}
			, selectOption: (targetPickerElement, targetListbox, targetOption, originalMultiselector) => {
				//GUARD: do nothing if there is no target option
				if (!targetOption) {
					return;
				}
				
				var targetOptionInput = targetOption.querySelector("input");
				
				//GUARD: do nothing if there is no input element for the target option or doesn't have a value attribute
				if (!targetOptionInput || targetOptionInput.hasAttribute("value") === false) {
					return;
				}
				
				var targetOptionInputValue = targetOptionInput.getAttribute("value");
				
				var originalOption = originalMultiselector && originalMultiselector.querySelector && originalMultiselector.querySelector(`option[value="${targetOptionInputValue}"]`);
				
				//GUARD: do nothing if there is no target option
				if (!originalOption) {
					return;
				}
				
				var isTargetOptionSelected = (() => {
					var output = false;
					
					if (targetOption.hasAttribute("aria-selected") && targetOption.getAttribute("aria-selected").toLowerCase() === "true") {
						output = true;
					}
					
					return output;
				})();
				
				targetOption.setAttribute("aria-selected", !isTargetOptionSelected);
				originalOption.selected = !isTargetOptionSelected;
				targetOptionInput.checked = !isTargetOptionSelected;
				
				//??? HACK: I think this is throwing an event so all other components of the multipicker are aware of changes
				var multipickerCloseEvent = "ApplePaySession" in window ? "blur" : "change"; // NOTE: when the user closes the native multi-select, iOS fires "blur" events and Android Chrome first "change" events
				
				originalMultiselector.dispatchEvent && originalMultiselector.dispatchEvent(
					new Event(multipickerCloseEvent, {
						view: window  //NOTE: not sure what this actually does, but all the code samples on MDN include it
						, bubbles: true
						, cancelable: true
					})
				);
			}
		});
		
		window.virtualCursor && window.virtualCursor.init({
			focusableElementsSelector: "a, button, select, option, input, summary, [tabindex]"
			, focusableContainerClass: "focusableContainer"
			, noFocusClass: "noFocus"
			, showFocusClass: "showFocusCursor"
		});
		
		window.AutoIDGenerator && AutoIDGenerator.init({
			simpleSelectors: [
				"h1"
				, "h2"
				, "h3"
				, "h4"
				, "h5"
				, "h6"
				, "summary"
			].join(", ")
			, simpleFilters: [
				"summary h1"
				, "summary h2"
				, "summary h3"
				, "summary h4"
				, "summary h5"
				, "summary h6"
				, "article > header > h1"
				, "article > header > h2"
				, "article > header > h3"
				, "article > header > h4"
				, "article > header > h5"
				, "article > header > h6"
				, "code h1"
				, "code h2"
				, "code h3"
				, "code h4"
				, "code h5"
				, "code h6"
				, "code summary"
			].join(", ")
			, complexSelectors: [
				AutoIDGenerator.generateIDsForTabs
				, AutoIDGenerator.generateIDsForAccordions
				, AutoIDGenerator.generateIDsForDialogs
				, AutoIDGenerator.generateIDsForArticleContent
				, AutoIDGenerator.generateIDsForFormContent
				, AutoIDGenerator.generateIDsForFormlessInputs
			]
		});
		
		window.Tabs && window.Tabs.init({
			hitboxSizing: "45% 45% 45% 45%"
		});
		
		window.AccessibleForms && window.AccessibleForms.init({
			targetSelector: [
				'main input[name]:not([type="hidden"])'
				, "main textarea[name]"
				, "main select[name]"
				, 'footer input[name]:not([type="hidden"])'
				, 'dialog input[name]:not([type="hidden"])'
				, "dialog textarea[name]"
				, "dialog select[name]"
			].join(", ")
			, errorMessageContainerSuffix: "error-msg"
		});
		
		window.FormImmediateValidator && window.FormImmediateValidator.init({
			allInputsWithValidatorSelectors: [
				"input[required]:not([data-use-weblibs-validation])"
				, "input[pattern]:not([data-use-weblibs-validation])"
				, "input[min]:not([data-use-weblibs-validation])"
				, "input[max]:not([data-use-weblibs-validation])"
				, "input[minlength]:not([data-use-weblibs-validation])"
				, "input[maxlength]:not([data-use-weblibs-validation])"
				, "textarea[required]:not([data-use-weblibs-validation])"
				, "textarea[pattern]:not([data-use-weblibs-validation])"
				, "textarea[minlength]:not([data-use-weblibs-validation])"
				, "textarea[maxlength]:not([data-use-weblibs-validation])"
				, "select[required]:not([data-use-weblibs-validation])"
			].join(", ")
			, fieldSpecificErrorMessages: {
				Details: {
					required: "Please enter your details in 2000 characters or less"
					, maxlength: "Please enter your details in 2000 characters or less"
				}
				, IncidentDate: {
					required: "Please enter a valid date"
					, max: "Please enter a date on or before today"
					, min: "Please enter a date within 3 months from today"
				}
				, IncidentTime: {
					required: "Please enter a valid time (HH:MM)"
					, max: "Please enter a time before current time"
				}
				, LostPropertyLocation: {
					required: "Please select a location"
				}
				, ResponseRequired: {
					required: "Please select a response"
				}
				, cvn: {
					required: "Please enter your 3-digit security number"
					, minlength: "Please enter your 3-digit security number"
					, maxlength: "Please enter your 3-digit security number"
				}
				, CVN: {
					required: "Please enter your 3-digit security number"
					, minlength: "Please enter your 3-digit security number"
					, maxlength: "Please enter your 3-digit security number"
				}
				, termsAndConditions: {
					required: "You must agree to our Terms and Conditions to enter the Sweepstakes"
				}
				, ageConfirmed: {
					required: "Please confirm that you are over the age of 18 to complete your registration"
				}
				, newFavourite: {
					required: "Please add a name"
				}
				, gtfsFavouriteKey: {
					required: "Please add a name"
				}
				, curFavouriteName: {
					required: "Please add a name"
				}
				, curFavourite: {
					required: "Please add a name"
				}
				, routeNumber: {
					required: "Please enter a valid bus route number (e.g. 99)"
				}
				, startTime: {
					required: "Please enter a valid start time (HH:MM)"
					, max: "Please enter an earlier start time"
				}
				, endTime: {
					required: "Please enter a valid end time (HH:MM)"
					, min: "Please enter an end time after the start time"
				}
			}
			, labelSpecificErrorMessages: {
				"First Name": {
					required: "Please enter your first name"
					, maxlength: "First name must be 50 characters or less"
					, minlength: "First name must be 2 characters or more"
				}
				, "Last Name": {
					required: "Please enter your last name"
					, maxlength: "Last name must be 50 characters or less"
					, minlength: "Last name must be 2 characters or more"
				}
				, "Display Name": {
					required: "Please enter a display name"
					, maxlength: "Display name must be 50 characters or less"
					, minlength: "Display name must be 2 characters or more"
				}
				, "Phone Number": {
					required: "Please enter your phone number"
					, maxlength: "Please enter a valid phone number"
					, minlength: "Please enter a valid phone number"
				}
				, "Phone Number Verification Code": {
					required: "Please enter your 5-digit verification code that was sent to your phone number"
					, maxlength: "You have entered in a number that's more than 5 digits. Please enter your 5-digit verification code that was sent to your phone number."
					, minlength: "You have entered in a number that's less than 5 digits. Please enter your 5-digit verification code that was sent to your phone number."
				}
				, "Stop Number": {
					maxlength: "Stop number must be 5 digits long"
					, minlength: "Stop number must be 5 digits long"
				}
				, "Search by transit mode, route # or name": {
					required: "Please enter a transit mode, route # or name"
				}
				, "Search by transit mode, route #, name, or stop": {
					required: "Please enter a transit mode, route #, name, or stop"
				}
				, "Compass Card Number": {
					required: "Please enter your 20-digit Compass Card Number"
					, maxlength: "Card number should be 20 digits long"
					, minlength: "Card number should be 20 digits long"
				}
				, "To:": {
					min: "Please enter a future date"
				}
				, "Map Title for Screenreaders": {
					required: "Please enter a map title"
					, minlength: "Map title must be 2 characters or more"
				}
			}
			, inputTypeSpecificErrorMessages: {
				email: {
					required: "Please enter a valid email address"
					, maxlength: "Email must be 254 characters or less"
				}
				, date: {
					required: "Please enter a valid date"
				}
				, time: {
					required: "Please enter a valid time (HH:MM)"
				}
				, "datetime-local": {
					required: "Please enter a valid date and time"
					, max: "Date and time must not be later than the current date and time"
				}
			}
			, getLabelTextForInput: target => {
				//GUARD: do nothing if there is no target
				if (!target) {
					return;
				}
				
				var output = "";
				
				var targetID = target.hasAttribute("id") && target.getAttribute("id");
				
				if (targetID) {
					var explicitLabel = document.querySelector(`[for="${targetID}"]`);  //??? should this be made more explicitly for inputs, etc and not '*' like it currently is
					var formattedExplicitLabelText = explicitLabel && explicitLabel.childNodes && explicitLabel.childNodes[0] && explicitLabel.childNodes[0].nodeValue && explicitLabel.childNodes[0].nodeValue.trim && explicitLabel.childNodes[0].nodeValue.trim();
					
					if (formattedExplicitLabelText) {
						output = formattedExplicitLabelText;
						
						return output;
					} 
				}
				
				var targetParent = target.closest("label") || target.closest("fieldset");
				
				var isParentALabel = targetParent && targetParent.tagName === "LABEL";
				var isParentAFieldset = targetParent && targetParent.tagName === "FIELDSET";
				
				if (isParentALabel === true) {
					var formattedParentLabelText = targetParent.childNodes && targetParent.childNodes[0] && targetParent.childNodes[0].nodeValue && targetParent.childNodes[0].nodeValue.trim && targetParent.childNodes[0].nodeValue.trim();
					
					output = formattedParentLabelText;
				} else if (isParentAFieldset === true) {
					var fieldSetLegendElement = targetParent.querySelector("legend");
					
					if (fieldSetLegendElement) {
						output = fieldSetLegendElement.textContent;
					}
				}
				
				if (output && output.trim) {
					output = output.trim();
				}
				
				return output;
			}
			, buildErrorMessage: (errorMessage, errorIcon) => {
				var output = document.createElement("small");
				
				output.classList.add("verticallyCenteredContent");
				output.setAttribute("style", "display: flex; margin-top: 0.25rem; line-height: 1;");
				output.textContent = errorMessage;
				
				errorIcon && output.prepend(errorIcon);
				
				return output;
				
			}
		});
		
		window.TableOfContents && window.TableOfContents.init({
			headersSelector: "h2"
			, excludeHeadersSelector: [
				"[data-exclude-from-table-of-contents]"
				, "dialog h1"
				, "dialog h2"
				, "dialog h3"
				, "dialog h4"
				, "dialog h5"
				, "dialog h6"
			].join(", ")
			, tableOfContentsContainerSelector: ".TableOfContents"
		});
		
		window.NumberMasker && window.NumberMasker.init({
			numberMasks: [
				{
					targetSelector: 'input:not([name="countryCode"]) + [type="tel"], [type="tel"]:first-child'
					, mask: "(000) 000-0000"
					, numberPlaceholder: "0"
				}
				, {
					targetSelector: '[name="countryCode"] + [type="tel"]'
					, mask: "(000) 000-000000"
					, numberPlaceholder: "0"
				}
				/*  //??? doesn't work because it doesn't allow anything except digits - need to enhance numbermasker
				, {
					targetSelector: '[type="text"][inputmode="numeric"][autocomplete="tel-country-code"]'
					, mask: "+000000"
					, numberPlaceholder: ""
				}
				*/
				, {
					targetSelector: '[name="ccsn"]'
					, mask: "0000 0000 0000 0000 0000"
					, numberPlaceholder: "0"
				}
			]
		});
		
		window.InfoWindow && window.InfoWindow.init({
			infoWindowButtonSelector: "[data-infowindow]"
			, getInfoWindow: infoWindowButton => {
				var infoWindowName = infoWindowButton.getAttribute("data-infowindow");
				
				return document.querySelector(`[data-infowindow-name="${infoWindowName}"]`);  //??? put into variable before returning
			}
		});
		
		window.expandoAccordion && window.expandoAccordion.init({
			largeViewportMediaQuery: "(min-width: 48em)"
			, smallViewportMediaQuery: "not all and (min-width: 48em)"
			, expandoAccordionSelector: '[data-type="expandoAccordion"]'
			, disableAccordionCollapsingClass: "forceAccordionOpen"
			, expandoAccordionContainerSelector: "body"
		});
		
		window.scrollHashTargetInView = () => {
			var targetID = document.location.hash;
			
			//GUARD: do nothing if there is no target ID
			if (!targetID) {
				return;
			}
			
			var target = document.getElementById(targetID.replace("#", ""));
			
			//GUARD: do nothing if there is no skiplink target
			if (!target) {
				return;
			}
			
			var isAccordion = target => {  //promote to tlhelpers
				var output = target.tagName === "SUMMARY";
				
				return output;
			};
			
			var isClosedAccordion = target => { //promote to tlhelpers
				if (isAccordion(target) === true) {
					return target.parentNode.getAttribute("open") === undefined || target.parentNode.getAttribute("open") === null;
				}
			};
			
			var isTab = target => {  //promote to tlhelpers
				var output = target.tagName === "BUTTON" && target.hasAttribute("role") && target.getAttribute("role") === "tab";
				
				return output;
			};
			
			var isUnselectedTab = target => { //promote to tlhelpers
				if (isTab(target) === true) {
					return target.hasAttribute("aria-selected") === false || target.getAttribute("aria-selected") === "false";
				}
				
				//??? probably should have a return statement outside of the IF too?
			};
			
			if (isClosedAccordion(target) === true || isUnselectedTab(target) === true) {
				target.click();
			}
			
			//open all closed parent accordions and tabs
			var parentContainer;
			
			if (target.tagName === "SUMMARY") {
				parentContainer = target.closest("details");
			} else {
				parentContainer = target.closest('[role="tabpanel"]');
			}
			
			while (parentContainer) {
				parentContainer = parentContainer.parentElement.closest("details") || parentContainer.parentElement.closest('[role="tabpanel"]');  //NOTE: we are running closest on the parentElement because otherwise parentContainer may match against itself
				
				if (parentContainer) {
					if (parentContainer.tagName === "DETAILS") {
						var targetAccordionHeader = parentContainer.querySelector("summary");
						
						targetAccordionHeader && targetAccordionHeader.click && targetAccordionHeader.click();
					} else {
						var targetTabID = parentContainer.hasAttribute("aria-labelledby") && parentContainer.getAttribute("aria-labelledby") ;
						
						var targetTab = targetTabID && document.getElementById(targetTabID);
						
						targetTab && targetTab.click && targetTab.click();
					}
				}
			}
			
			target.scrollIntoView();
		};
		
		window.addEventListener("hashchange", window.scrollHashTargetInView);
		window.scrollHashTargetInView();
		
		window.NextBusSettings && window.NextBusSettings.init({
			storageNamespace: "nbSettings"
			, settings: [
				"timeDisplay"
				, "viewPreference"
				, "nodeStopsPreference"
			]
		});
		
		window.TripPlannerSearch && window.TripPlannerSearch.init({
			formID: "TripPlannerSearch"
			, originFieldSelector: '[name="prev_point"]'
			, destinationFieldSelector: '[name="next_point"]'
			, swapLocationsButtonSelector: ".changeDirectionButton"
			, buildForm: formID => {
				var output = document.createElement("form");
				
				output.setAttribute("id", formID);
				output.setAttribute("method", "GET");
				
				return output;
			}
			, buildRedirectURL: (origin, destination) => {
				try {
					var redirectURL = new URL("https://www.google.com/maps/dir/?api=1");
					redirectURL.searchParams.set("travelmode", "transit");
					redirectURL.searchParams.set("origin", origin);
					redirectURL.searchParams.set("destination", destination);
					
					return redirectURL;
				} catch (error) {
					console.error(error);
				}
			}
		});
		
		window.NextBusSearch && window.NextBusSearch.init({
			apiURL: "/old-next-bus/results"  //??? replace with URL Object Pattern
			, formID: "NextBusSearch"
			, buildForm: formID => {
				var output = document.createElement("form");
				
				output.setAttribute("id", formID);
				output.setAttribute("method", "GET");
				
				return output;
			}
			, buildRedirectURL: formID => {
				var output = document.createElement("form");
				
				output.setAttribute("id", formID);
				output.setAttribute("method", "GET");
				
				return output;
			}
			, useCurrentLocationButtonSelector: '[name="useCurrentLocation"]'
			, searchBoxSelector: '[name="NextBusSearchTerm"]'
			, getViewPreference: () => {
				var output = window.NextBusSettings && window.NextBusSettings.getSetting("viewPreference") || "text";  //??? replace with MJS version of NextBusSettings
				
				return output;
			} 
			, getTimePreference: () => {
				var output = window.NextBusSettings && window.NextBusSettings.getSetting("timeDisplay");  //??? replace with MJS version of NextBusSettings
				
				return output;
			}
			, onSearchTermChange: (formID, apiURL, searchTerm, viewPreference, timeDisplayPreference) => {
				var targetForm = document.getElementById(formID);
				
				//GUARD: do nothing if there is no form
				if (!targetForm) {
					return;
				}
				
				var redirectURL = [
					"#"
					, viewPreference
					, searchTerm.length < 5 ? "route" : "stop"
					, searchTerm
					, timeDisplayPreference ? `?timeDisplay=${timeDisplayPreference}` : ""
				]
				.join("/")
				.replace(/\/\//g, "");
				
				targetForm.action = `${apiURL}/${redirectURL}`;  //??? update to follow URL Object pattern
			}
			, onUseCurrentLocation: (formID, apiURL, viewPreference, timeDisplayPreference) => {
				if ("geolocation" in navigator) {
					navigator.geolocation.getCurrentPosition(position => {
						var targetForm = document.getElementById(formID);
						
						//GUARD: do nothing if there is no form
						if (!targetForm) {
							return;
						}
						
						var nextBusFormattedLatLong = ((x, y) => {
							var output = "";
							
							output = `${x.toString().substring(0, 9).padEnd(9, "0")}%2c${y.toString().substring(0, 11).padEnd(11, "0")}`;
							output = output.replace(/\./g, "");
							
							return output;
						})(position.coords.latitude, position.coords.longitude);
						
						var redirectURL = [
							"#"
							, viewPreference
							, "GPS"
							, nextBusFormattedLatLong
							, timeDisplayPreference ? `?timeDisplay=${timeDisplayPreference}` : ""
						]
						.join("/")
						.replace(/\/\//g, "");
						
						targetForm.action = `${apiURL}/${redirectURL}`;
						
						window.location.href = targetForm.action;
					});
					
					navigator.permissions && navigator.permissions
					.query({name: "geolocation"})
					.then(permission => {
						if (permission.state !== "granted" && permission.state !== "prompt") {
							var noGPSErrorMessageModal = document.querySelector('[data-infowindow-name="Next Bus Location Services"]');
							
							noGPSErrorMessageModal && noGPSErrorMessageModal.showModal();
						}
					});
				}
			}
			, onSubmit: e => {
				var targetForm = e.target;
				
				window.location.href = targetForm.action;
				
				e.preventDefault();
				return false;
			}
		});
		
		window.FieldSync && window.FieldSync.init();
		
		window.getElapsedTimeInMilliseconds && window.getElapsedTimeInMilliseconds("init-js-inlined-driver-parsing-timer", "time-spent-parsing-init-js-inlined-driver");
	});
</script> <script type="module" class="inlined-driver">
	import { buildEnvironmentSpecificURL } from "https://tlweblibs.translink.ca/buildEnvironmentSpecificURL-1.0.1.mjs";
	import { getHTMLIDString } from "https://tlweblibs.translink.ca/URLHelpers-1.0.0.mjs";
	import { PersistentStorage } from "https://tlweblibs.translink.ca/PersistentStorage-2.0.1.mjs";
	import { CRITICAL_ALERT_ROUTELINE_NUMBER, formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber } from "/js/gtfsHelpers.mjs";
	import { GTFS_HANDYDART_LINE_NUMBER, GTFS_HANDYDART_LINE_NAME, GTFS_LINE_NUMBERS, GTFS_LINE_NAMES } from "/js/gtfsLines.mjs";
	import { fetchGTFSRouteLinesByNumber, fetchGTFSRouteLineFullNames } from "/js/gtfsRouteLines.mjs";
	import { fetchGTFSStopsByNumber, fetchGTFSStopNames, fetchGTFSStopFullNames } from "/js/gtfsStops.mjs";
	import { GTFS_STATION_NUMBERS, GTFS_STATION_NAMES, fetchGTFSStationNames } from "/js/gtfsStations.mjs";
	import { fetchSubscribableGTFSItemFullNames } from "/js/alertSubscriptions.mjs";
	import { NextBusSettings } from "/js/NextBusSettings.mjs";
	
	window.Autocomplete && window.Autocomplete.init({
		searchTermMinLength: 3
		, numberOfResults: 5
		, suggesterPaths: window.codeo && window.codeo.siteSuggesterPaths
	});
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("Site Search", {
		apiURL: await buildEnvironmentSpecificURL("https://postaway.translink.ca/api/autocomplete")
		, buildSearchQueryURL: (apiURL, searchTerm, numResults, suggesterPaths) => {
			var output = new URL(apiURL);
			output.searchParams.set("MaxResults", numResults);
			output.searchParams.set("Term", searchTerm);
			output.searchParams.set("IndexName", window.codeo.searchIndex || "");
			output.searchParams.set(
				"PathIds"
				, [
					"8e26d03f369d4346825cf7a16af50993"
					, "0329034065ae418e964bcb819a8d6932"
					, "ee4e2425842046768134f2af005fb1eb"
				].join(",")
			);
			
			return output;
		}
		, parseSearchQueryResults: results => {
			var output = [];
			
			results && results.results && results.results.forEach(curResult => {
				if (curResult !== "") { 
					output.push(curResult);
				}
			});
			
			return output;
		}
		, doesSearchQueryResultsHaveErrors: results => {
			if (results.errorMessage === null || results.errorMessage === undefined) {
				return false;
			}
			
			return true;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "searchQuerySuggestions"
		, storageKey: "searchAutoComplete"
	});
	
	var googlePlacesSearchboxElements = document.querySelectorAll('[type="search"][list="placesQuerySuggestions"]');  //??? [list] value is duplicated, consider moving into static string;
	
	if (googlePlacesSearchboxElements.length > 0) {
		var downloadGooglePlacesScriptController = new AbortController();
		
		googlePlacesSearchboxElements.forEach(curGooglePlacesSearchboxElement => {
			curGooglePlacesSearchboxElement.addEventListener("focus", () => {
				try {
					const googlePlacesScriptURLString = "https://maps.googleapis.com/maps/api/js?key=AIzaSyDyAIJCWHVz03z92budfeIHoJud2OtuqjE&libraries=places";
					var googlePlacesScriptURL = googlePlacesScriptURLString && new URL(googlePlacesScriptURLString);
					
					var googlePlacesScriptElement = document.createElement("script");
					googlePlacesScriptElement.setAttribute("src", googlePlacesScriptURL);
					
					googlePlacesScriptElement.addEventListener("load", () => {
						window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("Google Places", {
							searchProxy: (() => {
								if (window.google && window.google.maps && window.google.maps.places && window.google.maps.places.AutocompleteService) {
									return new google.maps.places.AutocompleteService();
								}
							})()
							, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
								//??? replace with official GVTA bounds?
								var transitBounds = new google.maps.LatLngBounds(
									new google.maps.LatLng(49.004383, -123.423063)
									, new google.maps.LatLng(49.474111, -122.303510)
								);
								
								searchProxy && searchProxy.getPlacePredictions(
									{
										input: searchTerm
										, bounds: transitBounds
										, componentRestrictions: {
											country: "ca"
										}
									}
									, suggestions => {
										handleSearchQueryResults && handleSearchQueryResults(suggestions, profileName);
									}
								);
							}
							, parseSearchQueryResults: results => {
								var output = [];
								
								results && results.forEach(curResult => {
									var curResult = curResult && curResult.description;
									
									curResult && output.push(curResult);
								});
								
								return output;
							}
							, searchFieldSelector: '[type="search"]'
							, suggestionsListID: "placesQuerySuggestions"
							, storageKey: "GooglePlacesAutoComplete"
						});
					});
					
					document.documentElement.append(googlePlacesScriptElement);
					
					//make sure the script is only downloaded once
					downloadGooglePlacesScriptController && downloadGooglePlacesScriptController.abort();
				} catch (error) {
					console.error(error);
				}
			}, {
				signal: downloadGooglePlacesScriptController.signal
				//??? add a "runOnce" here for extra safety?
			});
		});
	}
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("GTFS Bus Route Numbers", {
		searchProxy: async () => {
			var allGTFSRouteFullNames = [];
			
			try {
				var allGTFSRouteLineFullNames = await fetchGTFSRouteLineFullNames;
				
				if (allGTFSRouteLineFullNames) {
					allGTFSRouteFullNames = Array.from(allGTFSRouteLineFullNames)
					.filter(curGTFSRouteLineFullName => {
						var curGTFSRouteLineNumber = curGTFSRouteLineFullName.substring(0, curGTFSRouteLineFullName.indexOf(" "));
						
						var isGTFSRoute = true;
						
						if (curGTFSRouteLineNumber === CRITICAL_ALERT_ROUTELINE_NUMBER) {
							isGTFSRoute = false;
						}
						
						if (curGTFSRouteLineNumber === GTFS_HANDYDART_LINE_NUMBER) {
							isGTFSRoute = false;
						}
						
						if (GTFS_LINE_NUMBERS.has(curGTFSRouteLineNumber) === true) {
							isGTFSRoute = false;
						}
						
						return isGTFSRoute;
					});
				}
			} catch (error) {
				console.error(error);
			} finally {
				return allGTFSRouteFullNames;
			}
		}
		, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
			searchTerm = searchTerm.toLowerCase();
			
			var output = searchProxy.filter(curSuggestion => {
				if (curSuggestion && curSuggestion.toLowerCase().includes(searchTerm) === true) {
					return true;
				}
			}).slice(0, numResults);
			
			//if the user is not searching with leading 0s, we need to remove them
			//??? is there a way to combine it with the previous iterating?  probably not because we need to allow searching with leading 0s
			if (searchTerm.startsWith("0") === false) {
				output = output.map(gtfsRouteLineFullName => {
					var gtfsRouteLineNumber = gtfsRouteLineFullName.substring(0, gtfsRouteLineFullName.indexOf(" "));
					var gtfsRouteLineName = gtfsRouteLineFullName.substring(gtfsRouteLineFullName.indexOf(" ") + 1);
					
					var unpaddedGTFSRouteLineNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(gtfsRouteLineNumber);
					
					return `${unpaddedGTFSRouteLineNumber} ${gtfsRouteLineName}`;
				});
			}
			
			handleSearchQueryResults(output, profileName);
		}
		, parseSearchQueryResults: results => {
			return results;
		}
		, filterSearchQueryResults: undefined
		, injectSearchQueryResults: undefined
		, sortSuggestions: undefined
		, createSuggestion: curSuggestion => {
			var endOfRouteNumberIndex = curSuggestion.indexOf(" ");
			
			var routeNumber = curSuggestion.substring(0, endOfRouteNumberIndex);
			var routeName = curSuggestion.substring(endOfRouteNumberIndex);
			
			var suggestionItem = document.createElement("option");
			suggestionItem.setAttribute("value", routeNumber);
			suggestionItem.textContent = routeName;
			
			return suggestionItem;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "GTFSRouteNumbersQuerySuggestions"
		, searchTermMinLength: 1
	});
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("GTFS Line Names", {
		searchProxy: () => {
			var allGTFSLineNames = [];
			
			try {
				allGTFSLineNames = GTFS_LINE_NAMES.filter(curGTFSLineName => {
					var isHandyDART = curGTFSLineName === GTFS_HANDYDART_LINE_NAME;
					
					if (isHandyDART === true) {
						return false;
					} else {
						return true;
					}
				});
			} catch (error) {
				console.error(error);
			} finally {
				return allGTFSLineNames;
			}
		}
		, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
			searchTerm = searchTerm.toLowerCase();
			
			var output = searchProxy.filter(curSuggestion => {
				if (curSuggestion && curSuggestion.toLowerCase().includes(searchTerm) === true) {
					return true;
				}
			}).slice(0, numResults);
			
			handleSearchQueryResults(output, profileName);
		}
		, parseSearchQueryResults: results => {
			return results;
		}
		, filterSearchQueryResults: undefined
		, injectSearchQueryResults: undefined
		, sortSuggestions: undefined
		, createSuggestion: curSuggestion => {
			var suggestionItem = document.createElement("option");
			suggestionItem.setAttribute("value", curSuggestion);
			suggestionItem.textContent = curSuggestion;
			
			return suggestionItem;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "GTFSLineNameSuggestions"
		, searchTermMinLength: 1
	});
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("GTFS Route and Line Numbers", {
		searchProxy: async () => {
			var allGTFSRouteLineFullNames = [];
			
			try {
				allGTFSRouteLineFullNames = await fetchGTFSRouteLineFullNames;
				
				//??? shouldn't we be removing GTFSLineNumbers???
			} catch (error) {
				console.error(error);
			} finally {
				return allGTFSRouteLineFullNames;
			}
		}
		, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
			searchTerm = searchTerm.toLowerCase();
			
			var output = searchProxy.filter(curSuggestion => {
				if (curSuggestion && curSuggestion.toLowerCase().includes(searchTerm) === true) {
					return true;
				}
			}).slice(0, numResults);
			
			//if the user is not searching with leading 0s, we need to remove them
			//??? is there a way to combine it with the previous iterating?  probably not because we need to allow searching with leading 0s
			if (searchTerm.startsWith("0") === false) {
				output = output.map(gtfsRouteLineFullName => {
					var gtfsRouteLineNumber = gtfsRouteLineFullName.substring(0, gtfsRouteLineFullName.indexOf(" "));
					var gtfsRouteLineName = gtfsRouteLineFullName.substring(gtfsRouteLineFullName.indexOf(" ") + 1);
					
					var unpaddedGTFSRouteLineNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(gtfsRouteLineNumber);
					
					return `${unpaddedGTFSRouteLineNumber} ${gtfsRouteLineName}`;
				});
			}
			
			handleSearchQueryResults(output, profileName);
		}
		, parseSearchQueryResults: results => {
			return results;
		}
		, filterSearchQueryResults: undefined
		, injectSearchQueryResults: undefined
		, sortSuggestions: undefined
		, createSuggestion: curSuggestion => {
			var endOfRouteNumberIndex = curSuggestion.indexOf(" ");
			
			var routeNumber = curSuggestion.substring(0, endOfRouteNumberIndex);
			var routeName = curSuggestion.substring(endOfRouteNumberIndex);
			
			var suggestionItem = document.createElement("option");
			suggestionItem.setAttribute("value", routeNumber);
			suggestionItem.textContent = routeName;
			
			return suggestionItem;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "GTFSRouteLineNumbersQuerySuggestions"
		, searchTermMinLength: 1
	});
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("GTFS Stop Numbers", {
		searchProxy: async () => {
			var allGTFSStopFullNames = [];
			
			try {
				allGTFSStopFullNames = await fetchGTFSStopFullNames;
			} catch (error) {
				console.error(error);
			} finally {
				return allGTFSStopFullNames;
			}
		}
		, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
			searchTerm = searchTerm.toLowerCase();
			
			var output = searchProxy.filter(curSuggestion => {
				if (curSuggestion && curSuggestion.toLowerCase().includes(searchTerm) === true) {
					return true;
				}
			}).slice(0, numResults);
			
			handleSearchQueryResults(output, profileName);
		}
		, parseSearchQueryResults: results => {
			return results;
		}
		, filterSearchQueryResults: undefined
		, injectSearchQueryResults: undefined
		, sortSuggestions: undefined
		, createSuggestion: curSuggestion => {
			var endOfStopNumberIndex = curSuggestion.indexOf(" ");
			
			var stopNumber = curSuggestion.substring(0, endOfStopNumberIndex);
			var stopName = curSuggestion.substring(endOfStopNumberIndex);
			
			var suggestionItem = document.createElement("option");
			suggestionItem.setAttribute("value", stopNumber);
			suggestionItem.textContent = stopName;
			
			return suggestionItem;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "GTFSStopNumberSuggestions"
		, searchTermMinLength: 1
	});
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("GTFS Station Names", {
		searchProxy: async () => {
			var allGTFSStationNames = [];
			
			try {
				allGTFSStationNames = await fetchGTFSStationNames;
			} catch (error) {
				console.error(error);
			} finally {
				return allGTFSStationNames;
			}
		}
		, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
			searchTerm = searchTerm.toLowerCase();
			
			var output = searchProxy.filter(curSuggestion => {
				if (curSuggestion && curSuggestion.toLowerCase().includes(searchTerm) === true) {
					return true;
				}
			}).slice(0, numResults);
			
			handleSearchQueryResults(output, profileName);
		}
		, parseSearchQueryResults: results => {
			return results;
		}
		, filterSearchQueryResults: undefined
		, injectSearchQueryResults: undefined
		, sortSuggestions: undefined
		, createSuggestion: curSuggestion => {
			var suggestionItem = document.createElement("option");
			suggestionItem.setAttribute("value", curSuggestion);
			suggestionItem.textContent = curSuggestion;
			
			return suggestionItem;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "GTFSStationNameSuggestions"
		, searchTermMinLength: 1
	});
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("GTFS Location Numbers", {
		searchProxy: async () => {
			var allGTFSLocationNames = [];
			
			try {
				allGTFSLocationNames = await Promise.all([fetchGTFSStopNames, fetchGTFSStationNames]); //??? shouldn't this be getting GTFSStopFullNames because GTFSStopNumbers are legal search terms, but GTFSStationNumbers are not?
				allGTFSLocationNames = allGTFSLocationNames.flat();
			} catch (error) {
				console.error(error);
			} finally {
				return allGTFSLocationNames;
			}
		}
		, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
			searchTerm = searchTerm.toLowerCase();
			
			var output = searchProxy
			.filter(curSuggestion => {
				if (curSuggestion && curSuggestion.toLowerCase().includes(searchTerm) === true) {
					return true;
				}
			})
			.slice(0, numResults);
			
			handleSearchQueryResults(output, profileName);
		}
		, parseSearchQueryResults: results => {
			return results;
		}
		, filterSearchQueryResults: undefined
		, injectSearchQueryResults: undefined
		, sortSuggestions: undefined
		, createSuggestion: curSuggestion => {
			var suggestionItem = document.createElement("option");
			suggestionItem.setAttribute("value", curSuggestion);
			suggestionItem.textContent = curSuggestion;
			
			return suggestionItem;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "GTFSLocationNumberSuggestions"
		, searchTermMinLength: 1
	});
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("Subscribable GTFS Items", {
		searchProxy: async () => {
			var allSubscribableGTFSItemFullNames = [];
			
			try {
				allSubscribableGTFSItemFullNames = await fetchSubscribableGTFSItemFullNames;
				allSubscribableGTFSItemFullNames = Array.from(allSubscribableGTFSItemFullNames);
			} catch (error) {
				console.error(error);
			} finally {
				return allSubscribableGTFSItemFullNames;
			}
		}
		, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
			var output = [];
			
			searchTerm = searchTerm.toLowerCase();
			
			switch (searchTerm) {
				case "skytrain":
				case "sky train":
					; (() => {
						output = searchProxy.filter(curSuggestion => {
							if (curSuggestion.toLowerCase().endsWith("canada line") === true || curSuggestion.toLowerCase().endsWith("expo line") === true || curSuggestion.toLowerCase().endsWith("millennium line") === true) {
								return true;
							} else {
								return false;
							}
						}).slice(0, numResults);
					})();
					
					break;
				default:
					; (() => {
						output = searchProxy.filter(curSuggestion => {
							if (curSuggestion && curSuggestion.toLowerCase().includes(searchTerm) === true) {
								return true;
							}
						}).slice(0, numResults);
						
						//if the user is not searching with leading 0s, we need to remove them
						//??? is there a way to combine it with the previous iterating?  probably not because we need to allow searching with leading 0s
						if (searchTerm.startsWith("0") === false) {
							output = output.map(curResult => {
								var gtfsItemNumber = curResult.substring(0, curResult.indexOf(" "));
								var gtfsItemName = curResult.substring(curResult.indexOf(" ") + 1);
								
								var unpaddedGTFSItemNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(gtfsItemNumber);
								
								return `${unpaddedGTFSItemNumber} ${gtfsItemName}`;
							});
						}
					})();
					
					break;
			}
			
			handleSearchQueryResults(output, profileName);
		}
		, parseSearchQueryResults: results => {
			return results;
		}
		, filterSearchQueryResults: undefined
		, injectSearchQueryResults: undefined
		, sortSuggestions: undefined
		, createSuggestion: curSuggestedGTFSItem => {
			var gtfsItemNumber = curSuggestedGTFSItem.substring(0, curSuggestedGTFSItem.indexOf(" "));
			var gtfsItemName = curSuggestedGTFSItem.substring(curSuggestedGTFSItem.indexOf(" ") + 1);
			
			var suggestionItem = document.createElement("option");
			
			if (gtfsItemNumber === CRITICAL_ALERT_ROUTELINE_NUMBER || GTFS_LINE_NUMBERS.has(gtfsItemNumber) === true || GTFS_STATION_NUMBERS.has(gtfsItemNumber) === true) {
				suggestionItem.setAttribute("value", gtfsItemName);
			} else {
				suggestionItem.setAttribute("value", gtfsItemNumber);
				suggestionItem.textContent = gtfsItemName;
			}
			
			return suggestionItem;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "SubscribableGTFSItems"
		, searchTermMinLength: 1
	});
	
	window.Autocomplete && window.Autocomplete.isInited && window.Autocomplete.load("GTFS Search", {
		searchProxy: async () => {
			try {
				var [allGTFSRouteLineFullNames, allGTFSStopFullNames, allGTFSStationNames] = await Promise.all([fetchGTFSRouteLineFullNames, fetchGTFSStopFullNames, fetchGTFSStationNames]); //??? shouldn't this only be return GTFSStationNames, not GTFSStationFullNames?
				
				var allGTFSItemsWithSchedules = Array.from(allGTFSRouteLineFullNames)
				.filter(curGTFSRouteLineFullName => {
					var isHandyDART = curGTFSRouteLineFullName.toLowerCase().startsWith(GTFS_HANDYDART_LINE_NUMBER.toLowerCase());
					var isCriticalAlert = curGTFSRouteLineFullName.startsWith(CRITICAL_ALERT_ROUTELINE_NUMBER);
					
					var doesCurGTFSRouteLineHaveSchedule = isHandyDART === false && isCriticalAlert === false;
					
					return doesCurGTFSRouteLineHaveSchedule;
				})
				.concat(allGTFSStopFullNames)
				.concat(Array.from(allGTFSStationNames));  //??? surely this is a more efficient way to join everything together into an array? "FunctionalHelpers.mergeSimpleCollections"?
				
				return allGTFSItemsWithSchedules;
			} catch (error) {
				console.error(error);
			}
		}
		, querySearchProxy: (searchProxy, searchTerm, numResults, handleSearchQueryResults, profileName) => {
			searchTerm = searchTerm.toLowerCase();
			
			var output = searchProxy
			.filter(curSuggestion => {
				var formattedCurSuggestion = curSuggestion;
				
				var foundGTFSLineNumber = Array.from(GTFS_LINE_NUMBERS).find(curGTFSLineNumber => {
					var output = formattedCurSuggestion.startsWith(curGTFSLineNumber);
					
					return output;
				});
				
				if (foundGTFSLineNumber) {
					formattedCurSuggestion = formattedCurSuggestion.replace(`${foundGTFSLineNumber} `, "");
				}
				
				if (formattedCurSuggestion && formattedCurSuggestion.toLowerCase().includes(searchTerm) === true) {
					return true;
				}
			})
			.slice(0, numResults);
			
			//if the user is not searching with leading 0s, we need to remove them
			//??? is there a way to combine it with the previous iterating?  probably not because we need to allow searching with leading 0s
			if (searchTerm.startsWith("0") === false) {
				output = output.map(curResult => {
					var gtfsItemNumber = curResult.substring(0, curResult.indexOf(" "));
					var gtfsItemName = curResult.substring(curResult.indexOf(" ") + 1);
					
					var unpaddedGTFSItemNumber = formatGTFSRouteLineNumberAsUnpaddedGTFSRouteLineNumber(gtfsItemNumber);
					
					return `${unpaddedGTFSItemNumber} ${gtfsItemName}`;
				});
			}
			
			handleSearchQueryResults(output, profileName);
		}
		, parseSearchQueryResults: results => {
			return results;
		}
		, filterSearchQueryResults: undefined
		, injectSearchQueryResults: undefined
		, sortSuggestions: undefined
		, createSuggestion: curSuggestedGTFSItem => {
			//SHORT-CIRCUIT: we can short-circuit here because we do not download GTFSStationFullNames, just the GTFSStationName, which is exactly what we want to return without doing any formatting
			var suggestionItem = document.createElement("option");
			
			if (GTFS_STATION_NAMES.has(curSuggestedGTFSItem) === true) {
				suggestionItem.setAttribute("value", curSuggestedGTFSItem);
				
				return suggestionItem;	
			}
			
			var gtfsItemNumber = curSuggestedGTFSItem.substring(0, curSuggestedGTFSItem.indexOf(" "));
			var gtfsItemName = curSuggestedGTFSItem.substring(curSuggestedGTFSItem.indexOf(" ") + 1);
			
			if (GTFS_LINE_NUMBERS.has(gtfsItemNumber) === true) {
				suggestionItem.setAttribute("value", gtfsItemName);
			} else {
				suggestionItem.setAttribute("value", gtfsItemNumber);
				suggestionItem.textContent = gtfsItemName;
			}
			
			return suggestionItem;
		}
		, searchFieldSelector: '[type="search"]'
		, suggestionsListID: "GTFSItemURLs"
		, onFocus: targetInput => {
			var targetInputList = targetInput.hasAttribute("list") && targetInput.getAttribute("list");
			
			if (targetInputList) {
				var targetDataListElement = document.getElementById(targetInputList);
				
				if (targetDataListElement) {
					targetInput.setAttribute("data-list", targetInputList);
					targetInput.removeAttribute("list", targetInputList);
				}
			}
		}
		, onAfterBuildSuggestionsList: (targetSuggestionsListElement, searchBoxSelectorString) => {
			var searchBox = searchBoxSelectorString && document.querySelector(searchBoxSelectorString);
			
			//GUARD: do nothing if no searchbox is found
			if (!searchBox) {
				return;
			}
			
			var searchBoxID = searchBox.hasAttribute("id") && searchBox.getAttribute("id");
			
			var suggestionsPopoverElementWrapper = document.createElement("div");
			suggestionsPopoverElementWrapper.setAttribute("class", "absoluteContainer");
			suggestionsPopoverElementWrapper.setAttribute("style", "z-index: 9000;");
			
			var suggestionsPopoverElement = document.createElement("popper-upper");
			searchBoxID && suggestionsPopoverElement.setAttribute("data-for", searchBoxID);
			suggestionsPopoverElement.setAttribute("class", "flexColumn useContentSpacing useFontColor");
			suggestionsPopoverElement.setAttribute("style", "position: absolute; display: flex; padding: 1rem; background-color: white; border: 1px solid var(--lightGrey); border-radius: 3px; box-shadow: 0rem 0.75rem 1rem 0.5rem rgba(0, 0, 0, 0.06); width: 100%; overflow-x: hidden; overflow-y: auto; overscroll-behavior: none; transform: translateY(-1px);");
			
			suggestionsPopoverElementWrapper.append(suggestionsPopoverElement);
			
			searchBox.after(suggestionsPopoverElementWrapper);
			
			searchBox.addEventListener("input", e => {
				var targetInput = e.target;
				
				if (targetInput.value === "") {
					suggestionsPopoverElement.setAttribute("hidden", "");
				} else {
					suggestionsPopoverElement.removeAttribute("hidden");
				}
			});
			
			searchBox.addEventListener("input", e => {
				var targetInput = e.target;
				
				if (targetInput.value === "") {
					suggestionsPopoverElement.setAttribute("hidden", "");
				} else {
					suggestionsPopoverElement.removeAttribute("hidden");
				}
			});
			
			window.findDynamicComponent({
				parentContainerNode: targetSuggestionsListElement
				, targetSelector: "option"
				, targetChanges: [
					"childList"
				]
				, callbackFunction: targetSuggestionElement => {
					var allSuggestionElements = targetSuggestionsListElement.querySelectorAll("option");
					
					//GUARD: do nothing if this is not the last suggestion element
					//NOTE: this is for debouncing purposes
					if (targetSuggestionElement !== allSuggestionElements[allSuggestionElements.length - 1]) {
						return;
					}
					
					window.deleteAllChildNodes && window.deleteAllChildNodes(suggestionsPopoverElement);
					
					allSuggestionElements.forEach(async curSuggestionElement => {
						var curSuggestionValue = curSuggestionElement.hasAttribute("value") && curSuggestionElement.getAttribute("value");
						
						//GUARD: do nothing if there is no suggestion found
						if (!curSuggestionValue) {
							return;
						}
						
						curSuggestionValue = curSuggestionValue.replaceAll(/^0+/g, "");  //NOTE: replace all leading 0s
						
						var curSuggestionName = curSuggestionElement.textContent;
						
						var [allGTFSRouteLinesByNumber, allGTFSStopsByNumber] = await Promise.all([fetchGTFSRouteLinesByNumber, fetchGTFSStopsByNumber]);
						
						var gtfsRouteLineNumbersWithSchedules = allGTFSRouteLinesByNumber && Array.from(allGTFSRouteLinesByNumber.keys())
						.filter(curGTFSRouteLineNumber => {
							var doesCurGTFSRouteLineNumberHaveSchedule = curGTFSRouteLineNumber.toLowerCase().startsWith(GTFS_HANDYDART_LINE_NUMBER) === false;
							
							return doesCurGTFSRouteLineNumberHaveSchedule;
						});
						
						var allGTFSStopNumbers = Array.from(allGTFSStopsByNumber.keys());
						
						var numGTFSItems = 0;
						numGTFSItems = numGTFSItems + (gtfsRouteLineNumbersWithSchedules && gtfsRouteLineNumbersWithSchedules.length || 0);
						numGTFSItems = numGTFSItems + (allGTFSStopNumbers && allGTFSStopNumbers.length || 0);
						
						//GUARD: do nothing if there are no GTFS items
						if (numGTFSItems === 0) {
							return;
						}
						
						try {
							var viewPreference = NextBusSettings.getSetting("viewPreference") || "text";
							
							var gtfsSchedulePageURLString = "";
							
							if (gtfsRouteLineNumbersWithSchedules && gtfsRouteLineNumbersWithSchedules.includes(curSuggestionValue) === true && GTFS_LINE_NAMES.has(curSuggestionValue) === false) {
								if (viewPreference === "text") {
									gtfsSchedulePageURLString = `/schedules-and-maps/route/${curSuggestionValue}/direction/0/schedule`;  //??? hardcoding URL template strings is bad
								} else {
									gtfsSchedulePageURLString = `/schedules-and-maps/route/${curSuggestionValue}/direction/0/map`;  //??? hardcoding URL template strings is bad
								}
							} else if (GTFS_LINE_NAMES.has(curSuggestionValue) === true) {
								if (viewPreference === "text") {
									gtfsSchedulePageURLString = `/schedules-and-maps/line/${getHTMLIDString(curSuggestionValue)}/direction/0/schedule`;  //??? hardcoding URL template strings is bad
								} else {
									gtfsSchedulePageURLString = `/schedules-and-maps/line/${getHTMLIDString(curSuggestionValue)}/direction/0/map`;  //??? hardcoding URL template strings is bad
								}
							} else if (allGTFSStopNumbers && allGTFSStopNumbers.includes(curSuggestionValue) === true) {
								if (viewPreference === "text") {
									gtfsSchedulePageURLString = `/schedules-and-maps/stop/${curSuggestionValue}/schedule`;  //??? hardcoding URL template strings is bad
								} else {
									gtfsSchedulePageURLString = `/schedules-and-maps/stop/${curSuggestionValue}/map`;  //??? hardcoding URL template strings is bad
								}
							} else if (GTFS_STATION_NAMES.has(curSuggestionValue) === true) {
								var formattedGTFSStationName = getHTMLIDString(curSuggestionValue.replace(" Station", ""));
								
								if (viewPreference === "text") {
									gtfsSchedulePageURLString = `/schedules-and-maps/station/${formattedGTFSStationName}/schedule`;  //??? hardcoding URL template strings is bad
								} else {
									gtfsSchedulePageURLString = `/schedules-and-maps/station/${formattedGTFSStationName}/map`;  //??? hardcoding URL template strings is bad
								}
							}
							
							var gtfsSchedulePageURL = gtfsSchedulePageURLString && new URL(gtfsSchedulePageURLString, document.location.origin);
							
							var newSuggestionElement = document.createElement("a");
							newSuggestionElement.setAttribute("href", gtfsSchedulePageURL);
							newSuggestionElement.setAttribute("class", "flexContainer flexColumn");
							
							var newSuggestionGTFSItemTitle = document.createElement("strong");
							newSuggestionGTFSItemTitle.textContent = curSuggestionValue;
							
							var newSuggestionGTFSItemDescription;
							
							if (curSuggestionName) {
								newSuggestionGTFSItemDescription = document.createElement("span");
								newSuggestionGTFSItemDescription.setAttribute("style", "margin-top: 0px;");
								newSuggestionGTFSItemDescription.textContent = curSuggestionName;
							}
							
							newSuggestionElement.append(newSuggestionGTFSItemTitle);
							newSuggestionGTFSItemDescription && newSuggestionElement.append(newSuggestionGTFSItemDescription);
							
							//??? these 'does exist' checks are purely for 'debouncing' and async race condition purposes; this FDC callback is getting called way too often
							var matchingSuggestionElementInTargetSuggestionsContainer = targetSuggestionsListElement.querySelector(`option[value="${curSuggestionValue}"]`);
							var matchingSuggestionElementInSuggestionsPopover = suggestionsPopoverElement.querySelector(`a[href="${gtfsSchedulePageURL}"]`);
							
							if (matchingSuggestionElementInTargetSuggestionsContainer && !matchingSuggestionElementInSuggestionsPopover) {
								suggestionsPopoverElement.append(newSuggestionElement);
								
								newSuggestionElement.addEventListener("click", e => {
									if (window.TemporaryStorage) {
										window.TemporaryStorage.setItem("gtfs-search-for", curSuggestionValue);
									}
								});
							}
						} catch (error) {
							console.error(error);
						}
					});
				}
			});
			
			var suggestionsListID = targetSuggestionsListElement.hasAttribute("id") && targetSuggestionsListElement.getAttribute("id");
			
			searchBox.removeAttribute("list");
			searchBox.setAttribute("data-list", suggestionsListID);
		}
		, searchTermMinLength: 1
		, numberOfResults: window.matchMedia("not all and (min-width: 48em)").matches === true ? 3 : undefined
	});
</script> <script>
	; (() => {
		/*
			"gtfs-search-for" is a value used specifically when the user clicks an autosuggestion, but it leads to a GTFS page that doesn't exist yet.
			
			1. For any given GTFS Schedule AutosuggestionLink, the user clicks it
			2. Then, they are redirected to linked GTFS Schedule Page
			3. However, they are redirected to the Transit 404 page immediately since there is no actual GTFS Schedule Page
			4. On the Transit 404 page, if the target GTFS Schedule page is on a "redirect list", then we redirect them to an "under construction" page
			
			Since we only want the redirect in step-4 to run if the user follows this exact user story (time-sensitive), we must delete the "gtfs-search-for" value ASAP (aka on every single page load), so the user doesn't visit the "under construction" page in the future and get an unexpected redirect.
		*/
		
		window.TemporaryStorage && window.TemporaryStorage.removeItem && window.TemporaryStorage.removeItem("gtfs-search-for");
	})();
</script><script class="EmergencyTakeoverSnooze">
	; (() => {
		//??? refactor 'document.querySelectorAll(targetSelector)' to be cached instead of calling it repeatedly
		const targetSelector = '[data-infowindow-name="Emergency Takeover"]';  //??? should these be const? if so, their names should be capitalized right?
		const storageKey = "EmergencyTakeoverSnooze";  //??? should these be const? if so, their names should be capitalized right?
		
		var unsnoozeOnScroll = () => {
			window.localStorage && localStorage.removeItem(storageKey);
		};
		
		var previousSnoozeTime = new Date(window.localStorage && localStorage.getItem(storageKey));
		var currentTime = new Date();
		const TWENTY_MINUTES_IN_MILLISECONDS = 300000;  //1,200,000ms is 20minutes
		
		if (!previousSnoozeTime || (currentTime - previousSnoozeTime) >= TWENTY_MINUTES_IN_MILLISECONDS) {
			Array.from(document.querySelectorAll(targetSelector)).forEach(curTarget => {
				curTarget && curTarget.showModal();
				curTarget.scrollTo(0, 0);
				
				window.addEventListener("scroll", unsnoozeOnScroll, window.setPassiveEventListener);
			});
		}
		
		Array.from(document.querySelectorAll(targetSelector)).forEach(curTarget => {
			curTarget && curTarget.addEventListener("close", () => {
				window.removeEventListener("scroll", unsnoozeOnScroll);
			});
			
			curTarget && curTarget.querySelector('[type="submit"]').addEventListener("click", () => {
				window.localStorage && localStorage.setItem(storageKey, new Date());
			});
			
			Array.from(document.querySelectorAll('[type="submit"]')).forEach(curTarget => {
				curTarget.addEventListener("click", () => {
					window.localStorage && localStorage.setItem(storageKey, new Date());
				});
			});
		});
	})();
</script><style class="emergencytakeover">
	[data-infowindow-name="Emergency Takeover"]
	{
		border: 0.5rem solid #D9212C !important;
		
		border-radius: 0px;
	}
	
	[data-infowindow-name="Emergency Takeover"] .Header > h1
	, [data-infowindow-name="Emergency Takeover"] .Header > h2
	, [data-infowindow-name="Emergency Takeover"] .Header > h3
	, [data-infowindow-name="Emergency Takeover"] .Header > h4
	, [data-infowindow-name="Emergency Takeover"] .Header > h5
	, [data-infowindow-name="Emergency Takeover"] .Header > h6
	{
		display: flex;
		
		align-items: center;
		
		margin-top: 0px !important;
	}
	
	[data-infowindow-name="Emergency Takeover"] .Header > h1:before
	, [data-infowindow-name="Emergency Takeover"] .Header > h2:before
	, [data-infowindow-name="Emergency Takeover"] .Header > h3:before
	, [data-infowindow-name="Emergency Takeover"] .Header > h4:before
	, [data-infowindow-name="Emergency Takeover"] .Header > h5:before
	, [data-infowindow-name="Emergency Takeover"] .Header > h6:before
	{
		content: "";
		
		display: inline-block;
		
		margin-right: 1rem;
		
		width: 3rem;
		height: 3rem;
		
		background-repeat: no-repeat;
		background-image: url("data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcC1wYXRoIj48cmVjdCB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiLz48L2NsaXBQYXRoPjwvZGVmcz48dGl0bGU+Y3JpdGljYWxfYWxlcnRfaWNvbjwvdGl0bGU+PGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAtcGF0aCkiPjxnIGlkPSJDb21wb25lbnQiPjxwYXRoIGlkPSJQYXRoXzc4IiBkYXRhLW5hbWU9IlBhdGggNzgiIGQ9Ik0xMiwwQTEyLDEyLDAsMSwxLDAsMTIsMTIsMTIsMCwwLDEsMTIsMFoiIGZpbGw9IiNlZjQxMzUiLz48ZyBpZD0iR3JvdXBfOTEiIGRhdGEtbmFtZT0iR3JvdXAgOTEiPjxwYXRoIGlkPSJQYXRoXzc5IiBkYXRhLW5hbWU9IlBhdGggNzkiIGQ9Ik0xMiwyMC41YTEuOTEsMS45MSwwLDAsMS0xLjktMS45NGgwYTEuOTQsMS45NCwwLDAsMSwzLjg4LS4wN3YuMDdBMiwyLDAsMCwxLDEyLDIwLjVaTTEzLjE5LDE1aC0yLjRMMTAuMDgsNGwzLjc3LS41NFoiIGZpbGw9IiNmZmYiLz48L2c+PC9nPjwvZz48L3N2Zz4=");
		background-size: contain;
	}
</style><script>
	; (() => {
		/*
			"search-for" is a value used specifically when the user clicks a button to create an alert, but must login first.
			
			1. On page A, the user clicks the 'create alert for ###" button
			2. Then, they are redirected to the 3rd-party login page
			3. After successfully logging in, they are redirected to their preferences page
			4. On the preferences page, another script will read this variable and redirect them to the create alert page
			
			since we only want the redirect in step-4 to run if the user follows this exact user story (time-sensitive), we must delete the 'search-for' value ASAP (aka on every single page load), so the user doesn't visit the preferences page in the future and get an unexpected redirect.
		*/
		
		var curURLString = document.location.href;
		var curURL = curURLString && new URL(curURLString);
		
		var formattedCurURLString = curURL.origin + curURL.pathname;
		
		var excludedURLStrings = [
			"/signin"
		];
		
		var isCurURLExcluded = excludedURLStrings.some(curExcludedURLString => {
			var curExcludedURL = curExcludedURLString && new URL(curExcludedURLString, document.location.origin);
			
			if (!curExcludedURL) {
				return false;
			}
			
			var formattedCurExcludedURLString = curExcludedURL.origin + curExcludedURL.pathname;
			
			if (formattedCurURLString === formattedCurExcludedURLString) {
				return true;
			}
		});
		
		isCurURLExcluded === false && window.TemporaryStorage && window.TemporaryStorage.removeItem && window.TemporaryStorage.removeItem("search-for");
	})();
</script><script>
	;(() => {
		const referenceURLStrings = {
			alertsPage: "/alerts"
			, skytrainAlertsIcon: "/-/media/translink/icons/alerts/skytrain.svg"
			, emailSignupConfirmationPage: "/email-signup-confirmation"
			, compassCardPage: "/transit-fares/compass-card"
			, createAlertPage: "/alert-subscriptions/create-alert"
			, nextBusGPSTextViewPage: "/next-bus/stops-and-stations-nearby"
			, nextBusGPSMapViewPage: "/next-bus/stops-and-stations-nearby/map"
			, nextBusRealtimeIcon: "/-/media/translink/icons/transit-schedules/realtime_icon.svg"
			, editAlertPage: "/alert-subscriptions/create-alert/edit-alert"
			, nextBusFavouritesPage: "/schedules-and-maps/favourites"
		};
		
		var curURLStrings = {
			alertsPage: "/alerts"
			, skytrainAlertsIcon: "/-/media/translink/icons/alerts/skytrain.svg"
			, emailSignupConfirmationPage: "/email-signup-confirmation"
			, compassCardPage: "/transit-fares/compass-card"
			, createAlertPage: "/alert-subscriptions/create-alert"
			, nextBusGPSTextViewPage: "/next-bus/stops-and-stations-nearby"
			, nextBusGPSMapViewPage: "/next-bus/stops-and-stations-nearby/map"
			, nextBusRealtimeIcon: "/-/media/translink/icons/transit-schedules/realtime_icon.svg"
			, editAlertPage: "/alert-subscriptions/create-alert/edit-alert"
			, nextBusFavouritesPage: "/schedules-and-maps/favourites"
		};
		
		var isCurURLStringsMatchingReferenceURLStrings = JSON.stringify(referenceURLStrings) === JSON.stringify(curURLStrings);
		
		if (isCurURLStringsMatchingReferenceURLStrings === false) {
			console.error("System has not correctly dereferenced links");
		}
	})();
</script><!-- END OF Global Body JS -->
    <!-- Site Body JS -->
    <!-- END OF Site Body JS -->
    <!-- Page Body JS -->
    <!-- END OF Page Body JS --> <template id="PrefetchableBlockLayouts">
      <link href="flexColumnBlock-Large-1.0.0.css" rel="stylesheet" integrity="sha256-D7LJNQqcBRHgj4HqjZMF+ExYwKaBMA4GD28F4INi6zo="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="flexColumnBlock-Small-1.0.0.css" rel="stylesheet" integrity="sha256-xAYHDlz3BckRocqBFkW84n/judA0UTA1CWe1Y2n1yP4="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <style class="FlexImageBlockLayout-large-100">
	@media (min-width: 48em) {
		.FlexImageBlockLayout
		{
			--blockPaddingTopRow: 3.3333rem;
			--blockPaddingBottomRow: 3.3333rem;
			
			grid-template-areas: ". . ."
								 ". ImageMain ."
								 ". . .";
			
			grid-template-columns: [fullBleed-start] 1fr [background-start] minmax(42.6667rem, 79.9993rem) [background-end] 1fr [fullBleed-end];
			grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content var(--blockPaddingBottomRow) [background-end];	
		}
		
		.FlexImageBlockLayout.noSidePadding
		{
			grid-template-areas: ". . ."
								 "ImageMain ImageMain ImageMain"
								 ". . .";
		}
		
		.FlexImageBlockLayout > *:not(.Background):not(.ImageMain)
		{ 
			display: none;
		}
	}
</style> <style class="FlexImageBlockLayout-small-100">
	@media not all and (min-width: 48em) {
		.FlexImageBlockLayout
		{
			--blockPaddingColumn: 1rem;
			
			--blockPaddingTopRow: 3.3333rem;
			--blockPaddingBottomRow: 3.3333rem;
			
			grid-template-areas: ". . ."
								 "ImageMain ImageMain ImageMain"
								 ". . .";

			grid-template-columns: [background-start] var(--blockPaddingColumn) 1fr var(--blockPaddingColumn) [background-end];	
			grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content var(--blockPaddingBottomRow) [background-end];
		}

		.FlexImageBlockLayout > *:not(.Background):not(.ImageMain)
		{ 
			display: none;
		}
	}
</style><style class="LeftJustifiedFlexImageBlockLayout-100">
	.LeftJustifiedFlexImageBlockLayout
	{
		--blockPaddingTopRow: 3.3333rem;
		--blockPaddingBottomRow: 3.3333rem;
		
		grid-template-areas: ". . ."
							 ". ImageMain ."
							 ". . .";
		
		grid-template-columns: [fullBleed-start] 1fr [background-start] minmax(42.6667rem, 79.9993rem) [background-end] 1fr [fullBleed-end];
		grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content var(--blockPaddingBottomRow) [background-end];	
	}
	
	.LeftJustifiedFlexImageBlockLayout.noSidePadding
	{
		grid-template-areas: ". . ."
							 "ImageMain ImageMain ImageMain"
							 ". . .";
	}
		
	.LeftJustifiedFlexImageBlockLayout > *:not(.Background):not(.ImageMain)
	{ 
		display: none;
	}
</style><style class="FullColumnBlockLayout-large-100">
	@media (min-width: 48em) {
		.FullColumnBlockLayout
		{
			--blockPaddingTopRow: 3.3333rem;
			--blockPaddingBottomRow: 3.3333rem;
			
			grid-template-areas: ". . . . ."
								 ". . Header . ."
								 ". . . . ."
								 ". . CopyMain . ."
								 ". . . . .";
			
			grid-template-columns: [fullBleed-start] 1fr [background-start] 1rem minmax(40.6667rem, 77.9999rem) 1rem [background-end] 1fr [fullBleed-end];
			grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content 1rem min-content var(--blockPaddingBottomRow) [background-end];
		}

		.FullColumnBlockLayout > *:not(.Background):not(.Header):not(.CopyMain)
		{ 
			display: none;
		}

		.FullColumnBlockLayout > .Header:empty ~ .CopyMain
		{
			grid-row: 2 / 5;
		}
	}
</style> <style class="FullColumnBlockLayout-small-100">
	@media not all and (min-width: 48em) {
		.FullColumnBlockLayout
		{
			--blockPaddingColumn: 1rem;
			
			--blockPaddingTopRow: 3.3333rem;
			--blockPaddingBottomRow: 3.3333rem;
			
			grid-template-areas: ". . ."
								 ". Header ."
								 ". . ."
								 ". CopyMain ."
								 ". . .";
			
			grid-template-columns: [background-start] var(--blockPaddingColumn) 1fr var(--blockPaddingColumn) [background-end];	
			grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content 1rem min-content var(--blockPaddingBottomRow) [background-end];
		}
		
		.FullColumnBlockLayout.noSidePadding
		{
			grid-template-areas: ". . ."
								 "Header Header Header"
								 ". . ."
								 "CopyMain CopyMain CopyMain"
								 ". . .";
		}
		
		.FullColumnBlockLayout > *:not(.Background):not(.Header):not(.CopyMain)
		{ 
			display: none;
		}
		
		.FullColumnBlockLayout > .Header:empty ~ .CopyMain
		{
			grid-row: 2 / 5;
		}
	}
</style><link href="UnholyGrailBlock-Large-1.0.0.css" rel="stylesheet" integrity="sha256-GfxlzKu8zEwaBs6u7db3lUdxXqnTHPYP9r0NTgEltPM="

        crossorigin="anonymous" media="(min-width: 64.5em)">
      <link href="UnholyGrailBlock-Small-1.0.0.css" rel="stylesheet" integrity="sha256-mfTe5Kn4yUTKOao4iuM25Uvl1qroov2Ik4hzQnI2AI4="

        crossorigin="anonymous" media="not all and (min-width: 64.5em)">
      <style class="narrowFlexColumnBlockLayout-large-100" media="(min-width: 48em)">
	.NarrowFlexColumnBlockLayout
	{
		--blockPaddingTopRow: 3.3333rem;
		--blockPaddingBottomRow: 3.3333rem;
		
		grid-template-areas: ". . . . ."
							 ". . Header . ."
							 ". . . . ."
							 ". . ImageMain . ."
							 ". . . . ."
							 ". . CopyMain . ."
							 ". . . . .";
		
		grid-template-columns: [fullBleed-start] 1fr [background-start] minmax(1rem, 18.8889rem) minmax(40.7222rem, 42.2222rem) minmax(1rem, 18.8889rem) [background-end] 1fr [fullBleed-end];
		grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content 1rem min-content 1rem min-content var(--blockPaddingBottomRow) [background-end];
	}
	
	.NarrowFlexColumnBlockLayout.noSidePadding
	{
		grid-template-areas: ". . . . ."
							 ". Header Header Header ."
							 ". . . . ."
							 ". CopyMain CopyMain CopyMain ."
							 ". . . . .";
	}
	
	.NarrowFlexColumnBlockLayout > *:not(.Background):not(.CopyMain):not(.ImageMain):not(.Header)
	{ 
		display: none;
	}
	
	.NarrowFlexColumnBlockLayout > .Header:empty ~ .ImageMain
	{
		grid-row: 2 / 5;
	}
	
	.NarrowFlexColumnBlockLayout > .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.NarrowFlexColumnBlockLayout > .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
	}
</style> <style class="narrowFlexColumnBlockLayout-small-100" media="not all and (min-width: 48em)">
	.NarrowFlexColumnBlockLayout
	{
		--blockPaddingColumn: 1rem;
		
		--blockPaddingTopRow: 3.3333rem;
		--blockPaddingBottomRow: 3.3333rem;
		
		grid-template-areas: ". . ."
							 ". Header ."
							 ". . ."
							 ". ImageMain ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: [background-start] var(--blockPaddingColumn) 1fr var(--blockPaddingColumn) [background-end];	
		grid-template-rows: [background-start] var(--blockPaddingTopRow) min-content 1rem min-content 1rem min-content var(--blockPaddingBottomRow) [background-end];
	}
	
	.NarrowFlexColumnBlockLayout > *:not(.Background):not(.CopyMain):not(.ImageMain):not(.Header)
	{ 
		display: none;
	}
	
	.NarrowFlexColumnBlockLayout > .Header:empty ~ .ImageMain
	{
		grid-row: 2 / 5;
	}
	
	.NarrowFlexColumnBlockLayout > .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.NarrowFlexColumnBlockLayout > .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
	}
</style><link href="wideFlexColumnBlock-Large-1.0.0.css" rel="stylesheet" integrity="sha256-ZrWHKT3I/SUPUh+Csyy/cyEEkwG/cbhPw2XT3q84Qx0="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="wideFlexColumnBlock-Small-1.0.0.css" rel="stylesheet" integrity="sha256-mrjoV2x65MwawJI3VXn6YQUhxIVUI6nbHk+eeyhGZZc="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <link href="wideFlexBorderedColumnBlock-Large-1.0.0.css" rel="stylesheet"

        integrity="sha256-Zl7OAKIKABImt5THu3s4an/J9z6+S4LuJ6xbAPyZUo0=" crossorigin="anonymous"

        media="(min-width: 48em)">
      <link href="wideFlexBorderedColumnBlock-Small-1.0.0.css" rel="stylesheet"

        integrity="sha256-MSY5T4qUJ95FhWzC5QRYWTrbRK+VOiLEQGdQN720yUw=" crossorigin="anonymous"

        media="not all and (min-width: 48em)">
      <link href="leftColumnContentBlock-Large-1.0.0.css" rel="stylesheet" integrity="sha256-peORzzQY5+uhJHefSWappv4LcrlkiZ6NBN9qEloNMn0="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="leftColumnContentBlock-Small-1.0.0.css" rel="stylesheet" integrity="sha256-zpEcAoqa9AtdmIkyFRGm0RKHAkkjuu7AHOgndIHvrEM="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <link href="featuredContentHeaderBlock-Large-1.0.0.css" rel="stylesheet" integrity="sha256-taMu2u3xO7MN8lSqtiZ6ll8+lvxCbAFAL32CboSH6r4="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="featuredContentHeaderBlock-Small-1.0.0.css" rel="stylesheet" integrity="sha256-PSuvufB5mKJEGI7sK8tni1Fy7QJwZMtcB2NwNHHHdMM="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <link href="twoColumnContentBlock-Large-3.0.0.css" rel="stylesheet" integrity="sha256-/nA3B3sPG9Qc6P8Qt/IcYD+6BqA6fjjfoIRPK+yJpOk="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="twoColumnContentBlock-Small-2.0.0.css" rel="stylesheet" integrity="sha256-JORdCWyRiip1W5+HKSTGw5kcR32QKXAkuR58rGwF+8U="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <link href="iconContentBlock-Large-1.0.0.css" rel="stylesheet" integrity="sha256-frz+6W6n7guGPXSwrK2YMGHz0gg9jWpSPu5iumzkjXA="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="iconContentBlock-Small-1.0.0.css" rel="stylesheet" integrity="sha256-02OQuALVRLTwQFGzGMFRJZYmCkEB79bIG/nQS1ecwm8="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <link href="paginatedContentBlock-Large-1.0.1.css" rel="stylesheet" integrity="sha256-eWx5aOuVIFeXmXBsN32PlCcPTExH5KhHr6SzH94AQFs="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="paginatedContentBlock-Small-1.0.1.css" rel="stylesheet" integrity="sha256-RL+jfJIQh7K0C34+csehF56LpVdg3Yn55TPvS5Dm6Yg="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <link href="PaginatedContentOverlayBlock-Large-1.1.0.css" rel="stylesheet"

        integrity="sha256-edymWWI/0O9d8GMY3SDbpO9XMMnzQ4QJeBkw6tIVE6E=" crossorigin="anonymous"

        media="(min-width: 48em)">
      <style class="SmallPaginatedContentOverlayBlock">
	@media not all and (min-width: 48em) {
		.PaginatedContentOverlayBlockLayout
		{
			--blockPaddingColumn: 1rem;
			
			--blockPaddingTopRow: 3.3333rem;
			--blockPaddingBottomRow: 2.2222rem;
			
			grid-template-areas: "CopyMain CopyMain CopyMain"
								 "CopyMain CopyMain CopyMain"
								 "CopyMain CopyMain CopyMain"
								 "CopyMain CopyMain CopyMain"
								 ". . .";

			grid-template-columns: [background-start] var(--blockPaddingColumn) 1fr var(--blockPaddingColumn) [background-end];	
			grid-template-rows: [background-start] var(--blockPaddingTopRow) auto 1rem auto var(--blockPaddingBottomRow) [background-end];
		}

		.PaginatedContentOverlayBlockLayout.noTopPadding
		{
			--blockPaddingTopRow: 0px;
		}

		.PaginatedContentOverlayBlockLayout.noBottomPadding
		{
			--blockPaddingBottomRow: 0px;
		}

		.PaginatedContentOverlayBlockLayout > *:not(.Background):not(.CopyMain)
		{ 
			display: none;
		}
	}
</style><link href="oneImageFullContentBlock-Large-1.0.0.css" rel="stylesheet" integrity="sha256-nkDb+qM4YNKqCCLaoC8ySLkV2LrfvXONZKR668o8cmw="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="oneImageFullContentBlock-Small-1.0.0.css" rel="stylesheet" integrity="sha256-iSbCEAxhufyXPtJ4GzhqsilfcrquiJ4iwRQh3B3rbr4="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <link href="oneImageBarBgContentBlock-Large-2.0.0.css" rel="stylesheet" integrity="sha256-Dgeodr+WM+fMXQ/pFcExkINcETLuJxxCT15Ls6INVFo="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="oneImageBarBgContentBlock-Small-2.0.0.css" rel="stylesheet" integrity="sha256-Oc0bTtXciZMq83blSuyP5/5r0TY20kl2/3Un0LyZlX4="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
      <link href="twoImageBarContentBlock-Large-2.0.1.css" rel="stylesheet" integrity="sha256-B3/3pmV5tyc4qTXxsXent9+23yJJ4uVR+XrDan1q1YA="

        crossorigin="anonymous" media="(min-width: 48em)">
      <link href="twoImageBarContentBlock-Small-2.0.0.css" rel="stylesheet" integrity="sha256-WcKvSwyV1EoEy4iHqIjLIzDqYU7Hhuk2AtF/sU76pHE="

        crossorigin="anonymous" media="not all and (min-width: 48em)">
    </template> <template id="PrefetchableInfoCardThemes">
      <style>
	article.InfoCard.overflowableInfoCardTheme
	{
		overflow: visible !important;
	}
</style><style class="overflowablePlainTextInfoCardTheme-100">
	.overflowablePlainTextInfoCardTheme
	{
		--leftPadding: 1rem;
		--rightPadding: 1rem;
		
		display: grid;
		
		grid-template-areas: ". . ."
							 ". Header ."
							 ". . ."
							 ". Image ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: var(--leftPadding) calc(100% - var(--leftPadding) - var(--rightPadding)) var(--rightPadding);
		grid-template-rows: 1rem min-content 1rem min-content 1rem min-content 1rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
	}
	
	.overflowablePlainTextInfoCardTheme .Header
	{
		grid-area: Header;
	}
	
	.overflowablePlainTextInfoCardTheme .ImageMain
	{
		grid-area: Image;
	}
	
	.overflowablePlainTextInfoCardTheme .CopyMain
	{
		grid-area: CopyMain;
		
		margin-top: 0px !important;
		
		overflow: visible !important;
	}
	
	.overflowablePlainTextInfoCardTheme .CTALinkContainer
	{
		display: none;
	}
	
	.overflowablePlainTextInfoCardTheme .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.overflowablePlainTextInfoCardTheme .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
		
		display: flex;
		
		flex-direction: column;
		justify-content: center;
	}
</style><style class="maxsizeplaintext-infocardtheme-110">
	.maxSizePlainTextInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: "Header"
							 "."
							 "Image"
							 "."
							 "CopyMain";
		
		grid-template-columns: 1fr;
		grid-template-rows: min-content 1rem min-content 1rem 1fr;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
	}
	
	.maxSizePlainTextInfoCardTheme .Header
	{
		grid-area: Header;
	}
	
	.maxSizePlainTextInfoCardTheme .ImageMain
	{
		grid-area: Image;
	}
	
	.maxSizePlainTextInfoCardTheme .CopyMain
	{
		grid-area: CopyMain;
	}
	
	.maxSizePlainTextInfoCardTheme .CTALinkContainer
	{
		display: none;
	}
	
	.maxSizePlainTextInfoCardTheme .ImageMain:empty ~ .CopyMain
	{
		grid-row: 3 / -1;
	}
	
	.maxSizePlainTextInfoCardTheme .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 1 / -1;
		
		display: flex;
		
		flex-direction: column;
		
		justify-content: center;
		
		margin-top: 0px;
	}
</style><style class="overflowablemaxsizeplaintext-infocardtheme-110">
	.overflowableMaxSizePlainTextInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: "Header"
							 "."
							 "Image"
							 "."
							 "CopyMain";
		
		grid-template-columns: 1fr;
		grid-template-rows: min-content 1rem min-content 1rem 1fr;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
	}
	
	.overflowableMaxSizePlainTextInfoCardTheme .Header
	{
		grid-area: Header;
	}
	
	.overflowableMaxSizePlainTextInfoCardTheme .ImageMain
	{
		grid-area: Image;
	}
	
	.overflowableMaxSizePlainTextInfoCardTheme .CopyMain
	{
		grid-area: CopyMain;
		
		overflow: visible !important;
	}
	
	.overflowableMaxSizePlainTextInfoCardTheme .CTALinkContainer
	{
		display: none;
	}
	
	.overflowableMaxSizePlainTextInfoCardTheme .ImageMain:empty ~ .CopyMain
	{
		grid-row: 3 / -1;
	}
	
	.overflowableMaxSizePlainTextInfoCardTheme .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 1 / -1;
		
		display: flex;
		
		flex-direction: column;
		
		justify-content: center;
		
		margin-top: 0px;
	}
</style><style class="plaintext-infocardtheme-110">
	.plainTextInfoCardTheme
	{
		--leftPadding: 1rem;
		--rightPadding: 1rem;
		
		display: grid;
		
		grid-template-areas: ". . ."
							 ". Header ."
							 ". . ."
							 ". Image ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: var(--leftPadding) calc(100% - var(--leftPadding) - var(--rightPadding)) var(--rightPadding);
		grid-template-rows: 1rem min-content 1rem min-content 1rem min-content 1rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
	}
	
	.plainTextInfoCardTheme .Header
	{
		grid-area: Header;
	}
	
	.plainTextInfoCardTheme .ImageMain
	{
		grid-area: Image;
	}
	
	.plainTextInfoCardTheme .CopyMain
	{
		grid-area: CopyMain;
		
		margin-top: 0px !important;
	}
	
	.plainTextInfoCardTheme .CTALinkContainer
	{
		display: none;
	}
	
	.plainTextInfoCardTheme .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.plainTextInfoCardTheme .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
		
		display: flex;
		
		flex-direction: column;
		justify-content: center;
	}
</style><style class="plaintextblurredbackground-infocardtheme-100">
	.plainTextBlurredBackgroundInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: ". . ."
							 ". Header ."
							 ". . ."
							 ". Image ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: 1rem 1fr 1rem;
		grid-template-rows: 1rem min-content 1rem min-content 1rem min-content 1rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
		
		backdrop-filter: blur(1px);
	}
	
	.plainTextBlurredBackgroundInfoCardTheme .Header
	{
		grid-area: Header;
	}
	
	.plainTextBlurredBackgroundInfoCardTheme .ImageMain
	{
		grid-area: Image;
	}
	
	.plainTextBlurredBackgroundInfoCardTheme .CopyMain
	{
		grid-area: CopyMain;
	}
	
	.plainTextBlurredBackgroundInfoCardTheme .CTALinkContainer
	{
		display: none;
	}
	
	.plainTextBlurredBackgroundInfoCardTheme .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.plainTextBlurredBackgroundInfoCardTheme .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
		
		display: flex;
		
		flex-direction: column;
		justify-content: center;
	}
</style><style class="plaintextblurredtallbackground-infocardtheme-100">
	.plainTextBlurredTallBackgroundInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: ". . ."
							 ". Header ."
							 ". . ."
							 ". Image ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: 1.5rem 1fr 1.5rem;
		grid-template-rows: 2.5rem min-content 1rem min-content 1rem min-content 2.5rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
		
		backdrop-filter: blur(1px);
	}
	
	.plainTextBlurredTallBackgroundInfoCardTheme .Header
	{
		grid-area: Header;
	}
	
	.plainTextBlurredTallBackgroundInfoCardTheme .ImageMain
	{
		grid-area: Image;
	}
	
	.plainTextBlurredTallBackgroundInfoCardTheme .CopyMain
	{
		grid-area: CopyMain;
	}
	
	.plainTextBlurredTallBackgroundInfoCardTheme .CTALinkContainer
	{
		display: none;
	}
	
	.plainTextBlurredTallBackgroundInfoCardTheme .ImageMain:empty ~ .CopyMain
	{
		grid-row: 4 / 7;
	}
	
	.plainTextBlurredTallBackgroundInfoCardTheme .Header:empty ~ .ImageMain:empty ~ .CopyMain
	{
		grid-row: 2 / 7;
		
		display: flex;
		
		flex-direction: column;
		justify-content: center;
	}
</style><link href="FeedStoryCard-infoCardTheme-1.0.0.css" rel="stylesheet" integrity="sha256-cFcJXWfsyzG2dDhW/slA8gChm0giCkm+llCVslVa0r8="

        crossorigin="anonymous">
      <style>
	.inlineIconStoryCardCTAPromoInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: ". . . . ."
							 ". ImageMain . Header ."
							 ". . . . ."
							 ". CopyMain CopyMain CopyMain."
							 ". . . . ."
							 ". CTA CTA CTA ."
							 ". . . . .";
		
		grid-template-columns: 1rem 2.2222rem 1rem 1fr 1rem;
		grid-template-rows: 1rem min-content 1rem min-content 1rem min-content 1rem;
		
		min-width: calc(320px - 2rem);
			
		border-radius: 3px;
	}
	
	.inlineIconStoryCardCTAPromoInfoCardTheme .Header 
	{
		display: flex;
		
		align-items: center;
	}
	
	.inlineIconStoryCardCTAPromoInfoCardTheme .CTALinkContainer 
	{
		grid-area: CTA;
	}

	.inlineIconStoryCardCTAPromoInfoCardTheme .CTALinkContainer a
	{
		display: inline-block;
		
		padding-top: 1rem;
		padding-bottom: 1rem;
		height: 100%;
		
		font-family: "Fira Sans Bold", Arial, Helvetica, sans-serif;
		
		font-size: 0.8888rem;
		
		font-weight: bold;
	}
</style><style class="storyCardNarrowCTAPromoInfoCardTheme-styling">
	.storyCardNarrowCTAPromoInfoCardTheme
	{
		display: flex;
		flex-direction: column;
			
		padding-top: 1rem;
		padding-right: 1rem;
		padding-left: 1rem;
			
		width: 100%;
		min-width: calc(320px - 2rem);
			
		border-radius: 3px;
	}
	
	.storyCardNarrowCTAPromoInfoCardTheme .Header
	, .storyCardNarrowCTAPromoInfoCardTheme .ImageMain
	, .storyCardNarrowCTAPromoInfoCardTheme .CopyMain
	, .storyCardNarrowCTAPromoInfoCardTheme .CTALinkContainer 
	{
		margin-bottom: 1rem;
	}
	
	.storyCardNarrowCTAPromoInfoCardTheme .ImageMain
	{
		order: -1;
	}
	
	.storyCardNarrowCTAPromoInfoCardTheme .ImageMain img
	{
		width: fit-content;
		border-radius: 3px;
	}
	
	.storyCardNarrowCTAPromoInfoCardTheme .CTALinkContainer 
	{
		align-self: flex-end;
		
		border: 2px solid currentColor;
		
		border-radius: 3px;
	}
	
	@media (min-width: 48rem) {
		.storyCardNarrowCTAPromoInfoCardTheme .CTALinkContainer 
		{
			width: 60%;
		}
	}
	
	@media not all and (min-width: 48rem) {
		.storyCardNarrowCTAPromoInfoCardTheme .CTALinkContainer 
		{
			width: 100%;
		}
	}
	
	.storyCardNarrowCTAPromoInfoCardTheme .CTALinkContainer a
	{
		display: flex;
		
		justify-content: center;
		align-items: center;
		
		height: 100%;
		padding: 1rem;
		
		text-align: center;
		text-decoration: none;
	}
</style><style class="fullImageStoryCardFlexCTAPromoInfoCardTheme-styling">
	.fullImageStoryCardFlexCTAPromoInfoCardTheme
	{
		display: flex;
		
		flex-direction: column;
		
		padding-right: 1rem;
		padding-left: 1rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
	}
	
	.fullImageStoryCardFlexCTAPromoInfoCardTheme .Header
	, .fullImageStoryCardFlexCTAPromoInfoCardTheme .ImageMain
	, .fullImageStoryCardFlexCTAPromoInfoCardTheme .CopyMain
	, .fullImageStoryCardFlexCTAPromoInfoCardTheme .CTALinkContainer 
	{
		margin-bottom: 1rem;
	}
	
	.fullImageStoryCardFlexCTAPromoInfoCardTheme .ImageMain
	{
		order: -1;
	}
	
	.fullImageStoryCardFlexCTAPromoInfoCardTheme .ImageMain img
	{
		margin-left: -1rem;
		max-width: unset;
		width: calc(100% + 2rem);
	}
	
	.fullImageStoryCardFlexCTAPromoInfoCardTheme .CTALinkContainer 
	{
		align-self: flex-end;
		
		border: 2px solid currentColor;
		
		border-radius: 3px;
	}
	
	.fullImageStoryCardFlexCTAPromoInfoCardTheme .CTALinkContainer a
	{
		position: relative;
		
		display: flex;
		
		justify-content: right;
		align-items: center;
		
		height: 100%;
		padding: 1rem 5.2778rem 1rem 2.5rem;
		
		text-align: right;
		text-decoration: none;
		
		overflow: hidden;
	}
	
	.fullImageStoryCardFlexCTAPromoInfoCardTheme .CTALinkContainer a:after
	{
		content: url("-/media/translink/icons/shared/cta_link_arrow.svg");
		
		position: absolute;
		
		display: inline-block;
		
		width: 1rem;
		height: 1rem;
		
		top: 50%;
		right: 2.5rem;
		
		transform: translateY(-50%);
	}
</style><link href="fullWidthCTAPromo-infoCardTheme-1.1.0.css" rel="stylesheet"

        integrity="sha256-b/JjZtYeWZXWoGzdUbXgHoVNMdx4IPh+dkzXv5ypK9k=" crossorigin="anonymous">
      <link href="halfWidthCTAPromo-infoCardTheme-1.1.0.css" rel="stylesheet" integrity="sha256-tMJiVA5xhXov4pYkFLqgzbxXEWEJJL2T4Cm1N4Khv/4="

        crossorigin="anonymous">
      <link href="headerLink-infoCardTheme-1.1.1.css" rel="stylesheet" integrity="sha256-7rY87uHEIqzk7rBwhWQRQaeVqbVEa19kW3ZrKjUh9KQ="

        crossorigin="anonymous">
      <style class="indexLink-infoCardTheme-122">
	.indexLinkInfoCardTheme
	{
		position: relative;
		
		display: grid;
		
		grid-template-areas: ". .        .      Chevron	."
							 ". Header   . 		Chevron	."
							 ". .        .      Chevron	."
							 ". CopyMain .      Chevron	."
							 ". .        .      Chevron	.";
		
		grid-template-columns: 2.2222rem 1fr 2rem min-content 2.2222rem;
		grid-template-rows: 2.2222rem auto 0.25rem auto 2.2222rem;
		
		width: 100%;
		min-width: calc(320px - 2rem);
		
		border-radius: 3px;
	}
	
	.indexLinkInfoCardTheme:after
	{
		content: " ";
		
		grid-area: Chevron;
		
		align-self: center;
		
		width: 1.125rem;
		height: 1.125rem;
		
		pointer-events: none;
	}
	
	.indexLinkInfoCardTheme[style*="--chevronColor: " i]:after
	{
		background-color: var(--chevronColor);
		
		mask-repeat: no-repeat;
		mask-image: url("data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAxNSI+PHRpdGxlPmNoZXZyb24tZG93bl9pY29uPC90aXRsZT48cGF0aCBpZD0iY2hldnJvbi1yaWdodCIgZD0iTTIuODQuMDksMTIsOS4yNSwyMS4xOC4wOSwyNCwyLjkxbC0xMiwxMkwwLDIuOTFaIiBmaWxsPSIjMDA1ZGFhIi8+PC9zdmc+");
		
		transform: rotate(-90deg);
	}
	
	.indexLinkInfoCardTheme:not([style*="--chevronColor: " i]):after
	{
		background-repeat: no-repeat;
		background-image: url("data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAxNSI+PHRpdGxlPmNoZXZyb24tZG93bl9pY29uPC90aXRsZT48cGF0aCBpZD0iY2hldnJvbi1yaWdodCIgZD0iTTIuODQuMDksMTIsOS4yNSwyMS4xOC4wOSwyNCwyLjkxbC0xMiwxMkwwLDIuOTFaIiBmaWxsPSIjMDA1ZGFhIi8+PC9zdmc+");
		background-size: contain;
		
		transform: rotate(-90deg);
	}
	
	.indexLinkInfoCardTheme .Header
	{
		display: flex;
		
		align-items: flex-end;
	}
	
	.indexLinkInfoCardTheme .Header h1
	, .indexLinkInfoCardTheme .Header h2
	, .indexLinkInfoCardTheme .Header h3
	, .indexLinkInfoCardTheme .Header h4
	, .indexLinkInfoCardTheme .Header h5
	, .indexLinkInfoCardTheme .Header h6
	{
		font-family: "Fira Sans Regular", Arial, Helvetica, sans-serif !important;
	}
	
	.indexLinkInfoCardTheme .ImageMain
	{
		display: none;
	}
	
	.indexLinkInfoCardTheme .CopyMain
	{
		margin-top: 0px !important;
	}
	
	.indexLinkInfoCardTheme .CTALinkContainer
	{
		visibility: hidden;
	}
	
	.indexLinkInfoCardTheme .CTALinkContainer a
	{
		position: absolute;
		
		top: 0px;
		right: 0px;
		bottom: 0px;
		left: 0px;
		
		font-size: 0px;
		
		visibility: visible;
		
		user-select: none;
	}
</style><style class="storySlide-112">
	.storySlideCTAPromoInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: ". ImageMain ImageMain ImageMain ImageMain ImageMain ."
							 ". ImageMain ImageMain ImageMain ImageMain ImageMain ."
							 ". . . . . . ."
							 ". . Header . . . ."
							 ". . . . . . ."
							 ". . CopyMain . . . ."
							 ". . . . . . ."
							 ". . CTA . . . ."
							 ". . . . . . .";
		
		grid-template-columns: [background-start] 1fr minmax(1rem, 7.7778rem) minmax(19.33335rem, 31.2222rem) 2rem minmax(19.33335rem, 31.2222rem) minmax(1rem, 7.7778rem) 1fr [background-end];
		grid-template-rows: [background-start] auto auto [background-end] minmax(2rem, 1fr) min-content 1rem min-content 1rem minmax(44px, min-content) minmax(2rem, 1fr);
		
		width: 100%;
		height: 100%;
		
		min-width: calc(320px - 2rem);
	}

	.storySlideCTAPromoInfoCardTheme .Background
	{
		position: relative;
		
		overflow: hidden;
	}

	.storySlideCTAPromoInfoCardTheme .ImageMain
	{
		justify-self: center;
		
		position: relative;

		z-index: 8000;
	}

	.storySlideCTAPromoInfoCardTheme .CTALinkContainer 
	{
		grid-area: CTA;
		
		justify-self: flex-start;
		
		border-radius: 3px;
		
		overflow: hidden;
	}

	.storySlideCTAPromoInfoCardTheme .Background > img
	{
		position: absolute;
		
		top: -5px;
		right: -5px;
		bottom: -5px;
		left: -5px;
		
		width: calc(100% + 10px);
		max-width: unset;
		
		filter: blur(5px);
	}

	.storySlideCTAPromoInfoCardTheme .CTALinkContainer a
	{
		display: inline-flex;
		
		justify-content: center;
		align-items: center;
		
		padding: 1rem;
		height: 100%;
		
		background-color: inherit;
		
		font-family: "Fira Sans Bold", Arial, Helvetica, sans-serif;
		
		font-weight: bold;
		
		text-align: center;
		text-decoration: none;
	}
</style><style class="blogPostInfoCardTheme-100">
	.blogPostInfoCardTheme
	{
		display: grid;
		
		grid-template-areas: ". . ."
							 ". ImageMain ."
							 ". . ."
							 ". Header ."
							 ". . ."
							 ". CopyMain ."
							 ". . .";
		
		grid-template-columns: [background-start] 1rem 1fr 1rem [background-end];
		grid-template-rows: [background-start] 1rem min-content 1rem min-content 1rem min-content 1rem [background-end];
		
		width: 100%;
		height: 100%;
		
		min-width: calc(320px - 2rem);
	}
	
	.blogPostInfoCardTheme .Header
	{
		text-decoration: underline;
	}
	
	.blogPostInfoCardTheme .CTALinkContainer 
	{
		grid-area: Header;
		
		height: 100%;
		
		background-color: transparent !important;
		color: transparent !important;
		
		z-index: 1;
	}
	
	.blogPostInfoCardTheme .CTALinkContainer a
	{
		display: block;
		
		height: 100%;
		
		font-size: 0px;
		
		-ms-user-select: none;
		-moz-user-select: none;
		-webkit-user-select: none;
		user-select: none;
	}
</style><style class="iconContentCTAInfoCardTheme-styling">
	@media (min-width: 48em) {
		.iconContentCTAInfoCardTheme
		{
			display: grid;
			
			grid-template-areas: ". . . . ."
								 ". Header Header Header ."
								 ". . . . . "
								 ". ImageMain . CopyMain ."
								 ". . . . ."
								 ". CTA CTA CTA ."
								 ". . . . .";
			
			grid-template-columns: [background-start] 1rem minmax(2.2222rem, 5.5rem) 1rem minmax(auto, 1fr) 1rem [background-end];
			grid-template-rows: [background-start] 1rem min-content 1rem min-content minmax(1rem, 1fr) min-content 1rem[background-end];
			
			width: 100%;
			height: 100%;
			
			min-width: calc(320px - 2rem);
		}
	}
	
	@media not all and (min-width: 48em) {
		.iconContentCTAInfoCardTheme
		{
			display: grid;
			
			grid-template-areas: ". . ."
								 ". Header ."
								 ". . ."
								 ". ImageMain ."
								 ". . ."
								 ". CopyMain ."
								 ". . ."
								 ". CTA ."
								 ". . .";
			
			grid-template-columns: [background-start] 1rem minmax(auto, 1fr) 1rem [background-end];
			grid-template-rows: [background-start] 1rem min-content 1rem min-content 1rem min-content minmax(1rem, 1fr) min-content 1rem [background-end];
			
			width: 100%;
			height: 100%;
			
			min-width: calc(320px - 2rem);
		}
		
		.iconContentCTAInfoCardTheme .ImageMain
		{
			justify-self: center;
			
			max-width: 30%;
		}
	}
	
	.iconContentCTAInfoCardTheme .CTALinkContainer
	{
		grid-area: CTA;
		
		border-radius: 3px;
	}
	
	.iconContentCTAInfoCardTheme .CTALinkContainer a
	{
		display: flex;
		
		justify-content: center;
		align-items: center;
		
		height: 100%;
		padding: 1rem;
		
		text-align: center;
		text-decoration: none;
	}
</style><style class="largeIconContentCTAInfoCardTheme-styling">
	@media (min-width: 48em) {
		.largeIconContentCTAInfoCardTheme
		{
			display: grid;
			
			grid-template-areas: ". . . . ."
								 ". Header Header Header ."
								 ". . . . . "
								 ". ImageMain . CopyMain ."
								 ". . . . ."
								 ". CTA CTA CTA ."
								 ". . . . .";
			
			grid-template-columns: [background-start] 1rem minmax(2.2222rem, 8.3333rem) 1rem minmax(min-content, 1fr) 1rem [background-end];
			grid-template-rows: [background-start] 1rem min-content 1rem min-content minmax(1rem, 1fr) min-content 1rem[background-end];
			
			width: 100%;
			height: 100%;
			
			min-width: calc(320px - 2rem);
		}
	}
	
	@media not all and (min-width: 48em) {
		.largeIconContentCTAInfoCardTheme
		{
			display: grid;
			
			grid-template-areas: ". . ."
								 ". Header ."
								 ". . ."
								 ". ImageMain ."
								 ". . ."
								 ". CopyMain ."
								 ". . ."
								 ". CTA ."
								 ". . .";
			
			grid-template-columns: [background-start] 1rem minmax(min-content, 1fr) 1rem [background-end];
			grid-template-rows: [background-start] 1rem min-content 1rem min-content 1rem min-content minmax(1rem, 1fr) min-content 1rem [background-end];
			
			width: 100%;
			height: 100%;
			
			min-width: calc(320px - 2rem);
		}
		
		.largeIconContentCTAInfoCardTheme .ImageMain
		{
			justify-self: center;
		}
		
		@media (min-resolution: 2dppx) {
			.largeIconContentCTAInfoCardTheme .ImageMain
			{
				max-width: 200px;
				width: 100%;
			}
		}
	}
	
	.largeIconContentCTAInfoCardTheme .CTALinkContainer
	{
		grid-area: CTA;
		
		border-radius: 3px;
	}
	
	.largeIconContentCTAInfoCardTheme .CTALinkContainer a
	{
		display: flex;
		
		justify-content: center;
		align-items: center;
		
		height: 100%;
		padding: 1rem;
		
		text-align: center;
		text-decoration: none;
	}
</style></template> <script>
        ; (() => {
            const FUNCTION_TYPE = "[object Function]";

            //GUARD: do nothing if we cannot confirm we are in TLC debug mode
            if (!window.IS_DBG || Object.prototype.toString.call(window.IS_DBG) !== FUNCTION_TYPE || window.IS_DBG() === false) {
                return;
            }

            var allStyleSheetElements = [];

            var appendStyleSheetElement = () => {
                var nextStyleSheetElement = allStyleSheetElements.shift();

                nextStyleSheetElement && window.requestAnimationFrame && window.requestAnimationFrame(() => {
                    nextStyleSheetElement && document.documentElement.append(nextStyleSheetElement);
                    appendStyleSheetElement && appendStyleSheetElement();
                });
            };

            window.addEventListener("load", () => {
                window.requestIdleCallback && window.requestIdleCallback(() => {
                    var templateElement = document.getElementById("PrefetchableBlockLayouts");
                    var templateElementContent = templateElement && templateElement.tagName === "TEMPLATE" && templateElement.content;

                    //GUARD: do nothing if the target is not actually a <template>
                    if (!templateElementContent) {
                        return;
                    }

                    allStyleSheetElements = Array.from(templateElementContent.children);

                    allStyleSheetElements.length > 0 && appendStyleSheetElement && appendStyleSheetElement();
                }, { timeout: 10000 });
            });
        })();
    </script>
    <!-- Tag Manager Scripts -->
    <!-- END OF Tag Manager Scripts -->
    <!-- Site Body Analytics JS -->
    <!-- Google Tag Manager -->
    <script>
	; (function () {
		//NOTE: do not apply use-strict incase of incompatibility with GTM script
		
		var curURL = window.location.href;
		
		//GUARD: do not run in:
		//sitecore admin panel
		if (curURL.indexOf("/sitecore/") > -1) {
			return;
		}
		
		//GUARD: do nothing if this page is being embedded in an iframe on the same site
		if (window.self.location.href !== window.top.location.href && window.self.location.origin === window.top.location.origin) {
			return;
		}
		
		(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
		new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
		j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
		'https://www.googletagmanager.com/gtm.js?id='+i+dl+ '&gtm_auth=ib9Et0HQ2lWUjFhECqATCA&gtm_preview=env-2&gtm_cookies_win=x';f.parentNode.insertBefore(j,f);
		})(window,document,'script','dataLayer','GTM-PS4MHSN');
	})();
</script><!-- End Google Tag Manager -->
    <!-- END OF Site Body Analytics JS -->
    <script class="finish-user-timing-for-dom-parsing">
        ; (() => {
            window.getElapsedTimeInMilliseconds && window.getElapsedTimeInMilliseconds("body-parsing-timer", "time-spent-parsing-html-body");
        })();
    </script>
  </body>
</html>
